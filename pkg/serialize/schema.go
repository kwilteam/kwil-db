package serialize

import (
	"encoding/json"
	"fmt"
	"strings"

	engineTypes "github.com/kwilteam/kwil-db/pkg/engine/types"
)

type DatasetIdentifier struct {
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

type Schema struct {
	Owner      string       `json:"owner"`
	Name       string       `json:"name"`
	Tables     []*Table     `json:"tables"`
	Actions    []*Action    `json:"actions"`
	Extensions []*Extension `json:"extensions"`
}

type Extension struct {
	Name   string            `json:"name"`
	Config map[string]string `json:"config"`
	Alias  string            `json:"alias"`
}

type Table struct {
	Name        string        `json:"name"`
	Columns     []*Column     `json:"columns"`
	Indexes     []*Index      `json:"indexes"`
	ForeignKeys []*ForeignKey `json:"foreign_keys"`
}

type Column struct {
	Name       string       `json:"name"`
	Type       string       `json:"type"`
	Attributes []*Attribute `json:"attributes,omitempty"`
}

type Attribute struct {
	Type  string `json:"type"`
	Value any    `json:"value"`
}

type Action struct {
	Name   string   `json:"name"`
	Inputs []string `json:"inputs"`
	// Mutability could be empty if the abi is generated by legacy version of kuneiform,
	// default to "update" for backward compatibility
	Mutability string `json:"mutability"`
	// Auxiliaries are the auxiliary types that are required for the action, specifying extra characteristics of the action
	Auxiliaries []string `json:"auxiliaries"`
	Public      bool     `json:"public"`
	Statements  []string `json:"statements"`
}

type Index struct {
	Name    string   `json:"name"`
	Columns []string `json:"columns"`
	Type    string   `json:"type"`
}

type ForeignKey struct {
	// ChildKeys are the columns that are referencing another.
	// For example, in FOREIGN KEY (a) REFERENCES tbl2(b), "a" is the child key
	ChildKeys []string `json:"child_keys"`

	// ParentKeys are the columns that are being referred to.
	// For example, in FOREIGN KEY (a) REFERENCES tbl2(b), "tbl2.b" is the parent key
	ParentKeys []string `json:"parent_keys"`

	// ParentTable is the table that holds the parent columns.
	// For example, in FOREIGN KEY (a) REFERENCES tbl2(b), "tbl2.b" is the parent table
	ParentTable string `json:"parent_table"`

	// Action refers to what the foreign key should do when the parent is altered.
	// This is NOT the same as a database action;
	// however sqlite's docs refer to these as actions,
	// so we should be consistent with that.
	// For example, ON DELETE CASCADE is a foreign key action
	Actions []*ForeignKeyAction `json:"actions"`
}

// ForeignKeyAction is used to specify what should occur
// if a parent key is updated or deleted
type ForeignKeyAction struct {
	// On can be either "UPDATE" or "DELETE"
	On string `json:"on"`

	// Do specifies what a foreign key action should do
	Do string `json:"do"`
}

// MutabilityType is the type of mutability
type MutabilityType string

func (t MutabilityType) String() string {
	return string(t)
}

const (
	MutabilityUpdate MutabilityType = "update"
	MutabilityView   MutabilityType = "view"
)

// AuxiliaryType is the type of auxiliary
type AuxiliaryType string

func (t AuxiliaryType) String() string {
	return string(t)
}

const (
	// AuxiliaryTypeMustSign is used to specify that an action need signature, it is used for `view` action.
	AuxiliaryTypeMustSign AuxiliaryType = "mustsign"
)

func convertSchema(schema *Schema) (*engineTypes.Schema, error) {
	actions, err := convertActionsToDto(schema.Actions)
	if err != nil {
		return nil, err
	}

	tables, err := convertTablesToDto(schema.Tables)
	if err != nil {
		return nil, err
	}

	return &engineTypes.Schema{
		Name:       schema.Name,
		Owner:      schema.Owner,
		Procedures: actions,
		Tables:     tables,
		Extensions: convertExtensionsToDto(schema.Extensions),
	}, nil
}

func convertActions(actions []*engineTypes.Procedure) []*Action {
	entityActions := make([]*Action, len(actions))
	for i, action := range actions {
		entityActions[i] = &Action{
			Name:       action.Name,
			Inputs:     action.Args,
			Public:     action.Public,
			Statements: action.Statements,
		}
	}

	return entityActions
}

func convertTables(tables []*engineTypes.Table) []*Table {
	entityTables := make([]*Table, len(tables))
	for i, table := range tables {
		entityTables[i] = &Table{
			Name:    table.Name,
			Columns: convertColumns(table.Columns),
			Indexes: convertIndexes(table.Indexes),
		}
	}

	return entityTables
}

func convertColumns(columns []*engineTypes.Column) []*Column {
	entityColumns := make([]*Column, len(columns))
	for i, column := range columns {
		entityColumns[i] = &Column{
			Name:       column.Name,
			Type:       column.Type.String(),
			Attributes: convertAttributes(column.Attributes),
		}
	}

	return entityColumns
}

func convertAttributes(attributes []*engineTypes.Attribute) []*Attribute {
	entityAttributes := make([]*Attribute, len(attributes))
	for i, attribute := range attributes {
		entityAttributes[i] = &Attribute{
			Type:  attribute.Type.String(),
			Value: attribute.Value,
		}
	}

	return entityAttributes
}

func convertIndexes(indexes []*engineTypes.Index) []*Index {
	entityIndexes := make([]*Index, len(indexes))
	for i, index := range indexes {
		entityIndexes[i] = &Index{
			Name:    index.Name,
			Columns: index.Columns,
			Type:    index.Type.String(),
		}
	}

	return entityIndexes
}

func convertActionsToDto(actions []*Action) ([]*engineTypes.Procedure, error) {
	entityActions := make([]*engineTypes.Procedure, len(actions))
	for i, action := range actions {
		mods, err := getModifiers(action)
		if err != nil {
			return nil, err
		}

		entityActions[i] = &engineTypes.Procedure{
			Name:       action.Name,
			Args:       action.Inputs,
			Public:     action.Public,
			Modifiers:  mods,
			Statements: action.Statements,
		}
	}

	for i := range entityActions {
		err := entityActions[i].Clean()
		if err != nil {
			return nil, err
		}
	}

	return entityActions, nil
}

func getModifiers(action *Action) ([]engineTypes.Modifier, error) {
	mods := make([]engineTypes.Modifier, 0)

	if strings.EqualFold(action.Mutability, "view") {
		mods = append(mods, engineTypes.ModifierView)
	}

	for _, aux := range action.Auxiliaries {
		switch aux {
		case "mustsign":
			mods = append(mods, engineTypes.ModifierAuthenticated)
		default:
			return nil, fmt.Errorf("modifier %s not supported", aux)
		}
	}

	return mods, nil
}

func convertExtensionsToDto(extensions []*Extension) []*engineTypes.Extension {
	entityExtensions := make([]*engineTypes.Extension, len(extensions))
	for i, extension := range extensions {
		entityExtensions[i] = &engineTypes.Extension{
			Name:           extension.Name,
			Initialization: extension.Config,
			Alias:          extension.Alias,
		}
	}

	return entityExtensions
}

func convertTablesToDto(tables []*Table) ([]*engineTypes.Table, error) {
	entityTables := make([]*engineTypes.Table, len(tables))
	for i, table := range tables {
		entityTables[i] = &engineTypes.Table{
			Name:        table.Name,
			Columns:     convertColumnsToDto(table.Columns),
			Indexes:     convertIndexesToDto(table.Indexes),
			ForeignKeys: convertForeignKeysToDto(table.ForeignKeys),
		}
	}

	for i := range entityTables {
		err := entityTables[i].Clean()
		if err != nil {
			return nil, err
		}
	}

	return entityTables, nil
}

func convertForeignKeysToDto(foreignKeys []*ForeignKey) []*engineTypes.ForeignKey {
	entityForeignKeys := make([]*engineTypes.ForeignKey, len(foreignKeys))
	for i, foreignKey := range foreignKeys {
		entityForeignKeys[i] = &engineTypes.ForeignKey{
			ChildKeys:   foreignKey.ChildKeys,
			ParentKeys:  foreignKey.ParentKeys,
			ParentTable: foreignKey.ParentTable,
			Actions:     convertForeignKeyActionsToDto(foreignKey.Actions),
		}
	}

	return entityForeignKeys
}

func convertForeignKeyActionsToDto(foreignKeyActions []*ForeignKeyAction) []*engineTypes.ForeignKeyAction {
	entityForeignKeyActions := make([]*engineTypes.ForeignKeyAction, len(foreignKeyActions))
	for i, foreignKeyAction := range foreignKeyActions {
		entityForeignKeyActions[i] = &engineTypes.ForeignKeyAction{
			On: engineTypes.ForeignKeyActionOn(foreignKeyAction.On),
			Do: engineTypes.ForeignKeyActionDo(foreignKeyAction.Do),
		}
	}

	return entityForeignKeyActions
}

func convertColumnsToDto(columns []*Column) []*engineTypes.Column {
	entityColumns := make([]*engineTypes.Column, len(columns))
	for i, column := range columns {
		entityColumns[i] = &engineTypes.Column{
			Name:       column.Name,
			Type:       engineTypes.DataType(column.Type),
			Attributes: convertAttributesToDto(column.Attributes),
		}
	}

	return entityColumns
}

func convertAttributesToDto(attributes []*Attribute) []*engineTypes.Attribute {
	entityAttributes := make([]*engineTypes.Attribute, len(attributes))
	for i, attribute := range attributes {
		entityAttributes[i] = &engineTypes.Attribute{
			Type:  engineTypes.AttributeType(attribute.Type),
			Value: attribute.Value,
		}
	}

	return entityAttributes
}

func convertIndexesToDto(indexes []*Index) []*engineTypes.Index {
	entityIndexes := make([]*engineTypes.Index, len(indexes))
	for i, index := range indexes {
		entityIndexes[i] = &engineTypes.Index{
			Name:    index.Name,
			Columns: index.Columns,
			Type:    engineTypes.IndexType(index.Type),
		}
	}

	return entityIndexes
}

func UnmarshalSchema(b []byte) (*Schema, error) {
	var schema Schema
	err := json.Unmarshal(b, &schema)
	if err != nil {
		return nil, err
	}
	return &schema, nil
}

func UnmarshalDatasetIdentifier(b []byte) (*DatasetIdentifier, error) {
	var dsIdent DatasetIdentifier
	err := json.Unmarshal(b, &dsIdent)
	if err != nil {
		return nil, err
	}
	return &dsIdent, nil
}
