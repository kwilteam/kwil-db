package crypto

import (
	"crypto/ecdsa"
	"errors"
	"fmt"

	cmtCrypto "github.com/cometbft/cometbft/crypto"
	cmtjson "github.com/cometbft/cometbft/libs/json"
	"github.com/ethereum/go-ethereum/accounts"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	ec "github.com/ethereum/go-ethereum/crypto"
)

var ErrInvalidSignature = errors.New("invalid signature")

type SignatureType int32

const (
	SIGNATURE_TYPE_INVALID SignatureType = iota
	PK_SECP256K1_UNCOMPRESSED
	ACCOUNT_SECP256K1_UNCOMPRESSED
	ACCOUNT_SECP256K1_UNCOMPRESSED_STRUCTURED_v1
	PK_ED25519
	END_SIGNATURE_TYPE
)

func (s *SignatureType) IsValid() error {
	if *s < SIGNATURE_TYPE_INVALID || *s >= END_SIGNATURE_TYPE {
		return fmt.Errorf("invalid signature type '%d'", *s)
	}
	return nil
}

func (s SignatureType) Int32() int32 {
	return int32(s)
}

type Signature struct {
	Signature []byte        `json:"signature_bytes"`
	Type      SignatureType `json:"signature_type"`
}

func Sign(data []byte, k *ecdsa.PrivateKey) (*Signature, error) {
	signature := Signature{
		Type: PK_SECP256K1_UNCOMPRESSED,
	}
	hash := ec.Keccak256Hash(data)
	sig, err := ec.Sign(hash.Bytes(), k)
	if err != nil {
		return &signature, err
	}

	signature.Signature = sig
	return &signature, nil
}

func (s *Signature) Check(sender string, data []byte) error {
	ok, err := CheckSignature(sender, s, data)
	if err != nil {
		return err
	}

	if !ok {
		return ErrInvalidSignature
	}

	return nil
}

func ECDSAFromHex(hex string) (*ecdsa.PrivateKey, error) {
	return ec.HexToECDSA(hex)
}

func AddressFromPrivateKey(key *ecdsa.PrivateKey) string {
	caddr := ec.PubkeyToAddress(key.PublicKey)
	return caddr.Hex()
}

func IsValidAddress(addr string) bool {
	return common.IsHexAddress(addr)
}

func HexFromECDSAPrivateKey(key *ecdsa.PrivateKey) string {
	return hexutil.Encode(ec.FromECDSA(key))[2:]
}

func CheckSignature(addr string, sig *Signature, data []byte) (bool, error) {
	if addr == "" {
		return false, fmt.Errorf("transaction does not have a sender address")
	}
	switch sig.Type {
	case PK_SECP256K1_UNCOMPRESSED:
		return checkSignaturePkSECP256k1Uncompressed(addr, sig.Signature, data)
	case ACCOUNT_SECP256K1_UNCOMPRESSED:
		return checkSignatureAccountSECP256k1Uncompressed(addr, sig.Signature, data)
	case PK_ED25519:
		return checkSignatureED25519(addr, sig.Signature, data)
	default:
		return false, fmt.Errorf("unknown signature indicator: %d", sig.Type)
	}
}

func checkSignatureED25519(addr string, sig []byte, data []byte) (bool, error) {
	var publicKey cmtCrypto.PubKey
	key := fmt.Sprintf(`{"type":"tendermint/PubKeyEd25519","value":%s}`, addr)
	fmt.Println("Key:", key)

	err := cmtjson.Unmarshal([]byte(key), &publicKey)
	if err != nil {
		return false, fmt.Errorf("failed to unmarshal validator public key: %w", err)
	}
	fmt.Println("publicKey: ", publicKey)

	valid := publicKey.VerifySignature(data, sig)
	if valid {
		return true, nil
	} else {
		return false, fmt.Errorf("signature verification failed")
	}
}

func checkSigHash(addr string, sig, hash []byte) (bool, error) {
	recoveredPubKey, err := ec.SigToPub(hash, sig)
	if err != nil {
		return false, fmt.Errorf("failed to recover public key: %w", err)
	}

	derAddr := ec.PubkeyToAddress(*recoveredPubKey)
	return derAddr == common.HexToAddress(addr), nil
	// NOTE: We compare the address [N]byte to be robust to string formatting
	// details, namely deviations from EIP55 and prefix (or not).
}

// This would be for a signature generated by a private key.  Likely EVM chains
func checkSignaturePkSECP256k1Uncompressed(addr string, sig []byte, data []byte) (bool, error) {
	hash := ec.Keccak256Hash(data)
	return checkSigHash(addr, sig, hash[:])
}

// checkSignatureAccount checks a signature that was generated by an config instead of a private key
// generally this would mean a signature from MetaMask / equivalent for EVM chains
func checkSignatureAccountSECP256k1Uncompressed(addr string, sig []byte, data []byte) (bool, error) {
	msg := accounts.TextHash(data)
	if sig[ec.RecoveryIDOffset] == 27 || sig[ec.RecoveryIDOffset] == 28 {
		sig[ec.RecoveryIDOffset] -= 27 // Transform yellow paper V from 27/28 to 0/1
	}
	return checkSigHash(addr, sig, msg)
}
