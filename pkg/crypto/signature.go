package crypto

import (
	"crypto/ecdsa"
	"fmt"

	"github.com/ethereum/go-ethereum/accounts"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	ec "github.com/ethereum/go-ethereum/crypto"
)

type SignatureType int32

const (
	SIGNATURE_TYPE_INVALID SignatureType = iota
	PK_SECP256K1_UNCOMPRESSED
	ACCOUNT_SECP256K1_UNCOMPRESSED
	END_SIGNATURE_TYPE
)

type Signature struct {
	Signature []byte        `json:"signature_bytes"`
	Type      SignatureType `json:"signature_type"`
}

func Sign(data []byte, k *ecdsa.PrivateKey) (Signature, error) {
	signature := Signature{
		Type: PK_SECP256K1_UNCOMPRESSED,
	}
	hash := ec.Keccak256Hash(data)
	sig, err := ec.Sign(hash.Bytes(), k)
	if err != nil {
		return signature, err
	}

	signature.Signature = sig
	return signature, nil
}

func ECDSAFromHex(hex string) (*ecdsa.PrivateKey, error) {
	return ec.HexToECDSA(hex)
}

func AddressFromPrivateKey(key *ecdsa.PrivateKey) (string, error) {

	caddr := ec.PubkeyToAddress(key.PublicKey)
	return caddr.Hex(), nil
}

func HexFromECDSAPrivateKey(key *ecdsa.PrivateKey) string {
	return hexutil.Encode(ec.FromECDSA(key))
}

func CheckSignature(addr string, sig Signature, data []byte) (bool, error) {
	if addr == "" {
		return false, fmt.Errorf("transaction does not have a sender address")
	}
	switch sig.Type {
	case PK_SECP256K1_UNCOMPRESSED:
		return checkSignaturePkSECP256k1Uncompressed(addr, sig.Signature, data)
	case ACCOUNT_SECP256K1_UNCOMPRESSED:
		return checkSignatureAccountSECP256k1Uncompressed(addr, sig.Signature, data)
	default:
		return false, fmt.Errorf("unknown signature indicator: %d", sig.Type)
	}
}

// This would be for a signature generated by a private key.  Likely EVM chains
func checkSignaturePkSECP256k1Uncompressed(addr string, sig []byte, data []byte) (bool, error) {
	hash := ec.Keccak256Hash(data)

	pubBytes, err := ec.Ecrecover(hash.Bytes(), sig)
	if err != nil {
		return false, fmt.Errorf("ecrecover failed: %w", err)
	}

	pub, err := ec.UnmarshalPubkey(pubBytes)
	if err != nil {
		return false, fmt.Errorf("failed to unmarshal public key: %w", err)
	}
	derAddr := ec.PubkeyToAddress(*pub)

	return derAddr == common.HexToAddress(addr), nil
}

// checkSignatureAccount checks a signature that was generated by an config instead of a private key
// generally this would mean a signature from MetaMask / equivalent for EVM chains
func checkSignatureAccountSECP256k1Uncompressed(addr string, sig []byte, data []byte) (bool, error) {
	msg := accounts.TextHash(data)
	if sig[ec.RecoveryIDOffset] == 27 || sig[ec.RecoveryIDOffset] == 28 {
		sig[ec.RecoveryIDOffset] -= 27 // Transform yellow paper V from 27/28 to 0/1
	}

	recoveredPubKey, err := ec.SigToPub(msg, sig)
	if err != nil {
		return false, fmt.Errorf("failed to recover public key: %w", err)
	}

	derAddr := ec.PubkeyToAddress(*recoveredPubKey)
	return addr == derAddr.Hex(), nil
}
