// Code generated from KuneiformParser.g4 by ANTLR 4.13.1. DO NOT EDIT.

package gen // KuneiformParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type KuneiformParser struct {
	*antlr.BaseParser
}

var KuneiformParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func kuneiformparserParserInit() {
	staticData := &KuneiformParserParserStaticData
	staticData.LiteralNames = []string{
		"", "'{'", "'}'", "'['", "']'", "':'", "';'", "'('", "')'", "','", "'@'",
		"'!'", "'.'", "'||'", "'*'", "'='", "'=='", "'#'", "'$'", "'%'", "'+'",
		"'-'", "'/'", "", "'<'", "'<='", "'>'", "'>='", "'::'", "'_'", "':='",
		"'..'", "'database'", "'use'", "'table'", "'action'", "'procedure'",
		"'public'", "'private'", "'view'", "'owner'", "'min'", "'max'", "'minlen'",
		"'maxlen'", "'unique'", "'foreign'", "'primary'", "'key'", "'on'", "'do'",
		"'cascade'", "'restrict'", "'set'", "'default'", "'null'", "'delete'",
		"'update'", "'references'", "'ref'", "'not'", "'index'", "'and'", "'or'",
		"'like'", "'in'", "'between'", "'is'", "'exists'", "'all'", "'any'",
		"'join'", "'left'", "'right'", "'inner'", "'as'", "'asc'", "'desc'",
		"'limit'", "'offset'", "'order'", "'by'", "'group'", "'having'", "'returns'",
		"'no'", "'notnull'", "'with'", "'case'", "'when'", "'then'", "'end'",
		"'distinct'", "'from'", "'where'", "'collate'", "'select'", "'insert'",
		"'values'", "'full'", "'union'", "'intersect'", "'except'", "'nulls'",
		"'first'", "'last'", "'returning'", "'into'", "'conflict'", "'nothing'",
		"'for'", "'if'", "'elseif'", "'else'", "'break'", "'return'", "'next'",
		"", "'true'", "'false'", "", "", "", "", "'on_update'", "'on_delete'",
		"'set_default'", "'set_null'", "'no_action'",
	}
	staticData.SymbolicNames = []string{
		"", "LBRACE", "RBRACE", "LBRACKET", "RBRACKET", "COL", "SCOL", "LPAREN",
		"RPAREN", "COMMA", "AT", "EXCL", "PERIOD", "CONCAT", "STAR", "EQUALS",
		"EQUATE", "HASH", "DOLLAR", "MOD", "PLUS", "MINUS", "DIV", "NEQ", "LT",
		"LTE", "GT", "GTE", "TYPE_CAST", "UNDERSCORE", "ASSIGN", "RANGE", "DATABASE",
		"USE", "TABLE", "ACTION", "PROCEDURE", "PUBLIC", "PRIVATE", "VIEW",
		"OWNER", "MIN", "MAX", "MINLEN", "MAXLEN", "UNIQUE", "FOREIGN", "PRIMARY",
		"KEY", "ON", "DO", "CASCADE", "RESTRICT", "SET", "DEFAULT", "NULL",
		"DELETE", "UPDATE", "REFERENCES", "REF", "NOT", "INDEX", "AND", "OR",
		"LIKE", "IN", "BETWEEN", "IS", "EXISTS", "ALL", "ANY", "JOIN", "LEFT",
		"RIGHT", "INNER", "AS", "ASC", "DESC", "LIMIT", "OFFSET", "ORDER", "BY",
		"GROUP", "HAVING", "RETURNS", "NO", "NOTNULL", "WITH", "CASE", "WHEN",
		"THEN", "END", "DISTINCT", "FROM", "WHERE", "COLLATE", "SELECT", "INSERT",
		"VALUES", "FULL", "UNION", "INTERSECT", "EXCEPT", "NULLS", "FIRST",
		"LAST", "RETURNING", "INTO", "CONFLICT", "NOTHING", "FOR", "IF", "ELSEIF",
		"ELSE", "BREAK", "RETURN", "NEXT", "STRING_", "TRUE", "FALSE", "DIGITS_",
		"BINARY_", "LEGACY_PRIMARY_KEY", "LEGACY_FOREIGN_KEY", "LEGACY_ON_UPDATE",
		"LEGACY_ON_DELETE", "LEGACY_SET_DEFAULT", "LEGACY_SET_NULL", "LEGACY_NO_ACTION",
		"IDENTIFIER", "VARIABLE", "CONTEXTUAL_VARIABLE", "HASH_IDENTIFIER",
		"WS", "BLOCK_COMMENT", "LINE_COMMENT",
	}
	staticData.RuleNames = []string{
		"entry", "literal", "identifier_list", "type", "type_cast", "variable",
		"variable_list", "schema", "annotation", "database_declaration", "use_declaration",
		"table_declaration", "column_def", "index_def", "foreign_key_def", "foreign_key_action",
		"type_list", "named_type_list", "typed_variable_list", "constraint",
		"access_modifier", "action_declaration", "procedure_declaration", "foreign_procedure_declaration",
		"procedure_return", "sql", "sql_statement", "common_table_expression",
		"select_statement", "compound_operator", "ordering_term", "select_core",
		"relation", "join", "result_column", "update_statement", "update_set_clause",
		"insert_statement", "upsert_clause", "delete_statement", "sql_expr",
		"sql_expr_list", "sql_function_call", "action_block", "action_statement",
		"procedure_block", "procedure_expr", "procedure_expr_list", "statement",
		"variable_or_underscore", "procedure_function_call", "if_then_block",
		"range",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 135, 1114, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 1, 0, 1, 0, 1, 0, 1, 0, 3, 0, 111, 8, 0, 1, 0, 1, 0, 1, 1, 1, 1,
		3, 1, 117, 8, 1, 1, 1, 1, 1, 3, 1, 121, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 3, 1, 129, 8, 1, 1, 2, 1, 2, 1, 2, 5, 2, 134, 8, 2, 10, 2, 12,
		2, 137, 9, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 145, 8, 3, 1, 3,
		1, 3, 3, 3, 149, 8, 3, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 6, 1, 6, 1, 6,
		5, 6, 159, 8, 6, 10, 6, 12, 6, 162, 9, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7,
		1, 7, 5, 7, 170, 8, 7, 10, 7, 12, 7, 173, 9, 7, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 5, 8, 184, 8, 8, 10, 8, 12, 8, 187, 9, 8,
		3, 8, 189, 8, 8, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 5, 10, 207, 8, 10, 10,
		10, 12, 10, 210, 9, 10, 1, 10, 1, 10, 3, 10, 214, 8, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3,
		11, 228, 8, 11, 5, 11, 230, 8, 11, 10, 11, 12, 11, 233, 9, 11, 1, 11, 1,
		11, 1, 12, 1, 12, 1, 12, 5, 12, 240, 8, 12, 10, 12, 12, 12, 243, 9, 12,
		1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 3, 14, 254,
		8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 5,
		14, 265, 8, 14, 10, 14, 12, 14, 268, 9, 14, 1, 15, 1, 15, 1, 15, 3, 15,
		273, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 278, 8, 15, 3, 15, 280, 8, 15,
		1, 15, 3, 15, 283, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 288, 8, 15, 1, 15,
		1, 15, 1, 15, 1, 15, 3, 15, 294, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 299,
		8, 15, 1, 15, 3, 15, 302, 8, 15, 1, 16, 1, 16, 1, 16, 5, 16, 307, 8, 16,
		10, 16, 12, 16, 310, 9, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 5, 17, 317,
		8, 17, 10, 17, 12, 17, 320, 9, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 5, 18, 328, 8, 18, 10, 18, 12, 18, 331, 9, 18, 1, 19, 1, 19, 1, 19,
		1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19,
		356, 8, 19, 1, 19, 1, 19, 1, 19, 3, 19, 361, 8, 19, 3, 19, 363, 8, 19,
		1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 371, 8, 19, 1, 20, 1,
		20, 1, 21, 5, 21, 376, 8, 21, 10, 21, 12, 21, 379, 9, 21, 1, 21, 1, 21,
		1, 21, 1, 21, 3, 21, 385, 8, 21, 1, 21, 1, 21, 4, 21, 389, 8, 21, 11, 21,
		12, 21, 390, 1, 21, 1, 21, 1, 21, 1, 21, 1, 22, 5, 22, 398, 8, 22, 10,
		22, 12, 22, 401, 9, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 407, 8, 22,
		1, 22, 1, 22, 4, 22, 411, 8, 22, 11, 22, 12, 22, 412, 1, 22, 3, 22, 416,
		8, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1,
		23, 3, 23, 428, 8, 23, 1, 23, 1, 23, 3, 23, 432, 8, 23, 1, 24, 1, 24, 3,
		24, 436, 8, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24,
		3, 24, 446, 8, 24, 1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 26, 5,
		26, 455, 8, 26, 10, 26, 12, 26, 458, 9, 26, 3, 26, 460, 8, 26, 1, 26, 1,
		26, 1, 26, 1, 26, 3, 26, 466, 8, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27,
		5, 27, 473, 8, 27, 10, 27, 12, 27, 476, 9, 27, 3, 27, 478, 8, 27, 1, 27,
		1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 1, 28, 5, 28, 490,
		8, 28, 10, 28, 12, 28, 493, 9, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 5,
		28, 500, 8, 28, 10, 28, 12, 28, 503, 9, 28, 3, 28, 505, 8, 28, 1, 28, 1,
		28, 3, 28, 509, 8, 28, 1, 28, 1, 28, 3, 28, 513, 8, 28, 1, 29, 1, 29, 3,
		29, 517, 8, 29, 1, 29, 1, 29, 3, 29, 521, 8, 29, 1, 30, 1, 30, 3, 30, 525,
		8, 30, 1, 30, 1, 30, 3, 30, 529, 8, 30, 1, 31, 1, 31, 3, 31, 533, 8, 31,
		1, 31, 1, 31, 1, 31, 5, 31, 538, 8, 31, 10, 31, 12, 31, 541, 9, 31, 1,
		31, 1, 31, 1, 31, 5, 31, 546, 8, 31, 10, 31, 12, 31, 549, 9, 31, 3, 31,
		551, 8, 31, 1, 31, 1, 31, 3, 31, 555, 8, 31, 1, 31, 1, 31, 1, 31, 1, 31,
		1, 31, 3, 31, 562, 8, 31, 3, 31, 564, 8, 31, 1, 32, 1, 32, 3, 32, 568,
		8, 32, 1, 32, 3, 32, 571, 8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 577,
		8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 583, 8, 32, 1, 32, 1, 32, 3,
		32, 587, 8, 32, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 34, 1, 34,
		3, 34, 597, 8, 34, 1, 34, 3, 34, 600, 8, 34, 1, 34, 1, 34, 3, 34, 604,
		8, 34, 1, 34, 3, 34, 607, 8, 34, 1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 613,
		8, 35, 1, 35, 1, 35, 1, 35, 1, 35, 5, 35, 619, 8, 35, 10, 35, 12, 35, 622,
		9, 35, 1, 35, 1, 35, 1, 35, 5, 35, 627, 8, 35, 10, 35, 12, 35, 630, 9,
		35, 3, 35, 632, 8, 35, 1, 35, 1, 35, 3, 35, 636, 8, 35, 1, 36, 1, 36, 1,
		36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 647, 8, 37, 1, 37,
		1, 37, 1, 37, 1, 37, 3, 37, 653, 8, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1,
		37, 1, 37, 1, 37, 1, 37, 1, 37, 5, 37, 664, 8, 37, 10, 37, 12, 37, 667,
		9, 37, 1, 37, 3, 37, 670, 8, 37, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1,
		38, 1, 38, 3, 38, 679, 8, 38, 3, 38, 681, 8, 38, 1, 38, 1, 38, 1, 38, 1,
		38, 1, 38, 1, 38, 1, 38, 5, 38, 690, 8, 38, 10, 38, 12, 38, 693, 9, 38,
		1, 38, 1, 38, 3, 38, 697, 8, 38, 3, 38, 699, 8, 38, 1, 39, 1, 39, 1, 39,
		1, 39, 1, 39, 3, 39, 706, 8, 39, 1, 39, 1, 39, 3, 39, 710, 8, 39, 1, 40,
		1, 40, 1, 40, 3, 40, 715, 8, 40, 1, 40, 1, 40, 3, 40, 719, 8, 40, 1, 40,
		1, 40, 3, 40, 723, 8, 40, 1, 40, 1, 40, 3, 40, 727, 8, 40, 1, 40, 1, 40,
		3, 40, 731, 8, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 737, 8, 40, 1, 40,
		1, 40, 1, 40, 1, 40, 3, 40, 743, 8, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1,
		40, 4, 40, 750, 8, 40, 11, 40, 12, 40, 751, 1, 40, 1, 40, 3, 40, 756, 8,
		40, 1, 40, 1, 40, 1, 40, 3, 40, 761, 8, 40, 1, 40, 3, 40, 764, 8, 40, 1,
		40, 1, 40, 1, 40, 1, 40, 3, 40, 770, 8, 40, 3, 40, 772, 8, 40, 1, 40, 1,
		40, 1, 40, 1, 40, 1, 40, 3, 40, 779, 8, 40, 1, 40, 1, 40, 1, 40, 1, 40,
		3, 40, 785, 8, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1,
		40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40,
		1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 812, 8, 40, 1,
		40, 1, 40, 1, 40, 1, 40, 3, 40, 818, 8, 40, 1, 40, 1, 40, 3, 40, 822, 8,
		40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 828, 8, 40, 1, 40, 1, 40, 1, 40,
		1, 40, 1, 40, 3, 40, 835, 8, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1,
		40, 3, 40, 843, 8, 40, 1, 40, 1, 40, 1, 40, 5, 40, 848, 8, 40, 10, 40,
		12, 40, 851, 9, 40, 1, 41, 1, 41, 1, 41, 5, 41, 856, 8, 41, 10, 41, 12,
		41, 859, 9, 41, 1, 42, 1, 42, 1, 42, 3, 42, 864, 8, 42, 1, 42, 1, 42, 3,
		42, 868, 8, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42,
		1, 42, 3, 42, 879, 8, 42, 1, 42, 1, 42, 3, 42, 883, 8, 42, 1, 43, 1, 43,
		1, 43, 5, 43, 888, 8, 43, 10, 43, 12, 43, 891, 9, 43, 1, 44, 1, 44, 1,
		44, 1, 44, 3, 44, 897, 8, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 903, 8,
		44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 910, 8, 44, 1, 44, 3, 44,
		913, 8, 44, 1, 45, 5, 45, 916, 8, 45, 10, 45, 12, 45, 919, 9, 45, 1, 46,
		1, 46, 1, 46, 3, 46, 924, 8, 46, 1, 46, 1, 46, 3, 46, 928, 8, 46, 1, 46,
		1, 46, 3, 46, 932, 8, 46, 1, 46, 1, 46, 3, 46, 936, 8, 46, 1, 46, 1, 46,
		3, 46, 940, 8, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 946, 8, 46, 1, 46,
		1, 46, 3, 46, 950, 8, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46,
		3, 46, 969, 8, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 975, 8, 46, 5, 46,
		977, 8, 46, 10, 46, 12, 46, 980, 9, 46, 1, 47, 1, 47, 1, 47, 5, 47, 985,
		8, 47, 10, 47, 12, 47, 988, 9, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1,
		48, 1, 48, 5, 48, 997, 8, 48, 10, 48, 12, 48, 1000, 9, 48, 1, 48, 1, 48,
		3, 48, 1004, 8, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1,
		48, 1, 48, 1, 48, 3, 48, 1016, 8, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48,
		1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 1028, 8, 48, 1, 48, 1, 48, 5,
		48, 1032, 8, 48, 10, 48, 12, 48, 1035, 9, 48, 1, 48, 1, 48, 1, 48, 1, 48,
		1, 48, 1, 48, 5, 48, 1043, 8, 48, 10, 48, 12, 48, 1046, 9, 48, 1, 48, 1,
		48, 1, 48, 5, 48, 1051, 8, 48, 10, 48, 12, 48, 1054, 9, 48, 1, 48, 3, 48,
		1057, 8, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3,
		48, 1067, 8, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48,
		1076, 8, 48, 1, 49, 1, 49, 1, 50, 1, 50, 1, 50, 3, 50, 1083, 8, 50, 1,
		50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 1094,
		8, 50, 1, 50, 1, 50, 3, 50, 1098, 8, 50, 1, 51, 1, 51, 1, 51, 5, 51, 1103,
		8, 51, 10, 51, 12, 51, 1106, 9, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52,
		1, 52, 1, 52, 0, 2, 80, 92, 53, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20,
		22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56,
		58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92,
		94, 96, 98, 100, 102, 104, 0, 14, 1, 0, 20, 21, 1, 0, 118, 119, 1, 0, 130,
		131, 3, 0, 45, 45, 47, 47, 61, 61, 1, 0, 58, 59, 1, 0, 37, 40, 1, 0, 76,
		77, 1, 0, 104, 105, 2, 0, 72, 74, 99, 99, 2, 0, 20, 21, 60, 60, 2, 0, 15,
		16, 23, 27, 3, 0, 14, 14, 19, 19, 22, 22, 2, 0, 11, 11, 20, 21, 2, 0, 29,
		29, 130, 130, 1273, 0, 110, 1, 0, 0, 0, 2, 128, 1, 0, 0, 0, 4, 130, 1,
		0, 0, 0, 6, 138, 1, 0, 0, 0, 8, 150, 1, 0, 0, 0, 10, 153, 1, 0, 0, 0, 12,
		155, 1, 0, 0, 0, 14, 163, 1, 0, 0, 0, 16, 174, 1, 0, 0, 0, 18, 192, 1,
		0, 0, 0, 20, 196, 1, 0, 0, 0, 22, 219, 1, 0, 0, 0, 24, 236, 1, 0, 0, 0,
		26, 244, 1, 0, 0, 0, 28, 253, 1, 0, 0, 0, 30, 279, 1, 0, 0, 0, 32, 303,
		1, 0, 0, 0, 34, 311, 1, 0, 0, 0, 36, 321, 1, 0, 0, 0, 38, 370, 1, 0, 0,
		0, 40, 372, 1, 0, 0, 0, 42, 377, 1, 0, 0, 0, 44, 399, 1, 0, 0, 0, 46, 421,
		1, 0, 0, 0, 48, 433, 1, 0, 0, 0, 50, 447, 1, 0, 0, 0, 52, 459, 1, 0, 0,
		0, 54, 467, 1, 0, 0, 0, 56, 485, 1, 0, 0, 0, 58, 520, 1, 0, 0, 0, 60, 522,
		1, 0, 0, 0, 62, 530, 1, 0, 0, 0, 64, 586, 1, 0, 0, 0, 66, 588, 1, 0, 0,
		0, 68, 606, 1, 0, 0, 0, 70, 608, 1, 0, 0, 0, 72, 637, 1, 0, 0, 0, 74, 641,
		1, 0, 0, 0, 76, 671, 1, 0, 0, 0, 78, 700, 1, 0, 0, 0, 80, 771, 1, 0, 0,
		0, 82, 852, 1, 0, 0, 0, 84, 882, 1, 0, 0, 0, 86, 889, 1, 0, 0, 0, 88, 912,
		1, 0, 0, 0, 90, 917, 1, 0, 0, 0, 92, 949, 1, 0, 0, 0, 94, 981, 1, 0, 0,
		0, 96, 1075, 1, 0, 0, 0, 98, 1077, 1, 0, 0, 0, 100, 1097, 1, 0, 0, 0, 102,
		1099, 1, 0, 0, 0, 104, 1109, 1, 0, 0, 0, 106, 111, 3, 14, 7, 0, 107, 111,
		3, 50, 25, 0, 108, 111, 3, 86, 43, 0, 109, 111, 3, 90, 45, 0, 110, 106,
		1, 0, 0, 0, 110, 107, 1, 0, 0, 0, 110, 108, 1, 0, 0, 0, 110, 109, 1, 0,
		0, 0, 111, 112, 1, 0, 0, 0, 112, 113, 5, 0, 0, 1, 113, 1, 1, 0, 0, 0, 114,
		129, 5, 117, 0, 0, 115, 117, 7, 0, 0, 0, 116, 115, 1, 0, 0, 0, 116, 117,
		1, 0, 0, 0, 117, 118, 1, 0, 0, 0, 118, 129, 5, 120, 0, 0, 119, 121, 7,
		0, 0, 0, 120, 119, 1, 0, 0, 0, 120, 121, 1, 0, 0, 0, 121, 122, 1, 0, 0,
		0, 122, 123, 5, 120, 0, 0, 123, 124, 5, 12, 0, 0, 124, 129, 5, 120, 0,
		0, 125, 129, 7, 1, 0, 0, 126, 129, 5, 55, 0, 0, 127, 129, 5, 121, 0, 0,
		128, 114, 1, 0, 0, 0, 128, 116, 1, 0, 0, 0, 128, 120, 1, 0, 0, 0, 128,
		125, 1, 0, 0, 0, 128, 126, 1, 0, 0, 0, 128, 127, 1, 0, 0, 0, 129, 3, 1,
		0, 0, 0, 130, 135, 5, 129, 0, 0, 131, 132, 5, 9, 0, 0, 132, 134, 5, 129,
		0, 0, 133, 131, 1, 0, 0, 0, 134, 137, 1, 0, 0, 0, 135, 133, 1, 0, 0, 0,
		135, 136, 1, 0, 0, 0, 136, 5, 1, 0, 0, 0, 137, 135, 1, 0, 0, 0, 138, 144,
		5, 129, 0, 0, 139, 140, 5, 7, 0, 0, 140, 141, 5, 120, 0, 0, 141, 142, 5,
		9, 0, 0, 142, 143, 5, 120, 0, 0, 143, 145, 5, 8, 0, 0, 144, 139, 1, 0,
		0, 0, 144, 145, 1, 0, 0, 0, 145, 148, 1, 0, 0, 0, 146, 147, 5, 3, 0, 0,
		147, 149, 5, 4, 0, 0, 148, 146, 1, 0, 0, 0, 148, 149, 1, 0, 0, 0, 149,
		7, 1, 0, 0, 0, 150, 151, 5, 28, 0, 0, 151, 152, 3, 6, 3, 0, 152, 9, 1,
		0, 0, 0, 153, 154, 7, 2, 0, 0, 154, 11, 1, 0, 0, 0, 155, 160, 3, 10, 5,
		0, 156, 157, 5, 9, 0, 0, 157, 159, 3, 10, 5, 0, 158, 156, 1, 0, 0, 0, 159,
		162, 1, 0, 0, 0, 160, 158, 1, 0, 0, 0, 160, 161, 1, 0, 0, 0, 161, 13, 1,
		0, 0, 0, 162, 160, 1, 0, 0, 0, 163, 171, 3, 18, 9, 0, 164, 170, 3, 20,
		10, 0, 165, 170, 3, 22, 11, 0, 166, 170, 3, 42, 21, 0, 167, 170, 3, 44,
		22, 0, 168, 170, 3, 46, 23, 0, 169, 164, 1, 0, 0, 0, 169, 165, 1, 0, 0,
		0, 169, 166, 1, 0, 0, 0, 169, 167, 1, 0, 0, 0, 169, 168, 1, 0, 0, 0, 170,
		173, 1, 0, 0, 0, 171, 169, 1, 0, 0, 0, 171, 172, 1, 0, 0, 0, 172, 15, 1,
		0, 0, 0, 173, 171, 1, 0, 0, 0, 174, 175, 5, 131, 0, 0, 175, 188, 5, 7,
		0, 0, 176, 177, 5, 129, 0, 0, 177, 178, 5, 15, 0, 0, 178, 185, 3, 2, 1,
		0, 179, 180, 5, 9, 0, 0, 180, 181, 5, 129, 0, 0, 181, 182, 5, 15, 0, 0,
		182, 184, 3, 2, 1, 0, 183, 179, 1, 0, 0, 0, 184, 187, 1, 0, 0, 0, 185,
		183, 1, 0, 0, 0, 185, 186, 1, 0, 0, 0, 186, 189, 1, 0, 0, 0, 187, 185,
		1, 0, 0, 0, 188, 176, 1, 0, 0, 0, 188, 189, 1, 0, 0, 0, 189, 190, 1, 0,
		0, 0, 190, 191, 5, 8, 0, 0, 191, 17, 1, 0, 0, 0, 192, 193, 5, 32, 0, 0,
		193, 194, 5, 129, 0, 0, 194, 195, 5, 6, 0, 0, 195, 19, 1, 0, 0, 0, 196,
		197, 5, 33, 0, 0, 197, 213, 5, 129, 0, 0, 198, 199, 5, 1, 0, 0, 199, 200,
		5, 129, 0, 0, 200, 201, 5, 5, 0, 0, 201, 208, 3, 2, 1, 0, 202, 203, 5,
		9, 0, 0, 203, 204, 5, 129, 0, 0, 204, 205, 5, 5, 0, 0, 205, 207, 3, 2,
		1, 0, 206, 202, 1, 0, 0, 0, 207, 210, 1, 0, 0, 0, 208, 206, 1, 0, 0, 0,
		208, 209, 1, 0, 0, 0, 209, 211, 1, 0, 0, 0, 210, 208, 1, 0, 0, 0, 211,
		212, 5, 2, 0, 0, 212, 214, 1, 0, 0, 0, 213, 198, 1, 0, 0, 0, 213, 214,
		1, 0, 0, 0, 214, 215, 1, 0, 0, 0, 215, 216, 5, 75, 0, 0, 216, 217, 5, 129,
		0, 0, 217, 218, 5, 6, 0, 0, 218, 21, 1, 0, 0, 0, 219, 220, 5, 34, 0, 0,
		220, 221, 5, 129, 0, 0, 221, 222, 5, 1, 0, 0, 222, 231, 3, 24, 12, 0, 223,
		227, 5, 9, 0, 0, 224, 228, 3, 24, 12, 0, 225, 228, 3, 26, 13, 0, 226, 228,
		3, 28, 14, 0, 227, 224, 1, 0, 0, 0, 227, 225, 1, 0, 0, 0, 227, 226, 1,
		0, 0, 0, 228, 230, 1, 0, 0, 0, 229, 223, 1, 0, 0, 0, 230, 233, 1, 0, 0,
		0, 231, 229, 1, 0, 0, 0, 231, 232, 1, 0, 0, 0, 232, 234, 1, 0, 0, 0, 233,
		231, 1, 0, 0, 0, 234, 235, 5, 2, 0, 0, 235, 23, 1, 0, 0, 0, 236, 237, 5,
		129, 0, 0, 237, 241, 3, 6, 3, 0, 238, 240, 3, 38, 19, 0, 239, 238, 1, 0,
		0, 0, 240, 243, 1, 0, 0, 0, 241, 239, 1, 0, 0, 0, 241, 242, 1, 0, 0, 0,
		242, 25, 1, 0, 0, 0, 243, 241, 1, 0, 0, 0, 244, 245, 5, 132, 0, 0, 245,
		246, 7, 3, 0, 0, 246, 247, 5, 7, 0, 0, 247, 248, 3, 4, 2, 0, 248, 249,
		5, 8, 0, 0, 249, 27, 1, 0, 0, 0, 250, 251, 5, 46, 0, 0, 251, 254, 5, 48,
		0, 0, 252, 254, 5, 123, 0, 0, 253, 250, 1, 0, 0, 0, 253, 252, 1, 0, 0,
		0, 254, 255, 1, 0, 0, 0, 255, 256, 5, 7, 0, 0, 256, 257, 3, 4, 2, 0, 257,
		258, 5, 8, 0, 0, 258, 259, 7, 4, 0, 0, 259, 260, 5, 129, 0, 0, 260, 261,
		5, 7, 0, 0, 261, 262, 3, 4, 2, 0, 262, 266, 5, 8, 0, 0, 263, 265, 3, 30,
		15, 0, 264, 263, 1, 0, 0, 0, 265, 268, 1, 0, 0, 0, 266, 264, 1, 0, 0, 0,
		266, 267, 1, 0, 0, 0, 267, 29, 1, 0, 0, 0, 268, 266, 1, 0, 0, 0, 269, 270,
		5, 49, 0, 0, 270, 273, 5, 57, 0, 0, 271, 273, 5, 124, 0, 0, 272, 269, 1,
		0, 0, 0, 272, 271, 1, 0, 0, 0, 273, 280, 1, 0, 0, 0, 274, 275, 5, 49, 0,
		0, 275, 278, 5, 56, 0, 0, 276, 278, 5, 125, 0, 0, 277, 274, 1, 0, 0, 0,
		277, 276, 1, 0, 0, 0, 278, 280, 1, 0, 0, 0, 279, 272, 1, 0, 0, 0, 279,
		277, 1, 0, 0, 0, 280, 282, 1, 0, 0, 0, 281, 283, 5, 50, 0, 0, 282, 281,
		1, 0, 0, 0, 282, 283, 1, 0, 0, 0, 283, 301, 1, 0, 0, 0, 284, 285, 5, 85,
		0, 0, 285, 288, 5, 35, 0, 0, 286, 288, 5, 128, 0, 0, 287, 284, 1, 0, 0,
		0, 287, 286, 1, 0, 0, 0, 288, 302, 1, 0, 0, 0, 289, 302, 5, 51, 0, 0, 290,
		291, 5, 53, 0, 0, 291, 294, 5, 55, 0, 0, 292, 294, 5, 127, 0, 0, 293, 290,
		1, 0, 0, 0, 293, 292, 1, 0, 0, 0, 294, 302, 1, 0, 0, 0, 295, 296, 5, 53,
		0, 0, 296, 299, 5, 54, 0, 0, 297, 299, 5, 126, 0, 0, 298, 295, 1, 0, 0,
		0, 298, 297, 1, 0, 0, 0, 299, 302, 1, 0, 0, 0, 300, 302, 5, 52, 0, 0, 301,
		287, 1, 0, 0, 0, 301, 289, 1, 0, 0, 0, 301, 293, 1, 0, 0, 0, 301, 298,
		1, 0, 0, 0, 301, 300, 1, 0, 0, 0, 302, 31, 1, 0, 0, 0, 303, 308, 3, 6,
		3, 0, 304, 305, 5, 9, 0, 0, 305, 307, 3, 6, 3, 0, 306, 304, 1, 0, 0, 0,
		307, 310, 1, 0, 0, 0, 308, 306, 1, 0, 0, 0, 308, 309, 1, 0, 0, 0, 309,
		33, 1, 0, 0, 0, 310, 308, 1, 0, 0, 0, 311, 312, 5, 129, 0, 0, 312, 318,
		3, 6, 3, 0, 313, 314, 5, 9, 0, 0, 314, 315, 5, 129, 0, 0, 315, 317, 3,
		6, 3, 0, 316, 313, 1, 0, 0, 0, 317, 320, 1, 0, 0, 0, 318, 316, 1, 0, 0,
		0, 318, 319, 1, 0, 0, 0, 319, 35, 1, 0, 0, 0, 320, 318, 1, 0, 0, 0, 321,
		322, 3, 10, 5, 0, 322, 329, 3, 6, 3, 0, 323, 324, 5, 9, 0, 0, 324, 325,
		3, 10, 5, 0, 325, 326, 3, 6, 3, 0, 326, 328, 1, 0, 0, 0, 327, 323, 1, 0,
		0, 0, 328, 331, 1, 0, 0, 0, 329, 327, 1, 0, 0, 0, 329, 330, 1, 0, 0, 0,
		330, 37, 1, 0, 0, 0, 331, 329, 1, 0, 0, 0, 332, 333, 5, 41, 0, 0, 333,
		334, 5, 7, 0, 0, 334, 335, 3, 2, 1, 0, 335, 336, 5, 8, 0, 0, 336, 371,
		1, 0, 0, 0, 337, 338, 5, 42, 0, 0, 338, 339, 5, 7, 0, 0, 339, 340, 3, 2,
		1, 0, 340, 341, 5, 8, 0, 0, 341, 371, 1, 0, 0, 0, 342, 343, 5, 43, 0, 0,
		343, 344, 5, 7, 0, 0, 344, 345, 3, 2, 1, 0, 345, 346, 5, 8, 0, 0, 346,
		371, 1, 0, 0, 0, 347, 348, 5, 44, 0, 0, 348, 349, 5, 7, 0, 0, 349, 350,
		3, 2, 1, 0, 350, 351, 5, 8, 0, 0, 351, 371, 1, 0, 0, 0, 352, 356, 5, 86,
		0, 0, 353, 354, 5, 60, 0, 0, 354, 356, 5, 55, 0, 0, 355, 352, 1, 0, 0,
		0, 355, 353, 1, 0, 0, 0, 356, 371, 1, 0, 0, 0, 357, 363, 5, 122, 0, 0,
		358, 360, 5, 47, 0, 0, 359, 361, 5, 48, 0, 0, 360, 359, 1, 0, 0, 0, 360,
		361, 1, 0, 0, 0, 361, 363, 1, 0, 0, 0, 362, 357, 1, 0, 0, 0, 362, 358,
		1, 0, 0, 0, 363, 371, 1, 0, 0, 0, 364, 365, 5, 54, 0, 0, 365, 366, 5, 7,
		0, 0, 366, 367, 3, 2, 1, 0, 367, 368, 5, 8, 0, 0, 368, 371, 1, 0, 0, 0,
		369, 371, 5, 45, 0, 0, 370, 332, 1, 0, 0, 0, 370, 337, 1, 0, 0, 0, 370,
		342, 1, 0, 0, 0, 370, 347, 1, 0, 0, 0, 370, 355, 1, 0, 0, 0, 370, 362,
		1, 0, 0, 0, 370, 364, 1, 0, 0, 0, 370, 369, 1, 0, 0, 0, 371, 39, 1, 0,
		0, 0, 372, 373, 7, 5, 0, 0, 373, 41, 1, 0, 0, 0, 374, 376, 3, 16, 8, 0,
		375, 374, 1, 0, 0, 0, 376, 379, 1, 0, 0, 0, 377, 375, 1, 0, 0, 0, 377,
		378, 1, 0, 0, 0, 378, 380, 1, 0, 0, 0, 379, 377, 1, 0, 0, 0, 380, 381,
		5, 35, 0, 0, 381, 382, 5, 129, 0, 0, 382, 384, 5, 7, 0, 0, 383, 385, 3,
		12, 6, 0, 384, 383, 1, 0, 0, 0, 384, 385, 1, 0, 0, 0, 385, 386, 1, 0, 0,
		0, 386, 388, 5, 8, 0, 0, 387, 389, 3, 40, 20, 0, 388, 387, 1, 0, 0, 0,
		389, 390, 1, 0, 0, 0, 390, 388, 1, 0, 0, 0, 390, 391, 1, 0, 0, 0, 391,
		392, 1, 0, 0, 0, 392, 393, 5, 1, 0, 0, 393, 394, 3, 86, 43, 0, 394, 395,
		5, 2, 0, 0, 395, 43, 1, 0, 0, 0, 396, 398, 3, 16, 8, 0, 397, 396, 1, 0,
		0, 0, 398, 401, 1, 0, 0, 0, 399, 397, 1, 0, 0, 0, 399, 400, 1, 0, 0, 0,
		400, 402, 1, 0, 0, 0, 401, 399, 1, 0, 0, 0, 402, 403, 5, 36, 0, 0, 403,
		404, 5, 129, 0, 0, 404, 406, 5, 7, 0, 0, 405, 407, 3, 36, 18, 0, 406, 405,
		1, 0, 0, 0, 406, 407, 1, 0, 0, 0, 407, 408, 1, 0, 0, 0, 408, 410, 5, 8,
		0, 0, 409, 411, 3, 40, 20, 0, 410, 409, 1, 0, 0, 0, 411, 412, 1, 0, 0,
		0, 412, 410, 1, 0, 0, 0, 412, 413, 1, 0, 0, 0, 413, 415, 1, 0, 0, 0, 414,
		416, 3, 48, 24, 0, 415, 414, 1, 0, 0, 0, 415, 416, 1, 0, 0, 0, 416, 417,
		1, 0, 0, 0, 417, 418, 5, 1, 0, 0, 418, 419, 3, 90, 45, 0, 419, 420, 5,
		2, 0, 0, 420, 45, 1, 0, 0, 0, 421, 422, 5, 46, 0, 0, 422, 423, 5, 36, 0,
		0, 423, 424, 5, 129, 0, 0, 424, 427, 5, 7, 0, 0, 425, 428, 3, 32, 16, 0,
		426, 428, 3, 36, 18, 0, 427, 425, 1, 0, 0, 0, 427, 426, 1, 0, 0, 0, 427,
		428, 1, 0, 0, 0, 428, 429, 1, 0, 0, 0, 429, 431, 5, 8, 0, 0, 430, 432,
		3, 48, 24, 0, 431, 430, 1, 0, 0, 0, 431, 432, 1, 0, 0, 0, 432, 47, 1, 0,
		0, 0, 433, 445, 5, 84, 0, 0, 434, 436, 5, 34, 0, 0, 435, 434, 1, 0, 0,
		0, 435, 436, 1, 0, 0, 0, 436, 437, 1, 0, 0, 0, 437, 438, 5, 7, 0, 0, 438,
		439, 3, 34, 17, 0, 439, 440, 5, 8, 0, 0, 440, 446, 1, 0, 0, 0, 441, 442,
		5, 7, 0, 0, 442, 443, 3, 32, 16, 0, 443, 444, 5, 8, 0, 0, 444, 446, 1,
		0, 0, 0, 445, 435, 1, 0, 0, 0, 445, 441, 1, 0, 0, 0, 446, 49, 1, 0, 0,
		0, 447, 448, 3, 52, 26, 0, 448, 449, 5, 6, 0, 0, 449, 51, 1, 0, 0, 0, 450,
		451, 5, 87, 0, 0, 451, 456, 3, 54, 27, 0, 452, 453, 5, 9, 0, 0, 453, 455,
		3, 54, 27, 0, 454, 452, 1, 0, 0, 0, 455, 458, 1, 0, 0, 0, 456, 454, 1,
		0, 0, 0, 456, 457, 1, 0, 0, 0, 457, 460, 1, 0, 0, 0, 458, 456, 1, 0, 0,
		0, 459, 450, 1, 0, 0, 0, 459, 460, 1, 0, 0, 0, 460, 465, 1, 0, 0, 0, 461,
		466, 3, 56, 28, 0, 462, 466, 3, 70, 35, 0, 463, 466, 3, 74, 37, 0, 464,
		466, 3, 78, 39, 0, 465, 461, 1, 0, 0, 0, 465, 462, 1, 0, 0, 0, 465, 463,
		1, 0, 0, 0, 465, 464, 1, 0, 0, 0, 466, 53, 1, 0, 0, 0, 467, 468, 5, 129,
		0, 0, 468, 477, 5, 7, 0, 0, 469, 474, 5, 129, 0, 0, 470, 471, 5, 9, 0,
		0, 471, 473, 5, 129, 0, 0, 472, 470, 1, 0, 0, 0, 473, 476, 1, 0, 0, 0,
		474, 472, 1, 0, 0, 0, 474, 475, 1, 0, 0, 0, 475, 478, 1, 0, 0, 0, 476,
		474, 1, 0, 0, 0, 477, 469, 1, 0, 0, 0, 477, 478, 1, 0, 0, 0, 478, 479,
		1, 0, 0, 0, 479, 480, 5, 8, 0, 0, 480, 481, 5, 75, 0, 0, 481, 482, 5, 7,
		0, 0, 482, 483, 3, 56, 28, 0, 483, 484, 5, 8, 0, 0, 484, 55, 1, 0, 0, 0,
		485, 491, 3, 62, 31, 0, 486, 487, 3, 58, 29, 0, 487, 488, 3, 62, 31, 0,
		488, 490, 1, 0, 0, 0, 489, 486, 1, 0, 0, 0, 490, 493, 1, 0, 0, 0, 491,
		489, 1, 0, 0, 0, 491, 492, 1, 0, 0, 0, 492, 504, 1, 0, 0, 0, 493, 491,
		1, 0, 0, 0, 494, 495, 5, 80, 0, 0, 495, 496, 5, 81, 0, 0, 496, 501, 3,
		60, 30, 0, 497, 498, 5, 9, 0, 0, 498, 500, 3, 60, 30, 0, 499, 497, 1, 0,
		0, 0, 500, 503, 1, 0, 0, 0, 501, 499, 1, 0, 0, 0, 501, 502, 1, 0, 0, 0,
		502, 505, 1, 0, 0, 0, 503, 501, 1, 0, 0, 0, 504, 494, 1, 0, 0, 0, 504,
		505, 1, 0, 0, 0, 505, 508, 1, 0, 0, 0, 506, 507, 5, 78, 0, 0, 507, 509,
		3, 80, 40, 0, 508, 506, 1, 0, 0, 0, 508, 509, 1, 0, 0, 0, 509, 512, 1,
		0, 0, 0, 510, 511, 5, 79, 0, 0, 511, 513, 3, 80, 40, 0, 512, 510, 1, 0,
		0, 0, 512, 513, 1, 0, 0, 0, 513, 57, 1, 0, 0, 0, 514, 516, 5, 100, 0, 0,
		515, 517, 5, 69, 0, 0, 516, 515, 1, 0, 0, 0, 516, 517, 1, 0, 0, 0, 517,
		521, 1, 0, 0, 0, 518, 521, 5, 101, 0, 0, 519, 521, 5, 102, 0, 0, 520, 514,
		1, 0, 0, 0, 520, 518, 1, 0, 0, 0, 520, 519, 1, 0, 0, 0, 521, 59, 1, 0,
		0, 0, 522, 524, 3, 80, 40, 0, 523, 525, 7, 6, 0, 0, 524, 523, 1, 0, 0,
		0, 524, 525, 1, 0, 0, 0, 525, 528, 1, 0, 0, 0, 526, 527, 5, 103, 0, 0,
		527, 529, 7, 7, 0, 0, 528, 526, 1, 0, 0, 0, 528, 529, 1, 0, 0, 0, 529,
		61, 1, 0, 0, 0, 530, 532, 5, 96, 0, 0, 531, 533, 5, 92, 0, 0, 532, 531,
		1, 0, 0, 0, 532, 533, 1, 0, 0, 0, 533, 534, 1, 0, 0, 0, 534, 539, 3, 68,
		34, 0, 535, 536, 5, 9, 0, 0, 536, 538, 3, 68, 34, 0, 537, 535, 1, 0, 0,
		0, 538, 541, 1, 0, 0, 0, 539, 537, 1, 0, 0, 0, 539, 540, 1, 0, 0, 0, 540,
		550, 1, 0, 0, 0, 541, 539, 1, 0, 0, 0, 542, 543, 5, 93, 0, 0, 543, 547,
		3, 64, 32, 0, 544, 546, 3, 66, 33, 0, 545, 544, 1, 0, 0, 0, 546, 549, 1,
		0, 0, 0, 547, 545, 1, 0, 0, 0, 547, 548, 1, 0, 0, 0, 548, 551, 1, 0, 0,
		0, 549, 547, 1, 0, 0, 0, 550, 542, 1, 0, 0, 0, 550, 551, 1, 0, 0, 0, 551,
		554, 1, 0, 0, 0, 552, 553, 5, 94, 0, 0, 553, 555, 3, 80, 40, 0, 554, 552,
		1, 0, 0, 0, 554, 555, 1, 0, 0, 0, 555, 563, 1, 0, 0, 0, 556, 557, 5, 82,
		0, 0, 557, 558, 5, 81, 0, 0, 558, 561, 3, 82, 41, 0, 559, 560, 5, 83, 0,
		0, 560, 562, 3, 80, 40, 0, 561, 559, 1, 0, 0, 0, 561, 562, 1, 0, 0, 0,
		562, 564, 1, 0, 0, 0, 563, 556, 1, 0, 0, 0, 563, 564, 1, 0, 0, 0, 564,
		63, 1, 0, 0, 0, 565, 570, 5, 129, 0, 0, 566, 568, 5, 75, 0, 0, 567, 566,
		1, 0, 0, 0, 567, 568, 1, 0, 0, 0, 568, 569, 1, 0, 0, 0, 569, 571, 5, 129,
		0, 0, 570, 567, 1, 0, 0, 0, 570, 571, 1, 0, 0, 0, 571, 587, 1, 0, 0, 0,
		572, 573, 5, 7, 0, 0, 573, 574, 3, 56, 28, 0, 574, 576, 5, 8, 0, 0, 575,
		577, 5, 75, 0, 0, 576, 575, 1, 0, 0, 0, 576, 577, 1, 0, 0, 0, 577, 578,
		1, 0, 0, 0, 578, 579, 5, 129, 0, 0, 579, 587, 1, 0, 0, 0, 580, 582, 3,
		84, 42, 0, 581, 583, 5, 75, 0, 0, 582, 581, 1, 0, 0, 0, 582, 583, 1, 0,
		0, 0, 583, 584, 1, 0, 0, 0, 584, 585, 5, 129, 0, 0, 585, 587, 1, 0, 0,
		0, 586, 565, 1, 0, 0, 0, 586, 572, 1, 0, 0, 0, 586, 580, 1, 0, 0, 0, 587,
		65, 1, 0, 0, 0, 588, 589, 7, 8, 0, 0, 589, 590, 5, 71, 0, 0, 590, 591,
		3, 64, 32, 0, 591, 592, 5, 49, 0, 0, 592, 593, 3, 80, 40, 0, 593, 67, 1,
		0, 0, 0, 594, 599, 3, 80, 40, 0, 595, 597, 5, 75, 0, 0, 596, 595, 1, 0,
		0, 0, 596, 597, 1, 0, 0, 0, 597, 598, 1, 0, 0, 0, 598, 600, 5, 129, 0,
		0, 599, 596, 1, 0, 0, 0, 599, 600, 1, 0, 0, 0, 600, 607, 1, 0, 0, 0, 601,
		602, 5, 129, 0, 0, 602, 604, 5, 12, 0, 0, 603, 601, 1, 0, 0, 0, 603, 604,
		1, 0, 0, 0, 604, 605, 1, 0, 0, 0, 605, 607, 5, 14, 0, 0, 606, 594, 1, 0,
		0, 0, 606, 603, 1, 0, 0, 0, 607, 69, 1, 0, 0, 0, 608, 609, 5, 57, 0, 0,
		609, 612, 5, 129, 0, 0, 610, 611, 5, 75, 0, 0, 611, 613, 5, 129, 0, 0,
		612, 610, 1, 0, 0, 0, 612, 613, 1, 0, 0, 0, 613, 614, 1, 0, 0, 0, 614,
		615, 5, 53, 0, 0, 615, 620, 3, 72, 36, 0, 616, 617, 5, 9, 0, 0, 617, 619,
		3, 72, 36, 0, 618, 616, 1, 0, 0, 0, 619, 622, 1, 0, 0, 0, 620, 618, 1,
		0, 0, 0, 620, 621, 1, 0, 0, 0, 621, 631, 1, 0, 0, 0, 622, 620, 1, 0, 0,
		0, 623, 624, 5, 93, 0, 0, 624, 628, 3, 64, 32, 0, 625, 627, 3, 66, 33,
		0, 626, 625, 1, 0, 0, 0, 627, 630, 1, 0, 0, 0, 628, 626, 1, 0, 0, 0, 628,
		629, 1, 0, 0, 0, 629, 632, 1, 0, 0, 0, 630, 628, 1, 0, 0, 0, 631, 623,
		1, 0, 0, 0, 631, 632, 1, 0, 0, 0, 632, 635, 1, 0, 0, 0, 633, 634, 5, 94,
		0, 0, 634, 636, 3, 80, 40, 0, 635, 633, 1, 0, 0, 0, 635, 636, 1, 0, 0,
		0, 636, 71, 1, 0, 0, 0, 637, 638, 5, 129, 0, 0, 638, 639, 5, 15, 0, 0,
		639, 640, 3, 80, 40, 0, 640, 73, 1, 0, 0, 0, 641, 642, 5, 97, 0, 0, 642,
		643, 5, 107, 0, 0, 643, 646, 5, 129, 0, 0, 644, 645, 5, 75, 0, 0, 645,
		647, 5, 129, 0, 0, 646, 644, 1, 0, 0, 0, 646, 647, 1, 0, 0, 0, 647, 652,
		1, 0, 0, 0, 648, 649, 5, 7, 0, 0, 649, 650, 3, 4, 2, 0, 650, 651, 5, 8,
		0, 0, 651, 653, 1, 0, 0, 0, 652, 648, 1, 0, 0, 0, 652, 653, 1, 0, 0, 0,
		653, 654, 1, 0, 0, 0, 654, 655, 5, 98, 0, 0, 655, 656, 5, 7, 0, 0, 656,
		657, 3, 82, 41, 0, 657, 665, 5, 8, 0, 0, 658, 659, 5, 9, 0, 0, 659, 660,
		5, 7, 0, 0, 660, 661, 3, 82, 41, 0, 661, 662, 5, 8, 0, 0, 662, 664, 1,
		0, 0, 0, 663, 658, 1, 0, 0, 0, 664, 667, 1, 0, 0, 0, 665, 663, 1, 0, 0,
		0, 665, 666, 1, 0, 0, 0, 666, 669, 1, 0, 0, 0, 667, 665, 1, 0, 0, 0, 668,
		670, 3, 76, 38, 0, 669, 668, 1, 0, 0, 0, 669, 670, 1, 0, 0, 0, 670, 75,
		1, 0, 0, 0, 671, 672, 5, 49, 0, 0, 672, 680, 5, 108, 0, 0, 673, 674, 5,
		7, 0, 0, 674, 675, 3, 4, 2, 0, 675, 678, 5, 8, 0, 0, 676, 677, 5, 94, 0,
		0, 677, 679, 3, 80, 40, 0, 678, 676, 1, 0, 0, 0, 678, 679, 1, 0, 0, 0,
		679, 681, 1, 0, 0, 0, 680, 673, 1, 0, 0, 0, 680, 681, 1, 0, 0, 0, 681,
		682, 1, 0, 0, 0, 682, 698, 5, 50, 0, 0, 683, 699, 5, 109, 0, 0, 684, 685,
		5, 57, 0, 0, 685, 686, 5, 53, 0, 0, 686, 691, 3, 72, 36, 0, 687, 688, 5,
		9, 0, 0, 688, 690, 3, 72, 36, 0, 689, 687, 1, 0, 0, 0, 690, 693, 1, 0,
		0, 0, 691, 689, 1, 0, 0, 0, 691, 692, 1, 0, 0, 0, 692, 696, 1, 0, 0, 0,
		693, 691, 1, 0, 0, 0, 694, 695, 5, 94, 0, 0, 695, 697, 3, 80, 40, 0, 696,
		694, 1, 0, 0, 0, 696, 697, 1, 0, 0, 0, 697, 699, 1, 0, 0, 0, 698, 683,
		1, 0, 0, 0, 698, 684, 1, 0, 0, 0, 699, 77, 1, 0, 0, 0, 700, 701, 5, 56,
		0, 0, 701, 702, 5, 93, 0, 0, 702, 705, 5, 129, 0, 0, 703, 704, 5, 75, 0,
		0, 704, 706, 5, 129, 0, 0, 705, 703, 1, 0, 0, 0, 705, 706, 1, 0, 0, 0,
		706, 709, 1, 0, 0, 0, 707, 708, 5, 94, 0, 0, 708, 710, 3, 80, 40, 0, 709,
		707, 1, 0, 0, 0, 709, 710, 1, 0, 0, 0, 710, 79, 1, 0, 0, 0, 711, 712, 6,
		40, -1, 0, 712, 714, 3, 2, 1, 0, 713, 715, 3, 8, 4, 0, 714, 713, 1, 0,
		0, 0, 714, 715, 1, 0, 0, 0, 715, 772, 1, 0, 0, 0, 716, 718, 3, 84, 42,
		0, 717, 719, 3, 8, 4, 0, 718, 717, 1, 0, 0, 0, 718, 719, 1, 0, 0, 0, 719,
		772, 1, 0, 0, 0, 720, 722, 3, 10, 5, 0, 721, 723, 3, 8, 4, 0, 722, 721,
		1, 0, 0, 0, 722, 723, 1, 0, 0, 0, 723, 772, 1, 0, 0, 0, 724, 725, 5, 129,
		0, 0, 725, 727, 5, 12, 0, 0, 726, 724, 1, 0, 0, 0, 726, 727, 1, 0, 0, 0,
		727, 728, 1, 0, 0, 0, 728, 730, 5, 129, 0, 0, 729, 731, 3, 8, 4, 0, 730,
		729, 1, 0, 0, 0, 730, 731, 1, 0, 0, 0, 731, 772, 1, 0, 0, 0, 732, 733,
		5, 7, 0, 0, 733, 734, 3, 80, 40, 0, 734, 736, 5, 8, 0, 0, 735, 737, 3,
		8, 4, 0, 736, 735, 1, 0, 0, 0, 736, 737, 1, 0, 0, 0, 737, 772, 1, 0, 0,
		0, 738, 739, 7, 9, 0, 0, 739, 772, 3, 80, 40, 11, 740, 742, 5, 88, 0, 0,
		741, 743, 3, 80, 40, 0, 742, 741, 1, 0, 0, 0, 742, 743, 1, 0, 0, 0, 743,
		749, 1, 0, 0, 0, 744, 745, 5, 89, 0, 0, 745, 746, 3, 80, 40, 0, 746, 747,
		5, 90, 0, 0, 747, 748, 3, 80, 40, 0, 748, 750, 1, 0, 0, 0, 749, 744, 1,
		0, 0, 0, 750, 751, 1, 0, 0, 0, 751, 749, 1, 0, 0, 0, 751, 752, 1, 0, 0,
		0, 752, 755, 1, 0, 0, 0, 753, 754, 5, 113, 0, 0, 754, 756, 3, 80, 40, 0,
		755, 753, 1, 0, 0, 0, 755, 756, 1, 0, 0, 0, 756, 757, 1, 0, 0, 0, 757,
		758, 5, 91, 0, 0, 758, 772, 1, 0, 0, 0, 759, 761, 5, 60, 0, 0, 760, 759,
		1, 0, 0, 0, 760, 761, 1, 0, 0, 0, 761, 762, 1, 0, 0, 0, 762, 764, 5, 68,
		0, 0, 763, 760, 1, 0, 0, 0, 763, 764, 1, 0, 0, 0, 764, 765, 1, 0, 0, 0,
		765, 766, 5, 7, 0, 0, 766, 767, 3, 56, 28, 0, 767, 769, 5, 8, 0, 0, 768,
		770, 3, 8, 4, 0, 769, 768, 1, 0, 0, 0, 769, 770, 1, 0, 0, 0, 770, 772,
		1, 0, 0, 0, 771, 711, 1, 0, 0, 0, 771, 716, 1, 0, 0, 0, 771, 720, 1, 0,
		0, 0, 771, 726, 1, 0, 0, 0, 771, 732, 1, 0, 0, 0, 771, 738, 1, 0, 0, 0,
		771, 740, 1, 0, 0, 0, 771, 763, 1, 0, 0, 0, 772, 849, 1, 0, 0, 0, 773,
		774, 10, 14, 0, 0, 774, 775, 7, 10, 0, 0, 775, 848, 3, 80, 40, 15, 776,
		778, 10, 12, 0, 0, 777, 779, 5, 60, 0, 0, 778, 777, 1, 0, 0, 0, 778, 779,
		1, 0, 0, 0, 779, 780, 1, 0, 0, 0, 780, 781, 5, 64, 0, 0, 781, 848, 3, 80,
		40, 13, 782, 784, 10, 10, 0, 0, 783, 785, 5, 60, 0, 0, 784, 783, 1, 0,
		0, 0, 784, 785, 1, 0, 0, 0, 785, 786, 1, 0, 0, 0, 786, 787, 5, 66, 0, 0,
		787, 788, 3, 80, 40, 0, 788, 789, 5, 62, 0, 0, 789, 790, 3, 80, 40, 11,
		790, 848, 1, 0, 0, 0, 791, 792, 10, 5, 0, 0, 792, 793, 5, 13, 0, 0, 793,
		848, 3, 80, 40, 6, 794, 795, 10, 4, 0, 0, 795, 796, 7, 11, 0, 0, 796, 848,
		3, 80, 40, 5, 797, 798, 10, 3, 0, 0, 798, 799, 7, 0, 0, 0, 799, 848, 3,
		80, 40, 4, 800, 801, 10, 2, 0, 0, 801, 802, 5, 62, 0, 0, 802, 848, 3, 80,
		40, 3, 803, 804, 10, 1, 0, 0, 804, 805, 5, 63, 0, 0, 805, 848, 3, 80, 40,
		2, 806, 807, 10, 17, 0, 0, 807, 808, 5, 3, 0, 0, 808, 809, 3, 80, 40, 0,
		809, 811, 5, 4, 0, 0, 810, 812, 3, 8, 4, 0, 811, 810, 1, 0, 0, 0, 811,
		812, 1, 0, 0, 0, 812, 848, 1, 0, 0, 0, 813, 814, 10, 16, 0, 0, 814, 815,
		5, 12, 0, 0, 815, 817, 5, 129, 0, 0, 816, 818, 3, 8, 4, 0, 817, 816, 1,
		0, 0, 0, 817, 818, 1, 0, 0, 0, 818, 848, 1, 0, 0, 0, 819, 821, 10, 13,
		0, 0, 820, 822, 5, 60, 0, 0, 821, 820, 1, 0, 0, 0, 821, 822, 1, 0, 0, 0,
		822, 823, 1, 0, 0, 0, 823, 824, 5, 65, 0, 0, 824, 827, 5, 7, 0, 0, 825,
		828, 3, 82, 41, 0, 826, 828, 3, 56, 28, 0, 827, 825, 1, 0, 0, 0, 827, 826,
		1, 0, 0, 0, 828, 829, 1, 0, 0, 0, 829, 830, 5, 8, 0, 0, 830, 848, 1, 0,
		0, 0, 831, 832, 10, 9, 0, 0, 832, 834, 5, 67, 0, 0, 833, 835, 5, 60, 0,
		0, 834, 833, 1, 0, 0, 0, 834, 835, 1, 0, 0, 0, 835, 842, 1, 0, 0, 0, 836,
		837, 5, 92, 0, 0, 837, 838, 5, 93, 0, 0, 838, 843, 3, 80, 40, 0, 839, 843,
		5, 55, 0, 0, 840, 843, 5, 118, 0, 0, 841, 843, 5, 119, 0, 0, 842, 836,
		1, 0, 0, 0, 842, 839, 1, 0, 0, 0, 842, 840, 1, 0, 0, 0, 842, 841, 1, 0,
		0, 0, 843, 848, 1, 0, 0, 0, 844, 845, 10, 8, 0, 0, 845, 846, 5, 95, 0,
		0, 846, 848, 5, 129, 0, 0, 847, 773, 1, 0, 0, 0, 847, 776, 1, 0, 0, 0,
		847, 782, 1, 0, 0, 0, 847, 791, 1, 0, 0, 0, 847, 794, 1, 0, 0, 0, 847,
		797, 1, 0, 0, 0, 847, 800, 1, 0, 0, 0, 847, 803, 1, 0, 0, 0, 847, 806,
		1, 0, 0, 0, 847, 813, 1, 0, 0, 0, 847, 819, 1, 0, 0, 0, 847, 831, 1, 0,
		0, 0, 847, 844, 1, 0, 0, 0, 848, 851, 1, 0, 0, 0, 849, 847, 1, 0, 0, 0,
		849, 850, 1, 0, 0, 0, 850, 81, 1, 0, 0, 0, 851, 849, 1, 0, 0, 0, 852, 857,
		3, 80, 40, 0, 853, 854, 5, 9, 0, 0, 854, 856, 3, 80, 40, 0, 855, 853, 1,
		0, 0, 0, 856, 859, 1, 0, 0, 0, 857, 855, 1, 0, 0, 0, 857, 858, 1, 0, 0,
		0, 858, 83, 1, 0, 0, 0, 859, 857, 1, 0, 0, 0, 860, 861, 5, 129, 0, 0, 861,
		867, 5, 7, 0, 0, 862, 864, 5, 92, 0, 0, 863, 862, 1, 0, 0, 0, 863, 864,
		1, 0, 0, 0, 864, 865, 1, 0, 0, 0, 865, 868, 3, 82, 41, 0, 866, 868, 5,
		14, 0, 0, 867, 863, 1, 0, 0, 0, 867, 866, 1, 0, 0, 0, 867, 868, 1, 0, 0,
		0, 868, 869, 1, 0, 0, 0, 869, 883, 5, 8, 0, 0, 870, 871, 5, 129, 0, 0,
		871, 872, 5, 3, 0, 0, 872, 873, 3, 80, 40, 0, 873, 874, 5, 9, 0, 0, 874,
		875, 3, 80, 40, 0, 875, 876, 5, 4, 0, 0, 876, 878, 5, 7, 0, 0, 877, 879,
		3, 82, 41, 0, 878, 877, 1, 0, 0, 0, 878, 879, 1, 0, 0, 0, 879, 880, 1,
		0, 0, 0, 880, 881, 5, 8, 0, 0, 881, 883, 1, 0, 0, 0, 882, 860, 1, 0, 0,
		0, 882, 870, 1, 0, 0, 0, 883, 85, 1, 0, 0, 0, 884, 885, 3, 88, 44, 0, 885,
		886, 5, 6, 0, 0, 886, 888, 1, 0, 0, 0, 887, 884, 1, 0, 0, 0, 888, 891,
		1, 0, 0, 0, 889, 887, 1, 0, 0, 0, 889, 890, 1, 0, 0, 0, 890, 87, 1, 0,
		0, 0, 891, 889, 1, 0, 0, 0, 892, 913, 3, 52, 26, 0, 893, 894, 5, 129, 0,
		0, 894, 896, 5, 7, 0, 0, 895, 897, 3, 94, 47, 0, 896, 895, 1, 0, 0, 0,
		896, 897, 1, 0, 0, 0, 897, 898, 1, 0, 0, 0, 898, 913, 5, 8, 0, 0, 899,
		900, 3, 12, 6, 0, 900, 901, 5, 15, 0, 0, 901, 903, 1, 0, 0, 0, 902, 899,
		1, 0, 0, 0, 902, 903, 1, 0, 0, 0, 903, 904, 1, 0, 0, 0, 904, 905, 5, 129,
		0, 0, 905, 906, 5, 12, 0, 0, 906, 907, 5, 129, 0, 0, 907, 909, 5, 7, 0,
		0, 908, 910, 3, 94, 47, 0, 909, 908, 1, 0, 0, 0, 909, 910, 1, 0, 0, 0,
		910, 911, 1, 0, 0, 0, 911, 913, 5, 8, 0, 0, 912, 892, 1, 0, 0, 0, 912,
		893, 1, 0, 0, 0, 912, 902, 1, 0, 0, 0, 913, 89, 1, 0, 0, 0, 914, 916, 3,
		96, 48, 0, 915, 914, 1, 0, 0, 0, 916, 919, 1, 0, 0, 0, 917, 915, 1, 0,
		0, 0, 917, 918, 1, 0, 0, 0, 918, 91, 1, 0, 0, 0, 919, 917, 1, 0, 0, 0,
		920, 921, 6, 46, -1, 0, 921, 923, 3, 2, 1, 0, 922, 924, 3, 8, 4, 0, 923,
		922, 1, 0, 0, 0, 923, 924, 1, 0, 0, 0, 924, 950, 1, 0, 0, 0, 925, 927,
		3, 100, 50, 0, 926, 928, 3, 8, 4, 0, 927, 926, 1, 0, 0, 0, 927, 928, 1,
		0, 0, 0, 928, 950, 1, 0, 0, 0, 929, 931, 3, 10, 5, 0, 930, 932, 3, 8, 4,
		0, 931, 930, 1, 0, 0, 0, 931, 932, 1, 0, 0, 0, 932, 950, 1, 0, 0, 0, 933,
		935, 5, 3, 0, 0, 934, 936, 3, 94, 47, 0, 935, 934, 1, 0, 0, 0, 935, 936,
		1, 0, 0, 0, 936, 937, 1, 0, 0, 0, 937, 939, 5, 4, 0, 0, 938, 940, 3, 8,
		4, 0, 939, 938, 1, 0, 0, 0, 939, 940, 1, 0, 0, 0, 940, 950, 1, 0, 0, 0,
		941, 942, 5, 7, 0, 0, 942, 943, 3, 92, 46, 0, 943, 945, 5, 8, 0, 0, 944,
		946, 3, 8, 4, 0, 945, 944, 1, 0, 0, 0, 945, 946, 1, 0, 0, 0, 946, 950,
		1, 0, 0, 0, 947, 948, 7, 12, 0, 0, 948, 950, 3, 92, 46, 4, 949, 920, 1,
		0, 0, 0, 949, 925, 1, 0, 0, 0, 949, 929, 1, 0, 0, 0, 949, 933, 1, 0, 0,
		0, 949, 941, 1, 0, 0, 0, 949, 947, 1, 0, 0, 0, 950, 978, 1, 0, 0, 0, 951,
		952, 10, 5, 0, 0, 952, 953, 7, 10, 0, 0, 953, 977, 3, 92, 46, 6, 954, 955,
		10, 3, 0, 0, 955, 956, 5, 13, 0, 0, 956, 977, 3, 92, 46, 4, 957, 958, 10,
		2, 0, 0, 958, 959, 7, 11, 0, 0, 959, 977, 3, 92, 46, 3, 960, 961, 10, 1,
		0, 0, 961, 962, 7, 0, 0, 0, 962, 977, 3, 92, 46, 2, 963, 964, 10, 8, 0,
		0, 964, 965, 5, 3, 0, 0, 965, 966, 3, 92, 46, 0, 966, 968, 5, 4, 0, 0,
		967, 969, 3, 8, 4, 0, 968, 967, 1, 0, 0, 0, 968, 969, 1, 0, 0, 0, 969,
		977, 1, 0, 0, 0, 970, 971, 10, 6, 0, 0, 971, 972, 5, 12, 0, 0, 972, 974,
		5, 129, 0, 0, 973, 975, 3, 8, 4, 0, 974, 973, 1, 0, 0, 0, 974, 975, 1,
		0, 0, 0, 975, 977, 1, 0, 0, 0, 976, 951, 1, 0, 0, 0, 976, 954, 1, 0, 0,
		0, 976, 957, 1, 0, 0, 0, 976, 960, 1, 0, 0, 0, 976, 963, 1, 0, 0, 0, 976,
		970, 1, 0, 0, 0, 977, 980, 1, 0, 0, 0, 978, 976, 1, 0, 0, 0, 978, 979,
		1, 0, 0, 0, 979, 93, 1, 0, 0, 0, 980, 978, 1, 0, 0, 0, 981, 986, 3, 92,
		46, 0, 982, 983, 5, 9, 0, 0, 983, 985, 3, 92, 46, 0, 984, 982, 1, 0, 0,
		0, 985, 988, 1, 0, 0, 0, 986, 984, 1, 0, 0, 0, 986, 987, 1, 0, 0, 0, 987,
		95, 1, 0, 0, 0, 988, 986, 1, 0, 0, 0, 989, 990, 5, 130, 0, 0, 990, 991,
		3, 6, 3, 0, 991, 992, 5, 6, 0, 0, 992, 1076, 1, 0, 0, 0, 993, 998, 3, 98,
		49, 0, 994, 995, 5, 9, 0, 0, 995, 997, 3, 98, 49, 0, 996, 994, 1, 0, 0,
		0, 997, 1000, 1, 0, 0, 0, 998, 996, 1, 0, 0, 0, 998, 999, 1, 0, 0, 0, 999,
		1001, 1, 0, 0, 0, 1000, 998, 1, 0, 0, 0, 1001, 1002, 5, 30, 0, 0, 1002,
		1004, 1, 0, 0, 0, 1003, 993, 1, 0, 0, 0, 1003, 1004, 1, 0, 0, 0, 1004,
		1005, 1, 0, 0, 0, 1005, 1006, 3, 100, 50, 0, 1006, 1007, 5, 6, 0, 0, 1007,
		1076, 1, 0, 0, 0, 1008, 1009, 5, 130, 0, 0, 1009, 1010, 5, 30, 0, 0, 1010,
		1011, 3, 92, 46, 0, 1011, 1012, 5, 6, 0, 0, 1012, 1076, 1, 0, 0, 0, 1013,
		1015, 5, 130, 0, 0, 1014, 1016, 3, 6, 3, 0, 1015, 1014, 1, 0, 0, 0, 1015,
		1016, 1, 0, 0, 0, 1016, 1017, 1, 0, 0, 0, 1017, 1018, 5, 30, 0, 0, 1018,
		1019, 3, 92, 46, 0, 1019, 1020, 5, 6, 0, 0, 1020, 1076, 1, 0, 0, 0, 1021,
		1022, 5, 110, 0, 0, 1022, 1023, 5, 130, 0, 0, 1023, 1027, 5, 65, 0, 0,
		1024, 1028, 3, 104, 52, 0, 1025, 1028, 3, 10, 5, 0, 1026, 1028, 3, 52,
		26, 0, 1027, 1024, 1, 0, 0, 0, 1027, 1025, 1, 0, 0, 0, 1027, 1026, 1, 0,
		0, 0, 1028, 1029, 1, 0, 0, 0, 1029, 1033, 5, 1, 0, 0, 1030, 1032, 3, 96,
		48, 0, 1031, 1030, 1, 0, 0, 0, 1032, 1035, 1, 0, 0, 0, 1033, 1031, 1, 0,
		0, 0, 1033, 1034, 1, 0, 0, 0, 1034, 1036, 1, 0, 0, 0, 1035, 1033, 1, 0,
		0, 0, 1036, 1037, 5, 2, 0, 0, 1037, 1076, 1, 0, 0, 0, 1038, 1039, 5, 111,
		0, 0, 1039, 1044, 3, 102, 51, 0, 1040, 1041, 5, 112, 0, 0, 1041, 1043,
		3, 102, 51, 0, 1042, 1040, 1, 0, 0, 0, 1043, 1046, 1, 0, 0, 0, 1044, 1042,
		1, 0, 0, 0, 1044, 1045, 1, 0, 0, 0, 1045, 1056, 1, 0, 0, 0, 1046, 1044,
		1, 0, 0, 0, 1047, 1048, 5, 113, 0, 0, 1048, 1052, 5, 1, 0, 0, 1049, 1051,
		3, 96, 48, 0, 1050, 1049, 1, 0, 0, 0, 1051, 1054, 1, 0, 0, 0, 1052, 1050,
		1, 0, 0, 0, 1052, 1053, 1, 0, 0, 0, 1053, 1055, 1, 0, 0, 0, 1054, 1052,
		1, 0, 0, 0, 1055, 1057, 5, 2, 0, 0, 1056, 1047, 1, 0, 0, 0, 1056, 1057,
		1, 0, 0, 0, 1057, 1076, 1, 0, 0, 0, 1058, 1059, 3, 52, 26, 0, 1059, 1060,
		5, 6, 0, 0, 1060, 1076, 1, 0, 0, 0, 1061, 1062, 5, 114, 0, 0, 1062, 1076,
		5, 6, 0, 0, 1063, 1066, 5, 115, 0, 0, 1064, 1067, 3, 94, 47, 0, 1065, 1067,
		3, 52, 26, 0, 1066, 1064, 1, 0, 0, 0, 1066, 1065, 1, 0, 0, 0, 1067, 1068,
		1, 0, 0, 0, 1068, 1069, 5, 6, 0, 0, 1069, 1076, 1, 0, 0, 0, 1070, 1071,
		5, 115, 0, 0, 1071, 1072, 5, 116, 0, 0, 1072, 1073, 3, 94, 47, 0, 1073,
		1074, 5, 6, 0, 0, 1074, 1076, 1, 0, 0, 0, 1075, 989, 1, 0, 0, 0, 1075,
		1003, 1, 0, 0, 0, 1075, 1008, 1, 0, 0, 0, 1075, 1013, 1, 0, 0, 0, 1075,
		1021, 1, 0, 0, 0, 1075, 1038, 1, 0, 0, 0, 1075, 1058, 1, 0, 0, 0, 1075,
		1061, 1, 0, 0, 0, 1075, 1063, 1, 0, 0, 0, 1075, 1070, 1, 0, 0, 0, 1076,
		97, 1, 0, 0, 0, 1077, 1078, 7, 13, 0, 0, 1078, 99, 1, 0, 0, 0, 1079, 1080,
		5, 129, 0, 0, 1080, 1082, 5, 7, 0, 0, 1081, 1083, 3, 94, 47, 0, 1082, 1081,
		1, 0, 0, 0, 1082, 1083, 1, 0, 0, 0, 1083, 1084, 1, 0, 0, 0, 1084, 1098,
		5, 8, 0, 0, 1085, 1086, 5, 129, 0, 0, 1086, 1087, 5, 3, 0, 0, 1087, 1088,
		3, 92, 46, 0, 1088, 1089, 5, 9, 0, 0, 1089, 1090, 3, 92, 46, 0, 1090, 1091,
		5, 4, 0, 0, 1091, 1093, 5, 7, 0, 0, 1092, 1094, 3, 94, 47, 0, 1093, 1092,
		1, 0, 0, 0, 1093, 1094, 1, 0, 0, 0, 1094, 1095, 1, 0, 0, 0, 1095, 1096,
		5, 8, 0, 0, 1096, 1098, 1, 0, 0, 0, 1097, 1079, 1, 0, 0, 0, 1097, 1085,
		1, 0, 0, 0, 1098, 101, 1, 0, 0, 0, 1099, 1100, 3, 92, 46, 0, 1100, 1104,
		5, 1, 0, 0, 1101, 1103, 3, 96, 48, 0, 1102, 1101, 1, 0, 0, 0, 1103, 1106,
		1, 0, 0, 0, 1104, 1102, 1, 0, 0, 0, 1104, 1105, 1, 0, 0, 0, 1105, 1107,
		1, 0, 0, 0, 1106, 1104, 1, 0, 0, 0, 1107, 1108, 5, 2, 0, 0, 1108, 103,
		1, 0, 0, 0, 1109, 1110, 3, 92, 46, 0, 1110, 1111, 5, 31, 0, 0, 1111, 1112,
		3, 92, 46, 0, 1112, 105, 1, 0, 0, 0, 151, 110, 116, 120, 128, 135, 144,
		148, 160, 169, 171, 185, 188, 208, 213, 227, 231, 241, 253, 266, 272, 277,
		279, 282, 287, 293, 298, 301, 308, 318, 329, 355, 360, 362, 370, 377, 384,
		390, 399, 406, 412, 415, 427, 431, 435, 445, 456, 459, 465, 474, 477, 491,
		501, 504, 508, 512, 516, 520, 524, 528, 532, 539, 547, 550, 554, 561, 563,
		567, 570, 576, 582, 586, 596, 599, 603, 606, 612, 620, 628, 631, 635, 646,
		652, 665, 669, 678, 680, 691, 696, 698, 705, 709, 714, 718, 722, 726, 730,
		736, 742, 751, 755, 760, 763, 769, 771, 778, 784, 811, 817, 821, 827, 834,
		842, 847, 849, 857, 863, 867, 878, 882, 889, 896, 902, 909, 912, 917, 923,
		927, 931, 935, 939, 945, 949, 968, 974, 976, 978, 986, 998, 1003, 1015,
		1027, 1033, 1044, 1052, 1056, 1066, 1075, 1082, 1093, 1097, 1104,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// KuneiformParserInit initializes any static state used to implement KuneiformParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewKuneiformParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func KuneiformParserInit() {
	staticData := &KuneiformParserParserStaticData
	staticData.once.Do(kuneiformparserParserInit)
}

// NewKuneiformParser produces a new parser instance for the optional input antlr.TokenStream.
func NewKuneiformParser(input antlr.TokenStream) *KuneiformParser {
	KuneiformParserInit()
	this := new(KuneiformParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &KuneiformParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "KuneiformParser.g4"

	return this
}

// KuneiformParser tokens.
const (
	KuneiformParserEOF                 = antlr.TokenEOF
	KuneiformParserLBRACE              = 1
	KuneiformParserRBRACE              = 2
	KuneiformParserLBRACKET            = 3
	KuneiformParserRBRACKET            = 4
	KuneiformParserCOL                 = 5
	KuneiformParserSCOL                = 6
	KuneiformParserLPAREN              = 7
	KuneiformParserRPAREN              = 8
	KuneiformParserCOMMA               = 9
	KuneiformParserAT                  = 10
	KuneiformParserEXCL                = 11
	KuneiformParserPERIOD              = 12
	KuneiformParserCONCAT              = 13
	KuneiformParserSTAR                = 14
	KuneiformParserEQUALS              = 15
	KuneiformParserEQUATE              = 16
	KuneiformParserHASH                = 17
	KuneiformParserDOLLAR              = 18
	KuneiformParserMOD                 = 19
	KuneiformParserPLUS                = 20
	KuneiformParserMINUS               = 21
	KuneiformParserDIV                 = 22
	KuneiformParserNEQ                 = 23
	KuneiformParserLT                  = 24
	KuneiformParserLTE                 = 25
	KuneiformParserGT                  = 26
	KuneiformParserGTE                 = 27
	KuneiformParserTYPE_CAST           = 28
	KuneiformParserUNDERSCORE          = 29
	KuneiformParserASSIGN              = 30
	KuneiformParserRANGE               = 31
	KuneiformParserDATABASE            = 32
	KuneiformParserUSE                 = 33
	KuneiformParserTABLE               = 34
	KuneiformParserACTION              = 35
	KuneiformParserPROCEDURE           = 36
	KuneiformParserPUBLIC              = 37
	KuneiformParserPRIVATE             = 38
	KuneiformParserVIEW                = 39
	KuneiformParserOWNER               = 40
	KuneiformParserMIN                 = 41
	KuneiformParserMAX                 = 42
	KuneiformParserMINLEN              = 43
	KuneiformParserMAXLEN              = 44
	KuneiformParserUNIQUE              = 45
	KuneiformParserFOREIGN             = 46
	KuneiformParserPRIMARY             = 47
	KuneiformParserKEY                 = 48
	KuneiformParserON                  = 49
	KuneiformParserDO                  = 50
	KuneiformParserCASCADE             = 51
	KuneiformParserRESTRICT            = 52
	KuneiformParserSET                 = 53
	KuneiformParserDEFAULT             = 54
	KuneiformParserNULL                = 55
	KuneiformParserDELETE              = 56
	KuneiformParserUPDATE              = 57
	KuneiformParserREFERENCES          = 58
	KuneiformParserREF                 = 59
	KuneiformParserNOT                 = 60
	KuneiformParserINDEX               = 61
	KuneiformParserAND                 = 62
	KuneiformParserOR                  = 63
	KuneiformParserLIKE                = 64
	KuneiformParserIN                  = 65
	KuneiformParserBETWEEN             = 66
	KuneiformParserIS                  = 67
	KuneiformParserEXISTS              = 68
	KuneiformParserALL                 = 69
	KuneiformParserANY                 = 70
	KuneiformParserJOIN                = 71
	KuneiformParserLEFT                = 72
	KuneiformParserRIGHT               = 73
	KuneiformParserINNER               = 74
	KuneiformParserAS                  = 75
	KuneiformParserASC                 = 76
	KuneiformParserDESC                = 77
	KuneiformParserLIMIT               = 78
	KuneiformParserOFFSET              = 79
	KuneiformParserORDER               = 80
	KuneiformParserBY                  = 81
	KuneiformParserGROUP               = 82
	KuneiformParserHAVING              = 83
	KuneiformParserRETURNS             = 84
	KuneiformParserNO                  = 85
	KuneiformParserNOTNULL             = 86
	KuneiformParserWITH                = 87
	KuneiformParserCASE                = 88
	KuneiformParserWHEN                = 89
	KuneiformParserTHEN                = 90
	KuneiformParserEND                 = 91
	KuneiformParserDISTINCT            = 92
	KuneiformParserFROM                = 93
	KuneiformParserWHERE               = 94
	KuneiformParserCOLLATE             = 95
	KuneiformParserSELECT              = 96
	KuneiformParserINSERT              = 97
	KuneiformParserVALUES              = 98
	KuneiformParserFULL                = 99
	KuneiformParserUNION               = 100
	KuneiformParserINTERSECT           = 101
	KuneiformParserEXCEPT              = 102
	KuneiformParserNULLS               = 103
	KuneiformParserFIRST               = 104
	KuneiformParserLAST                = 105
	KuneiformParserRETURNING           = 106
	KuneiformParserINTO                = 107
	KuneiformParserCONFLICT            = 108
	KuneiformParserNOTHING             = 109
	KuneiformParserFOR                 = 110
	KuneiformParserIF                  = 111
	KuneiformParserELSEIF              = 112
	KuneiformParserELSE                = 113
	KuneiformParserBREAK               = 114
	KuneiformParserRETURN              = 115
	KuneiformParserNEXT                = 116
	KuneiformParserSTRING_             = 117
	KuneiformParserTRUE                = 118
	KuneiformParserFALSE               = 119
	KuneiformParserDIGITS_             = 120
	KuneiformParserBINARY_             = 121
	KuneiformParserLEGACY_PRIMARY_KEY  = 122
	KuneiformParserLEGACY_FOREIGN_KEY  = 123
	KuneiformParserLEGACY_ON_UPDATE    = 124
	KuneiformParserLEGACY_ON_DELETE    = 125
	KuneiformParserLEGACY_SET_DEFAULT  = 126
	KuneiformParserLEGACY_SET_NULL     = 127
	KuneiformParserLEGACY_NO_ACTION    = 128
	KuneiformParserIDENTIFIER          = 129
	KuneiformParserVARIABLE            = 130
	KuneiformParserCONTEXTUAL_VARIABLE = 131
	KuneiformParserHASH_IDENTIFIER     = 132
	KuneiformParserWS                  = 133
	KuneiformParserBLOCK_COMMENT       = 134
	KuneiformParserLINE_COMMENT        = 135
)

// KuneiformParser rules.
const (
	KuneiformParserRULE_entry                         = 0
	KuneiformParserRULE_literal                       = 1
	KuneiformParserRULE_identifier_list               = 2
	KuneiformParserRULE_type                          = 3
	KuneiformParserRULE_type_cast                     = 4
	KuneiformParserRULE_variable                      = 5
	KuneiformParserRULE_variable_list                 = 6
	KuneiformParserRULE_schema                        = 7
	KuneiformParserRULE_annotation                    = 8
	KuneiformParserRULE_database_declaration          = 9
	KuneiformParserRULE_use_declaration               = 10
	KuneiformParserRULE_table_declaration             = 11
	KuneiformParserRULE_column_def                    = 12
	KuneiformParserRULE_index_def                     = 13
	KuneiformParserRULE_foreign_key_def               = 14
	KuneiformParserRULE_foreign_key_action            = 15
	KuneiformParserRULE_type_list                     = 16
	KuneiformParserRULE_named_type_list               = 17
	KuneiformParserRULE_typed_variable_list           = 18
	KuneiformParserRULE_constraint                    = 19
	KuneiformParserRULE_access_modifier               = 20
	KuneiformParserRULE_action_declaration            = 21
	KuneiformParserRULE_procedure_declaration         = 22
	KuneiformParserRULE_foreign_procedure_declaration = 23
	KuneiformParserRULE_procedure_return              = 24
	KuneiformParserRULE_sql                           = 25
	KuneiformParserRULE_sql_statement                 = 26
	KuneiformParserRULE_common_table_expression       = 27
	KuneiformParserRULE_select_statement              = 28
	KuneiformParserRULE_compound_operator             = 29
	KuneiformParserRULE_ordering_term                 = 30
	KuneiformParserRULE_select_core                   = 31
	KuneiformParserRULE_relation                      = 32
	KuneiformParserRULE_join                          = 33
	KuneiformParserRULE_result_column                 = 34
	KuneiformParserRULE_update_statement              = 35
	KuneiformParserRULE_update_set_clause             = 36
	KuneiformParserRULE_insert_statement              = 37
	KuneiformParserRULE_upsert_clause                 = 38
	KuneiformParserRULE_delete_statement              = 39
	KuneiformParserRULE_sql_expr                      = 40
	KuneiformParserRULE_sql_expr_list                 = 41
	KuneiformParserRULE_sql_function_call             = 42
	KuneiformParserRULE_action_block                  = 43
	KuneiformParserRULE_action_statement              = 44
	KuneiformParserRULE_procedure_block               = 45
	KuneiformParserRULE_procedure_expr                = 46
	KuneiformParserRULE_procedure_expr_list           = 47
	KuneiformParserRULE_statement                     = 48
	KuneiformParserRULE_variable_or_underscore        = 49
	KuneiformParserRULE_procedure_function_call       = 50
	KuneiformParserRULE_if_then_block                 = 51
	KuneiformParserRULE_range                         = 52
)

// IEntryContext is an interface to support dynamic dispatch.
type IEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	Schema() ISchemaContext
	Sql() ISqlContext
	Action_block() IAction_blockContext
	Procedure_block() IProcedure_blockContext

	// IsEntryContext differentiates from other interfaces.
	IsEntryContext()
}

type EntryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntryContext() *EntryContext {
	var p = new(EntryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_entry
	return p
}

func InitEmptyEntryContext(p *EntryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_entry
}

func (*EntryContext) IsEntryContext() {}

func NewEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EntryContext {
	var p = new(EntryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_entry

	return p
}

func (s *EntryContext) GetParser() antlr.Parser { return s.parser }

func (s *EntryContext) EOF() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEOF, 0)
}

func (s *EntryContext) Schema() ISchemaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaContext)
}

func (s *EntryContext) Sql() ISqlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlContext)
}

func (s *EntryContext) Action_block() IAction_blockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_blockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_blockContext)
}

func (s *EntryContext) Procedure_block() IProcedure_blockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_blockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_blockContext)
}

func (s *EntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Entry() (localctx IEntryContext) {
	localctx = NewEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, KuneiformParserRULE_entry)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(110)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(106)
			p.Schema()
		}

	case 2:
		{
			p.SetState(107)
			p.Sql()
		}

	case 3:
		{
			p.SetState(108)
			p.Action_block()
		}

	case 4:
		{
			p.SetState(109)
			p.Procedure_block()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(112)
		p.Match(KuneiformParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) CopyAll(ctx *LiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type String_literalContext struct {
	LiteralContext
}

func NewString_literalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *String_literalContext {
	var p = new(String_literalContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *String_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_literalContext) STRING_() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSTRING_, 0)
}

func (s *String_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitString_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

type Decimal_literalContext struct {
	LiteralContext
}

func NewDecimal_literalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Decimal_literalContext {
	var p = new(Decimal_literalContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *Decimal_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Decimal_literalContext) AllDIGITS_() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserDIGITS_)
}

func (s *Decimal_literalContext) DIGITS_(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserDIGITS_, i)
}

func (s *Decimal_literalContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPERIOD, 0)
}

func (s *Decimal_literalContext) PLUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPLUS, 0)
}

func (s *Decimal_literalContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserMINUS, 0)
}

func (s *Decimal_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitDecimal_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

type Null_literalContext struct {
	LiteralContext
}

func NewNull_literalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Null_literalContext {
	var p = new(Null_literalContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *Null_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Null_literalContext) NULL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNULL, 0)
}

func (s *Null_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitNull_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

type Boolean_literalContext struct {
	LiteralContext
}

func NewBoolean_literalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Boolean_literalContext {
	var p = new(Boolean_literalContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *Boolean_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Boolean_literalContext) TRUE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserTRUE, 0)
}

func (s *Boolean_literalContext) FALSE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFALSE, 0)
}

func (s *Boolean_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitBoolean_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

type Integer_literalContext struct {
	LiteralContext
}

func NewInteger_literalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Integer_literalContext {
	var p = new(Integer_literalContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *Integer_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_literalContext) DIGITS_() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDIGITS_, 0)
}

func (s *Integer_literalContext) PLUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPLUS, 0)
}

func (s *Integer_literalContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserMINUS, 0)
}

func (s *Integer_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitInteger_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

type Binary_literalContext struct {
	LiteralContext
}

func NewBinary_literalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Binary_literalContext {
	var p = new(Binary_literalContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *Binary_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Binary_literalContext) BINARY_() antlr.TerminalNode {
	return s.GetToken(KuneiformParserBINARY_, 0)
}

func (s *Binary_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitBinary_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, KuneiformParserRULE_literal)
	var _la int

	p.SetState(128)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		localctx = NewString_literalContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(114)
			p.Match(KuneiformParserSTRING_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewInteger_literalContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(116)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserPLUS || _la == KuneiformParserMINUS {
			{
				p.SetState(115)
				_la = p.GetTokenStream().LA(1)

				if !(_la == KuneiformParserPLUS || _la == KuneiformParserMINUS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(118)
			p.Match(KuneiformParserDIGITS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewDecimal_literalContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(120)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserPLUS || _la == KuneiformParserMINUS {
			{
				p.SetState(119)
				_la = p.GetTokenStream().LA(1)

				if !(_la == KuneiformParserPLUS || _la == KuneiformParserMINUS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(122)
			p.Match(KuneiformParserDIGITS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(123)
			p.Match(KuneiformParserPERIOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(124)
			p.Match(KuneiformParserDIGITS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewBoolean_literalContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(125)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KuneiformParserTRUE || _la == KuneiformParserFALSE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 5:
		localctx = NewNull_literalContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(126)
			p.Match(KuneiformParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewBinary_literalContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(127)
			p.Match(KuneiformParserBINARY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifier_listContext is an interface to support dynamic dispatch.
type IIdentifier_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentifier_listContext differentiates from other interfaces.
	IsIdentifier_listContext()
}

type Identifier_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifier_listContext() *Identifier_listContext {
	var p = new(Identifier_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_identifier_list
	return p
}

func InitEmptyIdentifier_listContext(p *Identifier_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_identifier_list
}

func (*Identifier_listContext) IsIdentifier_listContext() {}

func NewIdentifier_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Identifier_listContext {
	var p = new(Identifier_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_identifier_list

	return p
}

func (s *Identifier_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Identifier_listContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserIDENTIFIER)
}

func (s *Identifier_listContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, i)
}

func (s *Identifier_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Identifier_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Identifier_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Identifier_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Identifier_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitIdentifier_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Identifier_list() (localctx IIdentifier_listContext) {
	localctx = NewIdentifier_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, KuneiformParserRULE_identifier_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(130)
		p.Match(KuneiformParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(135)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCOMMA {
		{
			p.SetState(131)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(132)
			p.Match(KuneiformParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(137)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllDIGITS_() []antlr.TerminalNode
	DIGITS_(i int) antlr.TerminalNode
	COMMA() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	LBRACKET() antlr.TerminalNode
	RBRACKET() antlr.TerminalNode

	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_type
	return p
}

func InitEmptyTypeContext(p *TypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_type
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *TypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *TypeContext) AllDIGITS_() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserDIGITS_)
}

func (s *TypeContext) DIGITS_(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserDIGITS_, i)
}

func (s *TypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, 0)
}

func (s *TypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *TypeContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACKET, 0)
}

func (s *TypeContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACKET, 0)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Type_() (localctx ITypeContext) {
	localctx = NewTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, KuneiformParserRULE_type)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(138)
		p.Match(KuneiformParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(144)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(139)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(140)
			p.Match(KuneiformParserDIGITS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(141)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(142)
			p.Match(KuneiformParserDIGITS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(143)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(148)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(146)
			p.Match(KuneiformParserLBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(147)
			p.Match(KuneiformParserRBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_castContext is an interface to support dynamic dispatch.
type IType_castContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE_CAST() antlr.TerminalNode
	Type_() ITypeContext

	// IsType_castContext differentiates from other interfaces.
	IsType_castContext()
}

type Type_castContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_castContext() *Type_castContext {
	var p = new(Type_castContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_type_cast
	return p
}

func InitEmptyType_castContext(p *Type_castContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_type_cast
}

func (*Type_castContext) IsType_castContext() {}

func NewType_castContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_castContext {
	var p = new(Type_castContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_type_cast

	return p
}

func (s *Type_castContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_castContext) TYPE_CAST() antlr.TerminalNode {
	return s.GetToken(KuneiformParserTYPE_CAST, 0)
}

func (s *Type_castContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Type_castContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_castContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_castContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitType_cast(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Type_cast() (localctx IType_castContext) {
	localctx = NewType_castContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, KuneiformParserRULE_type_cast)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(150)
		p.Match(KuneiformParserTYPE_CAST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(151)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VARIABLE() antlr.TerminalNode
	CONTEXTUAL_VARIABLE() antlr.TerminalNode

	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_variable
	return p
}

func InitEmptyVariableContext(p *VariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_variable
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserVARIABLE, 0)
}

func (s *VariableContext) CONTEXTUAL_VARIABLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCONTEXTUAL_VARIABLE, 0)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Variable() (localctx IVariableContext) {
	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, KuneiformParserRULE_variable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(153)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KuneiformParserVARIABLE || _la == KuneiformParserCONTEXTUAL_VARIABLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariable_listContext is an interface to support dynamic dispatch.
type IVariable_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariable() []IVariableContext
	Variable(i int) IVariableContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsVariable_listContext differentiates from other interfaces.
	IsVariable_listContext()
}

type Variable_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_listContext() *Variable_listContext {
	var p = new(Variable_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_variable_list
	return p
}

func InitEmptyVariable_listContext(p *Variable_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_variable_list
}

func (*Variable_listContext) IsVariable_listContext() {}

func NewVariable_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_listContext {
	var p = new(Variable_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_variable_list

	return p
}

func (s *Variable_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_listContext) AllVariable() []IVariableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableContext); ok {
			len++
		}
	}

	tst := make([]IVariableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableContext); ok {
			tst[i] = t.(IVariableContext)
			i++
		}
	}

	return tst
}

func (s *Variable_listContext) Variable(i int) IVariableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Variable_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Variable_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Variable_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitVariable_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Variable_list() (localctx IVariable_listContext) {
	localctx = NewVariable_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, KuneiformParserRULE_variable_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(155)
		p.Variable()
	}
	p.SetState(160)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCOMMA {
		{
			p.SetState(156)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(157)
			p.Variable()
		}

		p.SetState(162)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISchemaContext is an interface to support dynamic dispatch.
type ISchemaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Database_declaration() IDatabase_declarationContext
	AllUse_declaration() []IUse_declarationContext
	Use_declaration(i int) IUse_declarationContext
	AllTable_declaration() []ITable_declarationContext
	Table_declaration(i int) ITable_declarationContext
	AllAction_declaration() []IAction_declarationContext
	Action_declaration(i int) IAction_declarationContext
	AllProcedure_declaration() []IProcedure_declarationContext
	Procedure_declaration(i int) IProcedure_declarationContext
	AllForeign_procedure_declaration() []IForeign_procedure_declarationContext
	Foreign_procedure_declaration(i int) IForeign_procedure_declarationContext

	// IsSchemaContext differentiates from other interfaces.
	IsSchemaContext()
}

type SchemaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaContext() *SchemaContext {
	var p = new(SchemaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_schema
	return p
}

func InitEmptySchemaContext(p *SchemaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_schema
}

func (*SchemaContext) IsSchemaContext() {}

func NewSchemaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaContext {
	var p = new(SchemaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_schema

	return p
}

func (s *SchemaContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaContext) Database_declaration() IDatabase_declarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabase_declarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabase_declarationContext)
}

func (s *SchemaContext) AllUse_declaration() []IUse_declarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUse_declarationContext); ok {
			len++
		}
	}

	tst := make([]IUse_declarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUse_declarationContext); ok {
			tst[i] = t.(IUse_declarationContext)
			i++
		}
	}

	return tst
}

func (s *SchemaContext) Use_declaration(i int) IUse_declarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUse_declarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUse_declarationContext)
}

func (s *SchemaContext) AllTable_declaration() []ITable_declarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITable_declarationContext); ok {
			len++
		}
	}

	tst := make([]ITable_declarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITable_declarationContext); ok {
			tst[i] = t.(ITable_declarationContext)
			i++
		}
	}

	return tst
}

func (s *SchemaContext) Table_declaration(i int) ITable_declarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_declarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_declarationContext)
}

func (s *SchemaContext) AllAction_declaration() []IAction_declarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAction_declarationContext); ok {
			len++
		}
	}

	tst := make([]IAction_declarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAction_declarationContext); ok {
			tst[i] = t.(IAction_declarationContext)
			i++
		}
	}

	return tst
}

func (s *SchemaContext) Action_declaration(i int) IAction_declarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_declarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_declarationContext)
}

func (s *SchemaContext) AllProcedure_declaration() []IProcedure_declarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedure_declarationContext); ok {
			len++
		}
	}

	tst := make([]IProcedure_declarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedure_declarationContext); ok {
			tst[i] = t.(IProcedure_declarationContext)
			i++
		}
	}

	return tst
}

func (s *SchemaContext) Procedure_declaration(i int) IProcedure_declarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_declarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_declarationContext)
}

func (s *SchemaContext) AllForeign_procedure_declaration() []IForeign_procedure_declarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IForeign_procedure_declarationContext); ok {
			len++
		}
	}

	tst := make([]IForeign_procedure_declarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IForeign_procedure_declarationContext); ok {
			tst[i] = t.(IForeign_procedure_declarationContext)
			i++
		}
	}

	return tst
}

func (s *SchemaContext) Foreign_procedure_declaration(i int) IForeign_procedure_declarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForeign_procedure_declarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForeign_procedure_declarationContext)
}

func (s *SchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitSchema(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Schema() (localctx ISchemaContext) {
	localctx = NewSchemaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, KuneiformParserRULE_schema)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(163)
		p.Database_declaration()
	}
	p.SetState(171)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&70497593196544) != 0) || _la == KuneiformParserCONTEXTUAL_VARIABLE {
		p.SetState(169)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(164)
				p.Use_declaration()
			}

		case 2:
			{
				p.SetState(165)
				p.Table_declaration()
			}

		case 3:
			{
				p.SetState(166)
				p.Action_declaration()
			}

		case 4:
			{
				p.SetState(167)
				p.Procedure_declaration()
			}

		case 5:
			{
				p.SetState(168)
				p.Foreign_procedure_declaration()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(173)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONTEXTUAL_VARIABLE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	AllEQUALS() []antlr.TerminalNode
	EQUALS(i int) antlr.TerminalNode
	AllLiteral() []ILiteralContext
	Literal(i int) ILiteralContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_annotation
	return p
}

func InitEmptyAnnotationContext(p *AnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_annotation
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) CONTEXTUAL_VARIABLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCONTEXTUAL_VARIABLE, 0)
}

func (s *AnnotationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *AnnotationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *AnnotationContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserIDENTIFIER)
}

func (s *AnnotationContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, i)
}

func (s *AnnotationContext) AllEQUALS() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserEQUALS)
}

func (s *AnnotationContext) EQUALS(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserEQUALS, i)
}

func (s *AnnotationContext) AllLiteral() []ILiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILiteralContext); ok {
			len++
		}
	}

	tst := make([]ILiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILiteralContext); ok {
			tst[i] = t.(ILiteralContext)
			i++
		}
	}

	return tst
}

func (s *AnnotationContext) Literal(i int) ILiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AnnotationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *AnnotationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitAnnotation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Annotation() (localctx IAnnotationContext) {
	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, KuneiformParserRULE_annotation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(174)
		p.Match(KuneiformParserCONTEXTUAL_VARIABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(175)
		p.Match(KuneiformParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(188)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserIDENTIFIER {
		{
			p.SetState(176)
			p.Match(KuneiformParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(177)
			p.Match(KuneiformParserEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(178)
			p.Literal()
		}
		p.SetState(185)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KuneiformParserCOMMA {
			{
				p.SetState(179)
				p.Match(KuneiformParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(180)
				p.Match(KuneiformParserIDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(181)
				p.Match(KuneiformParserEQUALS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(182)
				p.Literal()
			}

			p.SetState(187)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(190)
		p.Match(KuneiformParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatabase_declarationContext is an interface to support dynamic dispatch.
type IDatabase_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATABASE() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	SCOL() antlr.TerminalNode

	// IsDatabase_declarationContext differentiates from other interfaces.
	IsDatabase_declarationContext()
}

type Database_declarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabase_declarationContext() *Database_declarationContext {
	var p = new(Database_declarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_database_declaration
	return p
}

func InitEmptyDatabase_declarationContext(p *Database_declarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_database_declaration
}

func (*Database_declarationContext) IsDatabase_declarationContext() {}

func NewDatabase_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Database_declarationContext {
	var p = new(Database_declarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_database_declaration

	return p
}

func (s *Database_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Database_declarationContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDATABASE, 0)
}

func (s *Database_declarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *Database_declarationContext) SCOL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, 0)
}

func (s *Database_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Database_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Database_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitDatabase_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Database_declaration() (localctx IDatabase_declarationContext) {
	localctx = NewDatabase_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, KuneiformParserRULE_database_declaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(192)
		p.Match(KuneiformParserDATABASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(193)
		p.Match(KuneiformParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(194)
		p.Match(KuneiformParserSCOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUse_declarationContext is an interface to support dynamic dispatch.
type IUse_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USE() antlr.TerminalNode
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	AS() antlr.TerminalNode
	SCOL() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	AllCOL() []antlr.TerminalNode
	COL(i int) antlr.TerminalNode
	AllLiteral() []ILiteralContext
	Literal(i int) ILiteralContext
	RBRACE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUse_declarationContext differentiates from other interfaces.
	IsUse_declarationContext()
}

type Use_declarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUse_declarationContext() *Use_declarationContext {
	var p = new(Use_declarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_use_declaration
	return p
}

func InitEmptyUse_declarationContext(p *Use_declarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_use_declaration
}

func (*Use_declarationContext) IsUse_declarationContext() {}

func NewUse_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Use_declarationContext {
	var p = new(Use_declarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_use_declaration

	return p
}

func (s *Use_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Use_declarationContext) USE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUSE, 0)
}

func (s *Use_declarationContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserIDENTIFIER)
}

func (s *Use_declarationContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, i)
}

func (s *Use_declarationContext) AS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAS, 0)
}

func (s *Use_declarationContext) SCOL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, 0)
}

func (s *Use_declarationContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACE, 0)
}

func (s *Use_declarationContext) AllCOL() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOL)
}

func (s *Use_declarationContext) COL(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOL, i)
}

func (s *Use_declarationContext) AllLiteral() []ILiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILiteralContext); ok {
			len++
		}
	}

	tst := make([]ILiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILiteralContext); ok {
			tst[i] = t.(ILiteralContext)
			i++
		}
	}

	return tst
}

func (s *Use_declarationContext) Literal(i int) ILiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *Use_declarationContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACE, 0)
}

func (s *Use_declarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Use_declarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Use_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Use_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Use_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitUse_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Use_declaration() (localctx IUse_declarationContext) {
	localctx = NewUse_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, KuneiformParserRULE_use_declaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(196)
		p.Match(KuneiformParserUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(197)
		p.Match(KuneiformParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(213)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserLBRACE {
		{
			p.SetState(198)
			p.Match(KuneiformParserLBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(199)
			p.Match(KuneiformParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(200)
			p.Match(KuneiformParserCOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(201)
			p.Literal()
		}
		p.SetState(208)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KuneiformParserCOMMA {
			{
				p.SetState(202)
				p.Match(KuneiformParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(203)
				p.Match(KuneiformParserIDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(204)
				p.Match(KuneiformParserCOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(205)
				p.Literal()
			}

			p.SetState(210)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(211)
			p.Match(KuneiformParserRBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(215)
		p.Match(KuneiformParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(216)
		p.Match(KuneiformParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(217)
		p.Match(KuneiformParserSCOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_declarationContext is an interface to support dynamic dispatch.
type ITable_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLE() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	AllColumn_def() []IColumn_defContext
	Column_def(i int) IColumn_defContext
	RBRACE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllIndex_def() []IIndex_defContext
	Index_def(i int) IIndex_defContext
	AllForeign_key_def() []IForeign_key_defContext
	Foreign_key_def(i int) IForeign_key_defContext

	// IsTable_declarationContext differentiates from other interfaces.
	IsTable_declarationContext()
}

type Table_declarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_declarationContext() *Table_declarationContext {
	var p = new(Table_declarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_table_declaration
	return p
}

func InitEmptyTable_declarationContext(p *Table_declarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_table_declaration
}

func (*Table_declarationContext) IsTable_declarationContext() {}

func NewTable_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_declarationContext {
	var p = new(Table_declarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_table_declaration

	return p
}

func (s *Table_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_declarationContext) TABLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserTABLE, 0)
}

func (s *Table_declarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *Table_declarationContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACE, 0)
}

func (s *Table_declarationContext) AllColumn_def() []IColumn_defContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumn_defContext); ok {
			len++
		}
	}

	tst := make([]IColumn_defContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumn_defContext); ok {
			tst[i] = t.(IColumn_defContext)
			i++
		}
	}

	return tst
}

func (s *Table_declarationContext) Column_def(i int) IColumn_defContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_defContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_defContext)
}

func (s *Table_declarationContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACE, 0)
}

func (s *Table_declarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Table_declarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Table_declarationContext) AllIndex_def() []IIndex_defContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndex_defContext); ok {
			len++
		}
	}

	tst := make([]IIndex_defContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndex_defContext); ok {
			tst[i] = t.(IIndex_defContext)
			i++
		}
	}

	return tst
}

func (s *Table_declarationContext) Index_def(i int) IIndex_defContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_defContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_defContext)
}

func (s *Table_declarationContext) AllForeign_key_def() []IForeign_key_defContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IForeign_key_defContext); ok {
			len++
		}
	}

	tst := make([]IForeign_key_defContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IForeign_key_defContext); ok {
			tst[i] = t.(IForeign_key_defContext)
			i++
		}
	}

	return tst
}

func (s *Table_declarationContext) Foreign_key_def(i int) IForeign_key_defContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForeign_key_defContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForeign_key_defContext)
}

func (s *Table_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitTable_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Table_declaration() (localctx ITable_declarationContext) {
	localctx = NewTable_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, KuneiformParserRULE_table_declaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(219)
		p.Match(KuneiformParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(220)
		p.Match(KuneiformParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(221)
		p.Match(KuneiformParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(222)
		p.Column_def()
	}
	p.SetState(231)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCOMMA {
		{
			p.SetState(223)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(227)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case KuneiformParserIDENTIFIER:
			{
				p.SetState(224)
				p.Column_def()
			}

		case KuneiformParserHASH_IDENTIFIER:
			{
				p.SetState(225)
				p.Index_def()
			}

		case KuneiformParserFOREIGN, KuneiformParserLEGACY_FOREIGN_KEY:
			{
				p.SetState(226)
				p.Foreign_key_def()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(233)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(234)
		p.Match(KuneiformParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_defContext is an interface to support dynamic dispatch.
type IColumn_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	Type_() ITypeContext
	IDENTIFIER() antlr.TerminalNode
	AllConstraint() []IConstraintContext
	Constraint(i int) IConstraintContext

	// IsColumn_defContext differentiates from other interfaces.
	IsColumn_defContext()
}

type Column_defContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyColumn_defContext() *Column_defContext {
	var p = new(Column_defContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_column_def
	return p
}

func InitEmptyColumn_defContext(p *Column_defContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_column_def
}

func (*Column_defContext) IsColumn_defContext() {}

func NewColumn_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_defContext {
	var p = new(Column_defContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_column_def

	return p
}

func (s *Column_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_defContext) GetName() antlr.Token { return s.name }

func (s *Column_defContext) SetName(v antlr.Token) { s.name = v }

func (s *Column_defContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Column_defContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *Column_defContext) AllConstraint() []IConstraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstraintContext); ok {
			len++
		}
	}

	tst := make([]IConstraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstraintContext); ok {
			tst[i] = t.(IConstraintContext)
			i++
		}
	}

	return tst
}

func (s *Column_defContext) Constraint(i int) IConstraintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintContext)
}

func (s *Column_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_defContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitColumn_def(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Column_def() (localctx IColumn_defContext) {
	localctx = NewColumn_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, KuneiformParserRULE_column_def)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(236)

		var _m = p.Match(KuneiformParserIDENTIFIER)

		localctx.(*Column_defContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(237)
		p.Type_()
	}
	p.SetState(241)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1171144810325606400) != 0) || _la == KuneiformParserNOTNULL || _la == KuneiformParserLEGACY_PRIMARY_KEY {
		{
			p.SetState(238)
			p.Constraint()
		}

		p.SetState(243)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_defContext is an interface to support dynamic dispatch.
type IIndex_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetColumns returns the columns rule contexts.
	GetColumns() IIdentifier_listContext

	// SetColumns sets the columns rule contexts.
	SetColumns(IIdentifier_listContext)

	// Getter signatures
	HASH_IDENTIFIER() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	Identifier_list() IIdentifier_listContext

	// IsIndex_defContext differentiates from other interfaces.
	IsIndex_defContext()
}

type Index_defContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	columns IIdentifier_listContext
}

func NewEmptyIndex_defContext() *Index_defContext {
	var p = new(Index_defContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_index_def
	return p
}

func InitEmptyIndex_defContext(p *Index_defContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_index_def
}

func (*Index_defContext) IsIndex_defContext() {}

func NewIndex_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_defContext {
	var p = new(Index_defContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_index_def

	return p
}

func (s *Index_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_defContext) GetColumns() IIdentifier_listContext { return s.columns }

func (s *Index_defContext) SetColumns(v IIdentifier_listContext) { s.columns = v }

func (s *Index_defContext) HASH_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserHASH_IDENTIFIER, 0)
}

func (s *Index_defContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Index_defContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Index_defContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUNIQUE, 0)
}

func (s *Index_defContext) INDEX() antlr.TerminalNode {
	return s.GetToken(KuneiformParserINDEX, 0)
}

func (s *Index_defContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPRIMARY, 0)
}

func (s *Index_defContext) Identifier_list() IIdentifier_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifier_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Index_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_defContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitIndex_def(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Index_def() (localctx IIndex_defContext) {
	localctx = NewIndex_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, KuneiformParserRULE_index_def)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(244)
		p.Match(KuneiformParserHASH_IDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(245)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2306018931074138112) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(246)
		p.Match(KuneiformParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(247)

		var _x = p.Identifier_list()

		localctx.(*Index_defContext).columns = _x
	}
	{
		p.SetState(248)
		p.Match(KuneiformParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForeign_key_defContext is an interface to support dynamic dispatch.
type IForeign_key_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetParent_table returns the parent_table token.
	GetParent_table() antlr.Token

	// SetParent_table sets the parent_table token.
	SetParent_table(antlr.Token)

	// GetChild_keys returns the child_keys rule contexts.
	GetChild_keys() IIdentifier_listContext

	// GetParent_keys returns the parent_keys rule contexts.
	GetParent_keys() IIdentifier_listContext

	// SetChild_keys sets the child_keys rule contexts.
	SetChild_keys(IIdentifier_listContext)

	// SetParent_keys sets the parent_keys rule contexts.
	SetParent_keys(IIdentifier_listContext)

	// Getter signatures
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	AllIdentifier_list() []IIdentifier_listContext
	Identifier_list(i int) IIdentifier_listContext
	REFERENCES() antlr.TerminalNode
	REF() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	FOREIGN() antlr.TerminalNode
	KEY() antlr.TerminalNode
	LEGACY_FOREIGN_KEY() antlr.TerminalNode
	AllForeign_key_action() []IForeign_key_actionContext
	Foreign_key_action(i int) IForeign_key_actionContext

	// IsForeign_key_defContext differentiates from other interfaces.
	IsForeign_key_defContext()
}

type Foreign_key_defContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	child_keys   IIdentifier_listContext
	parent_table antlr.Token
	parent_keys  IIdentifier_listContext
}

func NewEmptyForeign_key_defContext() *Foreign_key_defContext {
	var p = new(Foreign_key_defContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_foreign_key_def
	return p
}

func InitEmptyForeign_key_defContext(p *Foreign_key_defContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_foreign_key_def
}

func (*Foreign_key_defContext) IsForeign_key_defContext() {}

func NewForeign_key_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Foreign_key_defContext {
	var p = new(Foreign_key_defContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_foreign_key_def

	return p
}

func (s *Foreign_key_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Foreign_key_defContext) GetParent_table() antlr.Token { return s.parent_table }

func (s *Foreign_key_defContext) SetParent_table(v antlr.Token) { s.parent_table = v }

func (s *Foreign_key_defContext) GetChild_keys() IIdentifier_listContext { return s.child_keys }

func (s *Foreign_key_defContext) GetParent_keys() IIdentifier_listContext { return s.parent_keys }

func (s *Foreign_key_defContext) SetChild_keys(v IIdentifier_listContext) { s.child_keys = v }

func (s *Foreign_key_defContext) SetParent_keys(v IIdentifier_listContext) { s.parent_keys = v }

func (s *Foreign_key_defContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserLPAREN)
}

func (s *Foreign_key_defContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, i)
}

func (s *Foreign_key_defContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserRPAREN)
}

func (s *Foreign_key_defContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, i)
}

func (s *Foreign_key_defContext) AllIdentifier_list() []IIdentifier_listContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifier_listContext); ok {
			len++
		}
	}

	tst := make([]IIdentifier_listContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifier_listContext); ok {
			tst[i] = t.(IIdentifier_listContext)
			i++
		}
	}

	return tst
}

func (s *Foreign_key_defContext) Identifier_list(i int) IIdentifier_listContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifier_listContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Foreign_key_defContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(KuneiformParserREFERENCES, 0)
}

func (s *Foreign_key_defContext) REF() antlr.TerminalNode {
	return s.GetToken(KuneiformParserREF, 0)
}

func (s *Foreign_key_defContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *Foreign_key_defContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFOREIGN, 0)
}

func (s *Foreign_key_defContext) KEY() antlr.TerminalNode {
	return s.GetToken(KuneiformParserKEY, 0)
}

func (s *Foreign_key_defContext) LEGACY_FOREIGN_KEY() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLEGACY_FOREIGN_KEY, 0)
}

func (s *Foreign_key_defContext) AllForeign_key_action() []IForeign_key_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IForeign_key_actionContext); ok {
			len++
		}
	}

	tst := make([]IForeign_key_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IForeign_key_actionContext); ok {
			tst[i] = t.(IForeign_key_actionContext)
			i++
		}
	}

	return tst
}

func (s *Foreign_key_defContext) Foreign_key_action(i int) IForeign_key_actionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForeign_key_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForeign_key_actionContext)
}

func (s *Foreign_key_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Foreign_key_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Foreign_key_defContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitForeign_key_def(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Foreign_key_def() (localctx IForeign_key_defContext) {
	localctx = NewForeign_key_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, KuneiformParserRULE_foreign_key_def)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(253)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KuneiformParserFOREIGN:
		{
			p.SetState(250)
			p.Match(KuneiformParserFOREIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(251)
			p.Match(KuneiformParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KuneiformParserLEGACY_FOREIGN_KEY:
		{
			p.SetState(252)
			p.Match(KuneiformParserLEGACY_FOREIGN_KEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(255)
		p.Match(KuneiformParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(256)

		var _x = p.Identifier_list()

		localctx.(*Foreign_key_defContext).child_keys = _x
	}
	{
		p.SetState(257)
		p.Match(KuneiformParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(258)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KuneiformParserREFERENCES || _la == KuneiformParserREF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(259)

		var _m = p.Match(KuneiformParserIDENTIFIER)

		localctx.(*Foreign_key_defContext).parent_table = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(260)
		p.Match(KuneiformParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(261)

		var _x = p.Identifier_list()

		localctx.(*Foreign_key_defContext).parent_keys = _x
	}
	{
		p.SetState(262)
		p.Match(KuneiformParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(266)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserON || _la == KuneiformParserLEGACY_ON_UPDATE || _la == KuneiformParserLEGACY_ON_DELETE {
		{
			p.SetState(263)
			p.Foreign_key_action()
		}

		p.SetState(268)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForeign_key_actionContext is an interface to support dynamic dispatch.
type IForeign_key_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASCADE() antlr.TerminalNode
	RESTRICT() antlr.TerminalNode
	DO() antlr.TerminalNode
	ON() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	LEGACY_ON_UPDATE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	LEGACY_ON_DELETE() antlr.TerminalNode
	NO() antlr.TerminalNode
	ACTION() antlr.TerminalNode
	LEGACY_NO_ACTION() antlr.TerminalNode
	SET() antlr.TerminalNode
	NULL() antlr.TerminalNode
	LEGACY_SET_NULL() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	LEGACY_SET_DEFAULT() antlr.TerminalNode

	// IsForeign_key_actionContext differentiates from other interfaces.
	IsForeign_key_actionContext()
}

type Foreign_key_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForeign_key_actionContext() *Foreign_key_actionContext {
	var p = new(Foreign_key_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_foreign_key_action
	return p
}

func InitEmptyForeign_key_actionContext(p *Foreign_key_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_foreign_key_action
}

func (*Foreign_key_actionContext) IsForeign_key_actionContext() {}

func NewForeign_key_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Foreign_key_actionContext {
	var p = new(Foreign_key_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_foreign_key_action

	return p
}

func (s *Foreign_key_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Foreign_key_actionContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCASCADE, 0)
}

func (s *Foreign_key_actionContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRESTRICT, 0)
}

func (s *Foreign_key_actionContext) DO() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDO, 0)
}

func (s *Foreign_key_actionContext) ON() antlr.TerminalNode {
	return s.GetToken(KuneiformParserON, 0)
}

func (s *Foreign_key_actionContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUPDATE, 0)
}

func (s *Foreign_key_actionContext) LEGACY_ON_UPDATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLEGACY_ON_UPDATE, 0)
}

func (s *Foreign_key_actionContext) DELETE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDELETE, 0)
}

func (s *Foreign_key_actionContext) LEGACY_ON_DELETE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLEGACY_ON_DELETE, 0)
}

func (s *Foreign_key_actionContext) NO() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNO, 0)
}

func (s *Foreign_key_actionContext) ACTION() antlr.TerminalNode {
	return s.GetToken(KuneiformParserACTION, 0)
}

func (s *Foreign_key_actionContext) LEGACY_NO_ACTION() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLEGACY_NO_ACTION, 0)
}

func (s *Foreign_key_actionContext) SET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSET, 0)
}

func (s *Foreign_key_actionContext) NULL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNULL, 0)
}

func (s *Foreign_key_actionContext) LEGACY_SET_NULL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLEGACY_SET_NULL, 0)
}

func (s *Foreign_key_actionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDEFAULT, 0)
}

func (s *Foreign_key_actionContext) LEGACY_SET_DEFAULT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLEGACY_SET_DEFAULT, 0)
}

func (s *Foreign_key_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Foreign_key_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Foreign_key_actionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitForeign_key_action(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Foreign_key_action() (localctx IForeign_key_actionContext) {
	localctx = NewForeign_key_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, KuneiformParserRULE_foreign_key_action)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(279)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) {
	case 1:
		p.SetState(272)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case KuneiformParserON:
			{
				p.SetState(269)
				p.Match(KuneiformParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(270)
				p.Match(KuneiformParserUPDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case KuneiformParserLEGACY_ON_UPDATE:
			{
				p.SetState(271)
				p.Match(KuneiformParserLEGACY_ON_UPDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.SetState(277)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case KuneiformParserON:
			{
				p.SetState(274)
				p.Match(KuneiformParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(275)
				p.Match(KuneiformParserDELETE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case KuneiformParserLEGACY_ON_DELETE:
			{
				p.SetState(276)
				p.Match(KuneiformParserLEGACY_ON_DELETE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(282)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserDO {
		{
			p.SetState(281)
			p.Match(KuneiformParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(301)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.SetState(287)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case KuneiformParserNO:
			{
				p.SetState(284)
				p.Match(KuneiformParserNO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(285)
				p.Match(KuneiformParserACTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case KuneiformParserLEGACY_NO_ACTION:
			{
				p.SetState(286)
				p.Match(KuneiformParserLEGACY_NO_ACTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		{
			p.SetState(289)
			p.Match(KuneiformParserCASCADE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.SetState(293)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case KuneiformParserSET:
			{
				p.SetState(290)
				p.Match(KuneiformParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(291)
				p.Match(KuneiformParserNULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case KuneiformParserLEGACY_SET_NULL:
			{
				p.SetState(292)
				p.Match(KuneiformParserLEGACY_SET_NULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		p.SetState(298)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case KuneiformParserSET:
			{
				p.SetState(295)
				p.Match(KuneiformParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(296)
				p.Match(KuneiformParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case KuneiformParserLEGACY_SET_DEFAULT:
			{
				p.SetState(297)
				p.Match(KuneiformParserLEGACY_SET_DEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 5:
		{
			p.SetState(300)
			p.Match(KuneiformParserRESTRICT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_listContext is an interface to support dynamic dispatch.
type IType_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsType_listContext differentiates from other interfaces.
	IsType_listContext()
}

type Type_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_listContext() *Type_listContext {
	var p = new(Type_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_type_list
	return p
}

func InitEmptyType_listContext(p *Type_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_type_list
}

func (*Type_listContext) IsType_listContext() {}

func NewType_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_listContext {
	var p = new(Type_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_type_list

	return p
}

func (s *Type_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_listContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *Type_listContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Type_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Type_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Type_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitType_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Type_list() (localctx IType_listContext) {
	localctx = NewType_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, KuneiformParserRULE_type_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(303)
		p.Type_()
	}
	p.SetState(308)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCOMMA {
		{
			p.SetState(304)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(305)
			p.Type_()
		}

		p.SetState(310)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamed_type_listContext is an interface to support dynamic dispatch.
type INamed_type_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNamed_type_listContext differentiates from other interfaces.
	IsNamed_type_listContext()
}

type Named_type_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_type_listContext() *Named_type_listContext {
	var p = new(Named_type_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_named_type_list
	return p
}

func InitEmptyNamed_type_listContext(p *Named_type_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_named_type_list
}

func (*Named_type_listContext) IsNamed_type_listContext() {}

func NewNamed_type_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_type_listContext {
	var p = new(Named_type_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_named_type_list

	return p
}

func (s *Named_type_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_type_listContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserIDENTIFIER)
}

func (s *Named_type_listContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, i)
}

func (s *Named_type_listContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *Named_type_listContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Named_type_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Named_type_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Named_type_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_type_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_type_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitNamed_type_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Named_type_list() (localctx INamed_type_listContext) {
	localctx = NewNamed_type_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, KuneiformParserRULE_named_type_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(311)
		p.Match(KuneiformParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(312)
		p.Type_()
	}
	p.SetState(318)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCOMMA {
		{
			p.SetState(313)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(314)
			p.Match(KuneiformParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(315)
			p.Type_()
		}

		p.SetState(320)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITyped_variable_listContext is an interface to support dynamic dispatch.
type ITyped_variable_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariable() []IVariableContext
	Variable(i int) IVariableContext
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTyped_variable_listContext differentiates from other interfaces.
	IsTyped_variable_listContext()
}

type Typed_variable_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTyped_variable_listContext() *Typed_variable_listContext {
	var p = new(Typed_variable_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_typed_variable_list
	return p
}

func InitEmptyTyped_variable_listContext(p *Typed_variable_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_typed_variable_list
}

func (*Typed_variable_listContext) IsTyped_variable_listContext() {}

func NewTyped_variable_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Typed_variable_listContext {
	var p = new(Typed_variable_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_typed_variable_list

	return p
}

func (s *Typed_variable_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Typed_variable_listContext) AllVariable() []IVariableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableContext); ok {
			len++
		}
	}

	tst := make([]IVariableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableContext); ok {
			tst[i] = t.(IVariableContext)
			i++
		}
	}

	return tst
}

func (s *Typed_variable_listContext) Variable(i int) IVariableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Typed_variable_listContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *Typed_variable_listContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Typed_variable_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Typed_variable_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Typed_variable_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Typed_variable_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Typed_variable_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitTyped_variable_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Typed_variable_list() (localctx ITyped_variable_listContext) {
	localctx = NewTyped_variable_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, KuneiformParserRULE_typed_variable_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(321)
		p.Variable()
	}
	{
		p.SetState(322)
		p.Type_()
	}
	p.SetState(329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCOMMA {
		{
			p.SetState(323)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(324)
			p.Variable()
		}
		{
			p.SetState(325)
			p.Type_()
		}

		p.SetState(331)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstraintContext is an interface to support dynamic dispatch.
type IConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsConstraintContext differentiates from other interfaces.
	IsConstraintContext()
}

type ConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintContext() *ConstraintContext {
	var p = new(ConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_constraint
	return p
}

func InitEmptyConstraintContext(p *ConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_constraint
}

func (*ConstraintContext) IsConstraintContext() {}

func NewConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintContext {
	var p = new(ConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_constraint

	return p
}

func (s *ConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintContext) CopyAll(ctx *ConstraintContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type MIN_LENContext struct {
	ConstraintContext
}

func NewMIN_LENContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MIN_LENContext {
	var p = new(MIN_LENContext)

	InitEmptyConstraintContext(&p.ConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstraintContext))

	return p
}

func (s *MIN_LENContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MIN_LENContext) MINLEN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserMINLEN, 0)
}

func (s *MIN_LENContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *MIN_LENContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *MIN_LENContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *MIN_LENContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitMIN_LEN(s)

	default:
		return t.VisitChildren(s)
	}
}

type MINContext struct {
	ConstraintContext
}

func NewMINContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MINContext {
	var p = new(MINContext)

	InitEmptyConstraintContext(&p.ConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstraintContext))

	return p
}

func (s *MINContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MINContext) MIN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserMIN, 0)
}

func (s *MINContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *MINContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *MINContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *MINContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitMIN(s)

	default:
		return t.VisitChildren(s)
	}
}

type PRIMARY_KEYContext struct {
	ConstraintContext
}

func NewPRIMARY_KEYContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PRIMARY_KEYContext {
	var p = new(PRIMARY_KEYContext)

	InitEmptyConstraintContext(&p.ConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstraintContext))

	return p
}

func (s *PRIMARY_KEYContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PRIMARY_KEYContext) LEGACY_PRIMARY_KEY() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLEGACY_PRIMARY_KEY, 0)
}

func (s *PRIMARY_KEYContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPRIMARY, 0)
}

func (s *PRIMARY_KEYContext) KEY() antlr.TerminalNode {
	return s.GetToken(KuneiformParserKEY, 0)
}

func (s *PRIMARY_KEYContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitPRIMARY_KEY(s)

	default:
		return t.VisitChildren(s)
	}
}

type MAXContext struct {
	ConstraintContext
}

func NewMAXContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MAXContext {
	var p = new(MAXContext)

	InitEmptyConstraintContext(&p.ConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstraintContext))

	return p
}

func (s *MAXContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MAXContext) MAX() antlr.TerminalNode {
	return s.GetToken(KuneiformParserMAX, 0)
}

func (s *MAXContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *MAXContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *MAXContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *MAXContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitMAX(s)

	default:
		return t.VisitChildren(s)
	}
}

type MAX_LENContext struct {
	ConstraintContext
}

func NewMAX_LENContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MAX_LENContext {
	var p = new(MAX_LENContext)

	InitEmptyConstraintContext(&p.ConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstraintContext))

	return p
}

func (s *MAX_LENContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MAX_LENContext) MAXLEN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserMAXLEN, 0)
}

func (s *MAX_LENContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *MAX_LENContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *MAX_LENContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *MAX_LENContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitMAX_LEN(s)

	default:
		return t.VisitChildren(s)
	}
}

type UNIQUEContext struct {
	ConstraintContext
}

func NewUNIQUEContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UNIQUEContext {
	var p = new(UNIQUEContext)

	InitEmptyConstraintContext(&p.ConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstraintContext))

	return p
}

func (s *UNIQUEContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UNIQUEContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUNIQUE, 0)
}

func (s *UNIQUEContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitUNIQUE(s)

	default:
		return t.VisitChildren(s)
	}
}

type NOT_NULLContext struct {
	ConstraintContext
}

func NewNOT_NULLContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NOT_NULLContext {
	var p = new(NOT_NULLContext)

	InitEmptyConstraintContext(&p.ConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstraintContext))

	return p
}

func (s *NOT_NULLContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NOT_NULLContext) NOTNULL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOTNULL, 0)
}

func (s *NOT_NULLContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *NOT_NULLContext) NULL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNULL, 0)
}

func (s *NOT_NULLContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitNOT_NULL(s)

	default:
		return t.VisitChildren(s)
	}
}

type DEFAULTContext struct {
	ConstraintContext
}

func NewDEFAULTContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DEFAULTContext {
	var p = new(DEFAULTContext)

	InitEmptyConstraintContext(&p.ConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstraintContext))

	return p
}

func (s *DEFAULTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DEFAULTContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDEFAULT, 0)
}

func (s *DEFAULTContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *DEFAULTContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DEFAULTContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *DEFAULTContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitDEFAULT(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Constraint() (localctx IConstraintContext) {
	localctx = NewConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, KuneiformParserRULE_constraint)
	var _la int

	p.SetState(370)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KuneiformParserMIN:
		localctx = NewMINContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(332)
			p.Match(KuneiformParserMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(333)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(334)
			p.Literal()
		}
		{
			p.SetState(335)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KuneiformParserMAX:
		localctx = NewMAXContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(337)
			p.Match(KuneiformParserMAX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(338)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(339)
			p.Literal()
		}
		{
			p.SetState(340)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KuneiformParserMINLEN:
		localctx = NewMIN_LENContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(342)
			p.Match(KuneiformParserMINLEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(343)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(344)
			p.Literal()
		}
		{
			p.SetState(345)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KuneiformParserMAXLEN:
		localctx = NewMAX_LENContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(347)
			p.Match(KuneiformParserMAXLEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(348)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(349)
			p.Literal()
		}
		{
			p.SetState(350)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KuneiformParserNOT, KuneiformParserNOTNULL:
		localctx = NewNOT_NULLContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(355)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case KuneiformParserNOTNULL:
			{
				p.SetState(352)
				p.Match(KuneiformParserNOTNULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case KuneiformParserNOT:
			{
				p.SetState(353)
				p.Match(KuneiformParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(354)
				p.Match(KuneiformParserNULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case KuneiformParserPRIMARY, KuneiformParserLEGACY_PRIMARY_KEY:
		localctx = NewPRIMARY_KEYContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(362)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case KuneiformParserLEGACY_PRIMARY_KEY:
			{
				p.SetState(357)
				p.Match(KuneiformParserLEGACY_PRIMARY_KEY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case KuneiformParserPRIMARY:
			{
				p.SetState(358)
				p.Match(KuneiformParserPRIMARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(360)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == KuneiformParserKEY {
				{
					p.SetState(359)
					p.Match(KuneiformParserKEY)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case KuneiformParserDEFAULT:
		localctx = NewDEFAULTContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(364)
			p.Match(KuneiformParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(365)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(366)
			p.Literal()
		}
		{
			p.SetState(367)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KuneiformParserUNIQUE:
		localctx = NewUNIQUEContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(369)
			p.Match(KuneiformParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAccess_modifierContext is an interface to support dynamic dispatch.
type IAccess_modifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PUBLIC() antlr.TerminalNode
	PRIVATE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	OWNER() antlr.TerminalNode

	// IsAccess_modifierContext differentiates from other interfaces.
	IsAccess_modifierContext()
}

type Access_modifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccess_modifierContext() *Access_modifierContext {
	var p = new(Access_modifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_access_modifier
	return p
}

func InitEmptyAccess_modifierContext(p *Access_modifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_access_modifier
}

func (*Access_modifierContext) IsAccess_modifierContext() {}

func NewAccess_modifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Access_modifierContext {
	var p = new(Access_modifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_access_modifier

	return p
}

func (s *Access_modifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Access_modifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPUBLIC, 0)
}

func (s *Access_modifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPRIVATE, 0)
}

func (s *Access_modifierContext) VIEW() antlr.TerminalNode {
	return s.GetToken(KuneiformParserVIEW, 0)
}

func (s *Access_modifierContext) OWNER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserOWNER, 0)
}

func (s *Access_modifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Access_modifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Access_modifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitAccess_modifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Access_modifier() (localctx IAccess_modifierContext) {
	localctx = NewAccess_modifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, KuneiformParserRULE_access_modifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(372)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2061584302080) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAction_declarationContext is an interface to support dynamic dispatch.
type IAction_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACTION() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	Action_block() IAction_blockContext
	RBRACE() antlr.TerminalNode
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	Variable_list() IVariable_listContext
	AllAccess_modifier() []IAccess_modifierContext
	Access_modifier(i int) IAccess_modifierContext

	// IsAction_declarationContext differentiates from other interfaces.
	IsAction_declarationContext()
}

type Action_declarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAction_declarationContext() *Action_declarationContext {
	var p = new(Action_declarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_action_declaration
	return p
}

func InitEmptyAction_declarationContext(p *Action_declarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_action_declaration
}

func (*Action_declarationContext) IsAction_declarationContext() {}

func NewAction_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Action_declarationContext {
	var p = new(Action_declarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_action_declaration

	return p
}

func (s *Action_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Action_declarationContext) ACTION() antlr.TerminalNode {
	return s.GetToken(KuneiformParserACTION, 0)
}

func (s *Action_declarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *Action_declarationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Action_declarationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Action_declarationContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACE, 0)
}

func (s *Action_declarationContext) Action_block() IAction_blockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_blockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_blockContext)
}

func (s *Action_declarationContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACE, 0)
}

func (s *Action_declarationContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *Action_declarationContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *Action_declarationContext) Variable_list() IVariable_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariable_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariable_listContext)
}

func (s *Action_declarationContext) AllAccess_modifier() []IAccess_modifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAccess_modifierContext); ok {
			len++
		}
	}

	tst := make([]IAccess_modifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAccess_modifierContext); ok {
			tst[i] = t.(IAccess_modifierContext)
			i++
		}
	}

	return tst
}

func (s *Action_declarationContext) Access_modifier(i int) IAccess_modifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccess_modifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccess_modifierContext)
}

func (s *Action_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Action_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Action_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitAction_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Action_declaration() (localctx IAction_declarationContext) {
	localctx = NewAction_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, KuneiformParserRULE_action_declaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(377)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCONTEXTUAL_VARIABLE {
		{
			p.SetState(374)
			p.Annotation()
		}

		p.SetState(379)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(380)
		p.Match(KuneiformParserACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(381)
		p.Match(KuneiformParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(382)
		p.Match(KuneiformParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserVARIABLE || _la == KuneiformParserCONTEXTUAL_VARIABLE {
		{
			p.SetState(383)
			p.Variable_list()
		}

	}
	{
		p.SetState(386)
		p.Match(KuneiformParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(388)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2061584302080) != 0) {
		{
			p.SetState(387)
			p.Access_modifier()
		}

		p.SetState(390)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(392)
		p.Match(KuneiformParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(393)
		p.Action_block()
	}
	{
		p.SetState(394)
		p.Match(KuneiformParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedure_declarationContext is an interface to support dynamic dispatch.
type IProcedure_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCEDURE() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	Procedure_block() IProcedure_blockContext
	RBRACE() antlr.TerminalNode
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	Typed_variable_list() ITyped_variable_listContext
	AllAccess_modifier() []IAccess_modifierContext
	Access_modifier(i int) IAccess_modifierContext
	Procedure_return() IProcedure_returnContext

	// IsProcedure_declarationContext differentiates from other interfaces.
	IsProcedure_declarationContext()
}

type Procedure_declarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedure_declarationContext() *Procedure_declarationContext {
	var p = new(Procedure_declarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_procedure_declaration
	return p
}

func InitEmptyProcedure_declarationContext(p *Procedure_declarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_procedure_declaration
}

func (*Procedure_declarationContext) IsProcedure_declarationContext() {}

func NewProcedure_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedure_declarationContext {
	var p = new(Procedure_declarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_procedure_declaration

	return p
}

func (s *Procedure_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedure_declarationContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPROCEDURE, 0)
}

func (s *Procedure_declarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *Procedure_declarationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Procedure_declarationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Procedure_declarationContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACE, 0)
}

func (s *Procedure_declarationContext) Procedure_block() IProcedure_blockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_blockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_blockContext)
}

func (s *Procedure_declarationContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACE, 0)
}

func (s *Procedure_declarationContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *Procedure_declarationContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *Procedure_declarationContext) Typed_variable_list() ITyped_variable_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITyped_variable_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITyped_variable_listContext)
}

func (s *Procedure_declarationContext) AllAccess_modifier() []IAccess_modifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAccess_modifierContext); ok {
			len++
		}
	}

	tst := make([]IAccess_modifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAccess_modifierContext); ok {
			tst[i] = t.(IAccess_modifierContext)
			i++
		}
	}

	return tst
}

func (s *Procedure_declarationContext) Access_modifier(i int) IAccess_modifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccess_modifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccess_modifierContext)
}

func (s *Procedure_declarationContext) Procedure_return() IProcedure_returnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_returnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_returnContext)
}

func (s *Procedure_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedure_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedure_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitProcedure_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Procedure_declaration() (localctx IProcedure_declarationContext) {
	localctx = NewProcedure_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, KuneiformParserRULE_procedure_declaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCONTEXTUAL_VARIABLE {
		{
			p.SetState(396)
			p.Annotation()
		}

		p.SetState(401)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(402)
		p.Match(KuneiformParserPROCEDURE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(403)
		p.Match(KuneiformParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(404)
		p.Match(KuneiformParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(406)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserVARIABLE || _la == KuneiformParserCONTEXTUAL_VARIABLE {
		{
			p.SetState(405)
			p.Typed_variable_list()
		}

	}
	{
		p.SetState(408)
		p.Match(KuneiformParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(410)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2061584302080) != 0) {
		{
			p.SetState(409)
			p.Access_modifier()
		}

		p.SetState(412)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(415)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserRETURNS {
		{
			p.SetState(414)
			p.Procedure_return()
		}

	}
	{
		p.SetState(417)
		p.Match(KuneiformParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(418)
		p.Procedure_block()
	}
	{
		p.SetState(419)
		p.Match(KuneiformParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForeign_procedure_declarationContext is an interface to support dynamic dispatch.
type IForeign_procedure_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnnamed_params returns the unnamed_params rule contexts.
	GetUnnamed_params() IType_listContext

	// GetNamed_params returns the named_params rule contexts.
	GetNamed_params() ITyped_variable_listContext

	// SetUnnamed_params sets the unnamed_params rule contexts.
	SetUnnamed_params(IType_listContext)

	// SetNamed_params sets the named_params rule contexts.
	SetNamed_params(ITyped_variable_listContext)

	// Getter signatures
	FOREIGN() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Procedure_return() IProcedure_returnContext
	Type_list() IType_listContext
	Typed_variable_list() ITyped_variable_listContext

	// IsForeign_procedure_declarationContext differentiates from other interfaces.
	IsForeign_procedure_declarationContext()
}

type Foreign_procedure_declarationContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	unnamed_params IType_listContext
	named_params   ITyped_variable_listContext
}

func NewEmptyForeign_procedure_declarationContext() *Foreign_procedure_declarationContext {
	var p = new(Foreign_procedure_declarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_foreign_procedure_declaration
	return p
}

func InitEmptyForeign_procedure_declarationContext(p *Foreign_procedure_declarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_foreign_procedure_declaration
}

func (*Foreign_procedure_declarationContext) IsForeign_procedure_declarationContext() {}

func NewForeign_procedure_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Foreign_procedure_declarationContext {
	var p = new(Foreign_procedure_declarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_foreign_procedure_declaration

	return p
}

func (s *Foreign_procedure_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Foreign_procedure_declarationContext) GetUnnamed_params() IType_listContext {
	return s.unnamed_params
}

func (s *Foreign_procedure_declarationContext) GetNamed_params() ITyped_variable_listContext {
	return s.named_params
}

func (s *Foreign_procedure_declarationContext) SetUnnamed_params(v IType_listContext) {
	s.unnamed_params = v
}

func (s *Foreign_procedure_declarationContext) SetNamed_params(v ITyped_variable_listContext) {
	s.named_params = v
}

func (s *Foreign_procedure_declarationContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFOREIGN, 0)
}

func (s *Foreign_procedure_declarationContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPROCEDURE, 0)
}

func (s *Foreign_procedure_declarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *Foreign_procedure_declarationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Foreign_procedure_declarationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Foreign_procedure_declarationContext) Procedure_return() IProcedure_returnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_returnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_returnContext)
}

func (s *Foreign_procedure_declarationContext) Type_list() IType_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_listContext)
}

func (s *Foreign_procedure_declarationContext) Typed_variable_list() ITyped_variable_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITyped_variable_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITyped_variable_listContext)
}

func (s *Foreign_procedure_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Foreign_procedure_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Foreign_procedure_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitForeign_procedure_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Foreign_procedure_declaration() (localctx IForeign_procedure_declarationContext) {
	localctx = NewForeign_procedure_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, KuneiformParserRULE_foreign_procedure_declaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(421)
		p.Match(KuneiformParserFOREIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(422)
		p.Match(KuneiformParserPROCEDURE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(423)
		p.Match(KuneiformParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(424)
		p.Match(KuneiformParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(427)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case KuneiformParserIDENTIFIER:
		{
			p.SetState(425)

			var _x = p.Type_list()

			localctx.(*Foreign_procedure_declarationContext).unnamed_params = _x
		}

	case KuneiformParserVARIABLE, KuneiformParserCONTEXTUAL_VARIABLE:
		{
			p.SetState(426)

			var _x = p.Typed_variable_list()

			localctx.(*Foreign_procedure_declarationContext).named_params = _x
		}

	case KuneiformParserRPAREN:

	default:
	}
	{
		p.SetState(429)
		p.Match(KuneiformParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserRETURNS {
		{
			p.SetState(430)
			p.Procedure_return()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedure_returnContext is an interface to support dynamic dispatch.
type IProcedure_returnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetReturn_columns returns the return_columns rule contexts.
	GetReturn_columns() INamed_type_listContext

	// GetUnnamed_return_types returns the unnamed_return_types rule contexts.
	GetUnnamed_return_types() IType_listContext

	// SetReturn_columns sets the return_columns rule contexts.
	SetReturn_columns(INamed_type_listContext)

	// SetUnnamed_return_types sets the unnamed_return_types rule contexts.
	SetUnnamed_return_types(IType_listContext)

	// Getter signatures
	RETURNS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Named_type_list() INamed_type_listContext
	Type_list() IType_listContext
	TABLE() antlr.TerminalNode

	// IsProcedure_returnContext differentiates from other interfaces.
	IsProcedure_returnContext()
}

type Procedure_returnContext struct {
	antlr.BaseParserRuleContext
	parser               antlr.Parser
	return_columns       INamed_type_listContext
	unnamed_return_types IType_listContext
}

func NewEmptyProcedure_returnContext() *Procedure_returnContext {
	var p = new(Procedure_returnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_procedure_return
	return p
}

func InitEmptyProcedure_returnContext(p *Procedure_returnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_procedure_return
}

func (*Procedure_returnContext) IsProcedure_returnContext() {}

func NewProcedure_returnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedure_returnContext {
	var p = new(Procedure_returnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_procedure_return

	return p
}

func (s *Procedure_returnContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedure_returnContext) GetReturn_columns() INamed_type_listContext {
	return s.return_columns
}

func (s *Procedure_returnContext) GetUnnamed_return_types() IType_listContext {
	return s.unnamed_return_types
}

func (s *Procedure_returnContext) SetReturn_columns(v INamed_type_listContext) { s.return_columns = v }

func (s *Procedure_returnContext) SetUnnamed_return_types(v IType_listContext) {
	s.unnamed_return_types = v
}

func (s *Procedure_returnContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRETURNS, 0)
}

func (s *Procedure_returnContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Procedure_returnContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Procedure_returnContext) Named_type_list() INamed_type_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_type_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_type_listContext)
}

func (s *Procedure_returnContext) Type_list() IType_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_listContext)
}

func (s *Procedure_returnContext) TABLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserTABLE, 0)
}

func (s *Procedure_returnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedure_returnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedure_returnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitProcedure_return(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Procedure_return() (localctx IProcedure_returnContext) {
	localctx = NewProcedure_returnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, KuneiformParserRULE_procedure_return)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(433)
		p.Match(KuneiformParserRETURNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(445)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		p.SetState(435)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserTABLE {
			{
				p.SetState(434)
				p.Match(KuneiformParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(437)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(438)

			var _x = p.Named_type_list()

			localctx.(*Procedure_returnContext).return_columns = _x
		}
		{
			p.SetState(439)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(441)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(442)

			var _x = p.Type_list()

			localctx.(*Procedure_returnContext).unnamed_return_types = _x
		}
		{
			p.SetState(443)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISqlContext is an interface to support dynamic dispatch.
type ISqlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Sql_statement() ISql_statementContext
	SCOL() antlr.TerminalNode

	// IsSqlContext differentiates from other interfaces.
	IsSqlContext()
}

type SqlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlContext() *SqlContext {
	var p = new(SqlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_sql
	return p
}

func InitEmptySqlContext(p *SqlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_sql
}

func (*SqlContext) IsSqlContext() {}

func NewSqlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlContext {
	var p = new(SqlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_sql

	return p
}

func (s *SqlContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlContext) Sql_statement() ISql_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_statementContext)
}

func (s *SqlContext) SCOL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, 0)
}

func (s *SqlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitSql(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Sql() (localctx ISqlContext) {
	localctx = NewSqlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, KuneiformParserRULE_sql)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(447)
		p.Sql_statement()
	}
	{
		p.SetState(448)
		p.Match(KuneiformParserSCOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISql_statementContext is an interface to support dynamic dispatch.
type ISql_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_statement() ISelect_statementContext
	Update_statement() IUpdate_statementContext
	Insert_statement() IInsert_statementContext
	Delete_statement() IDelete_statementContext
	WITH() antlr.TerminalNode
	AllCommon_table_expression() []ICommon_table_expressionContext
	Common_table_expression(i int) ICommon_table_expressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSql_statementContext differentiates from other interfaces.
	IsSql_statementContext()
}

type Sql_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_statementContext() *Sql_statementContext {
	var p = new(Sql_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_sql_statement
	return p
}

func InitEmptySql_statementContext(p *Sql_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_sql_statement
}

func (*Sql_statementContext) IsSql_statementContext() {}

func NewSql_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_statementContext {
	var p = new(Sql_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_sql_statement

	return p
}

func (s *Sql_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_statementContext) Select_statement() ISelect_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *Sql_statementContext) Update_statement() IUpdate_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_statementContext)
}

func (s *Sql_statementContext) Insert_statement() IInsert_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_statementContext)
}

func (s *Sql_statementContext) Delete_statement() IDelete_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelete_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelete_statementContext)
}

func (s *Sql_statementContext) WITH() antlr.TerminalNode {
	return s.GetToken(KuneiformParserWITH, 0)
}

func (s *Sql_statementContext) AllCommon_table_expression() []ICommon_table_expressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommon_table_expressionContext); ok {
			len++
		}
	}

	tst := make([]ICommon_table_expressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommon_table_expressionContext); ok {
			tst[i] = t.(ICommon_table_expressionContext)
			i++
		}
	}

	return tst
}

func (s *Sql_statementContext) Common_table_expression(i int) ICommon_table_expressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommon_table_expressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommon_table_expressionContext)
}

func (s *Sql_statementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Sql_statementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Sql_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sql_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitSql_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Sql_statement() (localctx ISql_statementContext) {
	localctx = NewSql_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, KuneiformParserRULE_sql_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(459)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserWITH {
		{
			p.SetState(450)
			p.Match(KuneiformParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(451)
			p.Common_table_expression()
		}
		p.SetState(456)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KuneiformParserCOMMA {
			{
				p.SetState(452)
				p.Match(KuneiformParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(453)
				p.Common_table_expression()
			}

			p.SetState(458)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KuneiformParserSELECT:
		{
			p.SetState(461)
			p.Select_statement()
		}

	case KuneiformParserUPDATE:
		{
			p.SetState(462)
			p.Update_statement()
		}

	case KuneiformParserINSERT:
		{
			p.SetState(463)
			p.Insert_statement()
		}

	case KuneiformParserDELETE:
		{
			p.SetState(464)
			p.Delete_statement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommon_table_expressionContext is an interface to support dynamic dispatch.
type ICommon_table_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	AS() antlr.TerminalNode
	Select_statement() ISelect_statementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCommon_table_expressionContext differentiates from other interfaces.
	IsCommon_table_expressionContext()
}

type Common_table_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommon_table_expressionContext() *Common_table_expressionContext {
	var p = new(Common_table_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_common_table_expression
	return p
}

func InitEmptyCommon_table_expressionContext(p *Common_table_expressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_common_table_expression
}

func (*Common_table_expressionContext) IsCommon_table_expressionContext() {}

func NewCommon_table_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Common_table_expressionContext {
	var p = new(Common_table_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_common_table_expression

	return p
}

func (s *Common_table_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Common_table_expressionContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserIDENTIFIER)
}

func (s *Common_table_expressionContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, i)
}

func (s *Common_table_expressionContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserLPAREN)
}

func (s *Common_table_expressionContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, i)
}

func (s *Common_table_expressionContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserRPAREN)
}

func (s *Common_table_expressionContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, i)
}

func (s *Common_table_expressionContext) AS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAS, 0)
}

func (s *Common_table_expressionContext) Select_statement() ISelect_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *Common_table_expressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Common_table_expressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Common_table_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Common_table_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Common_table_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitCommon_table_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Common_table_expression() (localctx ICommon_table_expressionContext) {
	localctx = NewCommon_table_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, KuneiformParserRULE_common_table_expression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(467)
		p.Match(KuneiformParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(468)
		p.Match(KuneiformParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(477)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserIDENTIFIER {
		{
			p.SetState(469)
			p.Match(KuneiformParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(474)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KuneiformParserCOMMA {
			{
				p.SetState(470)
				p.Match(KuneiformParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(471)
				p.Match(KuneiformParserIDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(476)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(479)
		p.Match(KuneiformParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(480)
		p.Match(KuneiformParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(481)
		p.Match(KuneiformParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(482)
		p.Select_statement()
	}
	{
		p.SetState(483)
		p.Match(KuneiformParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_statementContext is an interface to support dynamic dispatch.
type ISelect_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit rule contexts.
	GetLimit() ISql_exprContext

	// GetOffset returns the offset rule contexts.
	GetOffset() ISql_exprContext

	// SetLimit sets the limit rule contexts.
	SetLimit(ISql_exprContext)

	// SetOffset sets the offset rule contexts.
	SetOffset(ISql_exprContext)

	// Getter signatures
	AllSelect_core() []ISelect_coreContext
	Select_core(i int) ISelect_coreContext
	AllCompound_operator() []ICompound_operatorContext
	Compound_operator(i int) ICompound_operatorContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllOrdering_term() []IOrdering_termContext
	Ordering_term(i int) IOrdering_termContext
	LIMIT() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	AllSql_expr() []ISql_exprContext
	Sql_expr(i int) ISql_exprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSelect_statementContext differentiates from other interfaces.
	IsSelect_statementContext()
}

type Select_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  ISql_exprContext
	offset ISql_exprContext
}

func NewEmptySelect_statementContext() *Select_statementContext {
	var p = new(Select_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_select_statement
	return p
}

func InitEmptySelect_statementContext(p *Select_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_select_statement
}

func (*Select_statementContext) IsSelect_statementContext() {}

func NewSelect_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_statementContext {
	var p = new(Select_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_select_statement

	return p
}

func (s *Select_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_statementContext) GetLimit() ISql_exprContext { return s.limit }

func (s *Select_statementContext) GetOffset() ISql_exprContext { return s.offset }

func (s *Select_statementContext) SetLimit(v ISql_exprContext) { s.limit = v }

func (s *Select_statementContext) SetOffset(v ISql_exprContext) { s.offset = v }

func (s *Select_statementContext) AllSelect_core() []ISelect_coreContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelect_coreContext); ok {
			len++
		}
	}

	tst := make([]ISelect_coreContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelect_coreContext); ok {
			tst[i] = t.(ISelect_coreContext)
			i++
		}
	}

	return tst
}

func (s *Select_statementContext) Select_core(i int) ISelect_coreContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_coreContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_coreContext)
}

func (s *Select_statementContext) AllCompound_operator() []ICompound_operatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICompound_operatorContext); ok {
			len++
		}
	}

	tst := make([]ICompound_operatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICompound_operatorContext); ok {
			tst[i] = t.(ICompound_operatorContext)
			i++
		}
	}

	return tst
}

func (s *Select_statementContext) Compound_operator(i int) ICompound_operatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompound_operatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompound_operatorContext)
}

func (s *Select_statementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserORDER, 0)
}

func (s *Select_statementContext) BY() antlr.TerminalNode {
	return s.GetToken(KuneiformParserBY, 0)
}

func (s *Select_statementContext) AllOrdering_term() []IOrdering_termContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrdering_termContext); ok {
			len++
		}
	}

	tst := make([]IOrdering_termContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrdering_termContext); ok {
			tst[i] = t.(IOrdering_termContext)
			i++
		}
	}

	return tst
}

func (s *Select_statementContext) Ordering_term(i int) IOrdering_termContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrdering_termContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrdering_termContext)
}

func (s *Select_statementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLIMIT, 0)
}

func (s *Select_statementContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserOFFSET, 0)
}

func (s *Select_statementContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Select_statementContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Select_statementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Select_statementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Select_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitSelect_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Select_statement() (localctx ISelect_statementContext) {
	localctx = NewSelect_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, KuneiformParserRULE_select_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(485)
		p.Select_core()
	}
	p.SetState(491)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-100)) & ^0x3f) == 0 && ((int64(1)<<(_la-100))&7) != 0 {
		{
			p.SetState(486)
			p.Compound_operator()
		}
		{
			p.SetState(487)
			p.Select_core()
		}

		p.SetState(493)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(504)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserORDER {
		{
			p.SetState(494)
			p.Match(KuneiformParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(495)
			p.Match(KuneiformParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(496)
			p.Ordering_term()
		}
		p.SetState(501)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KuneiformParserCOMMA {
			{
				p.SetState(497)
				p.Match(KuneiformParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(498)
				p.Ordering_term()
			}

			p.SetState(503)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(508)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserLIMIT {
		{
			p.SetState(506)
			p.Match(KuneiformParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(507)

			var _x = p.sql_expr(0)

			localctx.(*Select_statementContext).limit = _x
		}

	}
	p.SetState(512)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserOFFSET {
		{
			p.SetState(510)
			p.Match(KuneiformParserOFFSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(511)

			var _x = p.sql_expr(0)

			localctx.(*Select_statementContext).offset = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompound_operatorContext is an interface to support dynamic dispatch.
type ICompound_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNION() antlr.TerminalNode
	ALL() antlr.TerminalNode
	INTERSECT() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode

	// IsCompound_operatorContext differentiates from other interfaces.
	IsCompound_operatorContext()
}

type Compound_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompound_operatorContext() *Compound_operatorContext {
	var p = new(Compound_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_compound_operator
	return p
}

func InitEmptyCompound_operatorContext(p *Compound_operatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_compound_operator
}

func (*Compound_operatorContext) IsCompound_operatorContext() {}

func NewCompound_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compound_operatorContext {
	var p = new(Compound_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_compound_operator

	return p
}

func (s *Compound_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Compound_operatorContext) UNION() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUNION, 0)
}

func (s *Compound_operatorContext) ALL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserALL, 0)
}

func (s *Compound_operatorContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserINTERSECT, 0)
}

func (s *Compound_operatorContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEXCEPT, 0)
}

func (s *Compound_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compound_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Compound_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitCompound_operator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Compound_operator() (localctx ICompound_operatorContext) {
	localctx = NewCompound_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, KuneiformParserRULE_compound_operator)
	var _la int

	p.SetState(520)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KuneiformParserUNION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(514)
			p.Match(KuneiformParserUNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(516)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserALL {
			{
				p.SetState(515)
				p.Match(KuneiformParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case KuneiformParserINTERSECT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(518)
			p.Match(KuneiformParserINTERSECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KuneiformParserEXCEPT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(519)
			p.Match(KuneiformParserEXCEPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrdering_termContext is an interface to support dynamic dispatch.
type IOrdering_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Sql_expr() ISql_exprContext
	NULLS() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode

	// IsOrdering_termContext differentiates from other interfaces.
	IsOrdering_termContext()
}

type Ordering_termContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrdering_termContext() *Ordering_termContext {
	var p = new(Ordering_termContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_ordering_term
	return p
}

func InitEmptyOrdering_termContext(p *Ordering_termContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_ordering_term
}

func (*Ordering_termContext) IsOrdering_termContext() {}

func NewOrdering_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ordering_termContext {
	var p = new(Ordering_termContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_ordering_term

	return p
}

func (s *Ordering_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Ordering_termContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Ordering_termContext) NULLS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNULLS, 0)
}

func (s *Ordering_termContext) ASC() antlr.TerminalNode {
	return s.GetToken(KuneiformParserASC, 0)
}

func (s *Ordering_termContext) DESC() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDESC, 0)
}

func (s *Ordering_termContext) FIRST() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFIRST, 0)
}

func (s *Ordering_termContext) LAST() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLAST, 0)
}

func (s *Ordering_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ordering_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ordering_termContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitOrdering_term(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Ordering_term() (localctx IOrdering_termContext) {
	localctx = NewOrdering_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, KuneiformParserRULE_ordering_term)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(522)
		p.sql_expr(0)
	}
	p.SetState(524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserASC || _la == KuneiformParserDESC {
		{
			p.SetState(523)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KuneiformParserASC || _la == KuneiformParserDESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(528)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserNULLS {
		{
			p.SetState(526)
			p.Match(KuneiformParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(527)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KuneiformParserFIRST || _la == KuneiformParserLAST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_coreContext is an interface to support dynamic dispatch.
type ISelect_coreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() ISql_exprContext

	// GetGroup_by returns the group_by rule contexts.
	GetGroup_by() ISql_expr_listContext

	// GetHaving returns the having rule contexts.
	GetHaving() ISql_exprContext

	// SetWhere sets the where rule contexts.
	SetWhere(ISql_exprContext)

	// SetGroup_by sets the group_by rule contexts.
	SetGroup_by(ISql_expr_listContext)

	// SetHaving sets the having rule contexts.
	SetHaving(ISql_exprContext)

	// Getter signatures
	SELECT() antlr.TerminalNode
	AllResult_column() []IResult_columnContext
	Result_column(i int) IResult_columnContext
	DISTINCT() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	FROM() antlr.TerminalNode
	Relation() IRelationContext
	WHERE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSql_expr() []ISql_exprContext
	Sql_expr(i int) ISql_exprContext
	Sql_expr_list() ISql_expr_listContext
	AllJoin() []IJoinContext
	Join(i int) IJoinContext
	HAVING() antlr.TerminalNode

	// IsSelect_coreContext differentiates from other interfaces.
	IsSelect_coreContext()
}

type Select_coreContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	where    ISql_exprContext
	group_by ISql_expr_listContext
	having   ISql_exprContext
}

func NewEmptySelect_coreContext() *Select_coreContext {
	var p = new(Select_coreContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_select_core
	return p
}

func InitEmptySelect_coreContext(p *Select_coreContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_select_core
}

func (*Select_coreContext) IsSelect_coreContext() {}

func NewSelect_coreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_coreContext {
	var p = new(Select_coreContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_select_core

	return p
}

func (s *Select_coreContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_coreContext) GetWhere() ISql_exprContext { return s.where }

func (s *Select_coreContext) GetGroup_by() ISql_expr_listContext { return s.group_by }

func (s *Select_coreContext) GetHaving() ISql_exprContext { return s.having }

func (s *Select_coreContext) SetWhere(v ISql_exprContext) { s.where = v }

func (s *Select_coreContext) SetGroup_by(v ISql_expr_listContext) { s.group_by = v }

func (s *Select_coreContext) SetHaving(v ISql_exprContext) { s.having = v }

func (s *Select_coreContext) SELECT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSELECT, 0)
}

func (s *Select_coreContext) AllResult_column() []IResult_columnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResult_columnContext); ok {
			len++
		}
	}

	tst := make([]IResult_columnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResult_columnContext); ok {
			tst[i] = t.(IResult_columnContext)
			i++
		}
	}

	return tst
}

func (s *Select_coreContext) Result_column(i int) IResult_columnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResult_columnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResult_columnContext)
}

func (s *Select_coreContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDISTINCT, 0)
}

func (s *Select_coreContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Select_coreContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Select_coreContext) FROM() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFROM, 0)
}

func (s *Select_coreContext) Relation() IRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *Select_coreContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserWHERE, 0)
}

func (s *Select_coreContext) GROUP() antlr.TerminalNode {
	return s.GetToken(KuneiformParserGROUP, 0)
}

func (s *Select_coreContext) BY() antlr.TerminalNode {
	return s.GetToken(KuneiformParserBY, 0)
}

func (s *Select_coreContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Select_coreContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Select_coreContext) Sql_expr_list() ISql_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_expr_listContext)
}

func (s *Select_coreContext) AllJoin() []IJoinContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinContext); ok {
			len++
		}
	}

	tst := make([]IJoinContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinContext); ok {
			tst[i] = t.(IJoinContext)
			i++
		}
	}

	return tst
}

func (s *Select_coreContext) Join(i int) IJoinContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinContext)
}

func (s *Select_coreContext) HAVING() antlr.TerminalNode {
	return s.GetToken(KuneiformParserHAVING, 0)
}

func (s *Select_coreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_coreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_coreContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitSelect_core(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Select_core() (localctx ISelect_coreContext) {
	localctx = NewSelect_coreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, KuneiformParserRULE_select_core)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(530)
		p.Match(KuneiformParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(532)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserDISTINCT {
		{
			p.SetState(531)
			p.Match(KuneiformParserDISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(534)
		p.Result_column()
	}
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCOMMA {
		{
			p.SetState(535)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(536)
			p.Result_column()
		}

		p.SetState(541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(550)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserFROM {
		{
			p.SetState(542)
			p.Match(KuneiformParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(543)
			p.Relation()
		}
		p.SetState(547)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&134217735) != 0 {
			{
				p.SetState(544)
				p.Join()
			}

			p.SetState(549)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(554)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserWHERE {
		{
			p.SetState(552)
			p.Match(KuneiformParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(553)

			var _x = p.sql_expr(0)

			localctx.(*Select_coreContext).where = _x
		}

	}
	p.SetState(563)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserGROUP {
		{
			p.SetState(556)
			p.Match(KuneiformParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(557)
			p.Match(KuneiformParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(558)

			var _x = p.Sql_expr_list()

			localctx.(*Select_coreContext).group_by = _x
		}
		p.SetState(561)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserHAVING {
			{
				p.SetState(559)
				p.Match(KuneiformParserHAVING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(560)

				var _x = p.sql_expr(0)

				localctx.(*Select_coreContext).having = _x
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_relation
	return p
}

func InitEmptyRelationContext(p *RelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_relation
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) CopyAll(ctx *RelationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Function_relationContext struct {
	RelationContext
	alias antlr.Token
}

func NewFunction_relationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Function_relationContext {
	var p = new(Function_relationContext)

	InitEmptyRelationContext(&p.RelationContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationContext))

	return p
}

func (s *Function_relationContext) GetAlias() antlr.Token { return s.alias }

func (s *Function_relationContext) SetAlias(v antlr.Token) { s.alias = v }

func (s *Function_relationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_relationContext) Sql_function_call() ISql_function_callContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_function_callContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_function_callContext)
}

func (s *Function_relationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *Function_relationContext) AS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAS, 0)
}

func (s *Function_relationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitFunction_relation(s)

	default:
		return t.VisitChildren(s)
	}
}

type Table_relationContext struct {
	RelationContext
	table_name antlr.Token
	alias      antlr.Token
}

func NewTable_relationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Table_relationContext {
	var p = new(Table_relationContext)

	InitEmptyRelationContext(&p.RelationContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationContext))

	return p
}

func (s *Table_relationContext) GetTable_name() antlr.Token { return s.table_name }

func (s *Table_relationContext) GetAlias() antlr.Token { return s.alias }

func (s *Table_relationContext) SetTable_name(v antlr.Token) { s.table_name = v }

func (s *Table_relationContext) SetAlias(v antlr.Token) { s.alias = v }

func (s *Table_relationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_relationContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserIDENTIFIER)
}

func (s *Table_relationContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, i)
}

func (s *Table_relationContext) AS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAS, 0)
}

func (s *Table_relationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitTable_relation(s)

	default:
		return t.VisitChildren(s)
	}
}

type Subquery_relationContext struct {
	RelationContext
	alias antlr.Token
}

func NewSubquery_relationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Subquery_relationContext {
	var p = new(Subquery_relationContext)

	InitEmptyRelationContext(&p.RelationContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationContext))

	return p
}

func (s *Subquery_relationContext) GetAlias() antlr.Token { return s.alias }

func (s *Subquery_relationContext) SetAlias(v antlr.Token) { s.alias = v }

func (s *Subquery_relationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subquery_relationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Subquery_relationContext) Select_statement() ISelect_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *Subquery_relationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Subquery_relationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *Subquery_relationContext) AS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAS, 0)
}

func (s *Subquery_relationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitSubquery_relation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Relation() (localctx IRelationContext) {
	localctx = NewRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, KuneiformParserRULE_relation)
	var _la int

	p.SetState(586)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTable_relationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(565)

			var _m = p.Match(KuneiformParserIDENTIFIER)

			localctx.(*Table_relationContext).table_name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(570)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserAS || _la == KuneiformParserIDENTIFIER {
			p.SetState(567)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == KuneiformParserAS {
				{
					p.SetState(566)
					p.Match(KuneiformParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(569)

				var _m = p.Match(KuneiformParserIDENTIFIER)

				localctx.(*Table_relationContext).alias = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		localctx = NewSubquery_relationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(572)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(573)
			p.Select_statement()
		}
		{
			p.SetState(574)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(576)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserAS {
			{
				p.SetState(575)
				p.Match(KuneiformParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(578)

			var _m = p.Match(KuneiformParserIDENTIFIER)

			localctx.(*Subquery_relationContext).alias = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewFunction_relationContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(580)
			p.Sql_function_call()
		}
		p.SetState(582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserAS {
			{
				p.SetState(581)
				p.Match(KuneiformParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(584)

			var _m = p.Match(KuneiformParserIDENTIFIER)

			localctx.(*Function_relationContext).alias = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinContext is an interface to support dynamic dispatch.
type IJoinContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JOIN() antlr.TerminalNode
	Relation() IRelationContext
	ON() antlr.TerminalNode
	Sql_expr() ISql_exprContext
	INNER() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	FULL() antlr.TerminalNode

	// IsJoinContext differentiates from other interfaces.
	IsJoinContext()
}

type JoinContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinContext() *JoinContext {
	var p = new(JoinContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_join
	return p
}

func InitEmptyJoinContext(p *JoinContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_join
}

func (*JoinContext) IsJoinContext() {}

func NewJoinContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinContext {
	var p = new(JoinContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_join

	return p
}

func (s *JoinContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinContext) JOIN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserJOIN, 0)
}

func (s *JoinContext) Relation() IRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *JoinContext) ON() antlr.TerminalNode {
	return s.GetToken(KuneiformParserON, 0)
}

func (s *JoinContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *JoinContext) INNER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserINNER, 0)
}

func (s *JoinContext) LEFT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLEFT, 0)
}

func (s *JoinContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRIGHT, 0)
}

func (s *JoinContext) FULL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFULL, 0)
}

func (s *JoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitJoin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Join() (localctx IJoinContext) {
	localctx = NewJoinContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, KuneiformParserRULE_join)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(588)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&134217735) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(589)
		p.Match(KuneiformParserJOIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(590)
		p.Relation()
	}
	{
		p.SetState(591)
		p.Match(KuneiformParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(592)
		p.sql_expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResult_columnContext is an interface to support dynamic dispatch.
type IResult_columnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsResult_columnContext differentiates from other interfaces.
	IsResult_columnContext()
}

type Result_columnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResult_columnContext() *Result_columnContext {
	var p = new(Result_columnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_result_column
	return p
}

func InitEmptyResult_columnContext(p *Result_columnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_result_column
}

func (*Result_columnContext) IsResult_columnContext() {}

func NewResult_columnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Result_columnContext {
	var p = new(Result_columnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_result_column

	return p
}

func (s *Result_columnContext) GetParser() antlr.Parser { return s.parser }

func (s *Result_columnContext) CopyAll(ctx *Result_columnContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *Result_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Result_columnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Expression_result_columnContext struct {
	Result_columnContext
}

func NewExpression_result_columnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Expression_result_columnContext {
	var p = new(Expression_result_columnContext)

	InitEmptyResult_columnContext(&p.Result_columnContext)
	p.parser = parser
	p.CopyAll(ctx.(*Result_columnContext))

	return p
}

func (s *Expression_result_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_result_columnContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Expression_result_columnContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *Expression_result_columnContext) AS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAS, 0)
}

func (s *Expression_result_columnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitExpression_result_column(s)

	default:
		return t.VisitChildren(s)
	}
}

type Wildcard_result_columnContext struct {
	Result_columnContext
	table_name antlr.Token
}

func NewWildcard_result_columnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Wildcard_result_columnContext {
	var p = new(Wildcard_result_columnContext)

	InitEmptyResult_columnContext(&p.Result_columnContext)
	p.parser = parser
	p.CopyAll(ctx.(*Result_columnContext))

	return p
}

func (s *Wildcard_result_columnContext) GetTable_name() antlr.Token { return s.table_name }

func (s *Wildcard_result_columnContext) SetTable_name(v antlr.Token) { s.table_name = v }

func (s *Wildcard_result_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Wildcard_result_columnContext) STAR() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSTAR, 0)
}

func (s *Wildcard_result_columnContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPERIOD, 0)
}

func (s *Wildcard_result_columnContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *Wildcard_result_columnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitWildcard_result_column(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Result_column() (localctx IResult_columnContext) {
	localctx = NewResult_columnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, KuneiformParserRULE_result_column)
	var _la int

	p.SetState(606)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		localctx = NewExpression_result_columnContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(594)
			p.sql_expr(0)
		}
		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserAS || _la == KuneiformParserIDENTIFIER {
			p.SetState(596)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == KuneiformParserAS {
				{
					p.SetState(595)
					p.Match(KuneiformParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(598)
				p.Match(KuneiformParserIDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		localctx = NewWildcard_result_columnContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(603)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserIDENTIFIER {
			{
				p.SetState(601)

				var _m = p.Match(KuneiformParserIDENTIFIER)

				localctx.(*Wildcard_result_columnContext).table_name = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(602)
				p.Match(KuneiformParserPERIOD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(605)
			p.Match(KuneiformParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdate_statementContext is an interface to support dynamic dispatch.
type IUpdate_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable_name returns the table_name token.
	GetTable_name() antlr.Token

	// GetAlias returns the alias token.
	GetAlias() antlr.Token

	// SetTable_name sets the table_name token.
	SetTable_name(antlr.Token)

	// SetAlias sets the alias token.
	SetAlias(antlr.Token)

	// GetWhere returns the where rule contexts.
	GetWhere() ISql_exprContext

	// SetWhere sets the where rule contexts.
	SetWhere(ISql_exprContext)

	// Getter signatures
	UPDATE() antlr.TerminalNode
	SET() antlr.TerminalNode
	AllUpdate_set_clause() []IUpdate_set_clauseContext
	Update_set_clause(i int) IUpdate_set_clauseContext
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	AS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	FROM() antlr.TerminalNode
	Relation() IRelationContext
	WHERE() antlr.TerminalNode
	Sql_expr() ISql_exprContext
	AllJoin() []IJoinContext
	Join(i int) IJoinContext

	// IsUpdate_statementContext differentiates from other interfaces.
	IsUpdate_statementContext()
}

type Update_statementContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	table_name antlr.Token
	alias      antlr.Token
	where      ISql_exprContext
}

func NewEmptyUpdate_statementContext() *Update_statementContext {
	var p = new(Update_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_update_statement
	return p
}

func InitEmptyUpdate_statementContext(p *Update_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_update_statement
}

func (*Update_statementContext) IsUpdate_statementContext() {}

func NewUpdate_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_statementContext {
	var p = new(Update_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_update_statement

	return p
}

func (s *Update_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_statementContext) GetTable_name() antlr.Token { return s.table_name }

func (s *Update_statementContext) GetAlias() antlr.Token { return s.alias }

func (s *Update_statementContext) SetTable_name(v antlr.Token) { s.table_name = v }

func (s *Update_statementContext) SetAlias(v antlr.Token) { s.alias = v }

func (s *Update_statementContext) GetWhere() ISql_exprContext { return s.where }

func (s *Update_statementContext) SetWhere(v ISql_exprContext) { s.where = v }

func (s *Update_statementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUPDATE, 0)
}

func (s *Update_statementContext) SET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSET, 0)
}

func (s *Update_statementContext) AllUpdate_set_clause() []IUpdate_set_clauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdate_set_clauseContext); ok {
			len++
		}
	}

	tst := make([]IUpdate_set_clauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdate_set_clauseContext); ok {
			tst[i] = t.(IUpdate_set_clauseContext)
			i++
		}
	}

	return tst
}

func (s *Update_statementContext) Update_set_clause(i int) IUpdate_set_clauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_set_clauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_set_clauseContext)
}

func (s *Update_statementContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserIDENTIFIER)
}

func (s *Update_statementContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, i)
}

func (s *Update_statementContext) AS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAS, 0)
}

func (s *Update_statementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Update_statementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Update_statementContext) FROM() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFROM, 0)
}

func (s *Update_statementContext) Relation() IRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *Update_statementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserWHERE, 0)
}

func (s *Update_statementContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Update_statementContext) AllJoin() []IJoinContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinContext); ok {
			len++
		}
	}

	tst := make([]IJoinContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinContext); ok {
			tst[i] = t.(IJoinContext)
			i++
		}
	}

	return tst
}

func (s *Update_statementContext) Join(i int) IJoinContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinContext)
}

func (s *Update_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitUpdate_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Update_statement() (localctx IUpdate_statementContext) {
	localctx = NewUpdate_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, KuneiformParserRULE_update_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(608)
		p.Match(KuneiformParserUPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(609)

		var _m = p.Match(KuneiformParserIDENTIFIER)

		localctx.(*Update_statementContext).table_name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserAS {
		{
			p.SetState(610)
			p.Match(KuneiformParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(611)

			var _m = p.Match(KuneiformParserIDENTIFIER)

			localctx.(*Update_statementContext).alias = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(614)
		p.Match(KuneiformParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(615)
		p.Update_set_clause()
	}
	p.SetState(620)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCOMMA {
		{
			p.SetState(616)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(617)
			p.Update_set_clause()
		}

		p.SetState(622)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(631)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserFROM {
		{
			p.SetState(623)
			p.Match(KuneiformParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(624)
			p.Relation()
		}
		p.SetState(628)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&134217735) != 0 {
			{
				p.SetState(625)
				p.Join()
			}

			p.SetState(630)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(635)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserWHERE {
		{
			p.SetState(633)
			p.Match(KuneiformParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(634)

			var _x = p.sql_expr(0)

			localctx.(*Update_statementContext).where = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdate_set_clauseContext is an interface to support dynamic dispatch.
type IUpdate_set_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetColumn returns the column token.
	GetColumn() antlr.Token

	// SetColumn sets the column token.
	SetColumn(antlr.Token)

	// Getter signatures
	EQUALS() antlr.TerminalNode
	Sql_expr() ISql_exprContext
	IDENTIFIER() antlr.TerminalNode

	// IsUpdate_set_clauseContext differentiates from other interfaces.
	IsUpdate_set_clauseContext()
}

type Update_set_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	column antlr.Token
}

func NewEmptyUpdate_set_clauseContext() *Update_set_clauseContext {
	var p = new(Update_set_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_update_set_clause
	return p
}

func InitEmptyUpdate_set_clauseContext(p *Update_set_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_update_set_clause
}

func (*Update_set_clauseContext) IsUpdate_set_clauseContext() {}

func NewUpdate_set_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_set_clauseContext {
	var p = new(Update_set_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_update_set_clause

	return p
}

func (s *Update_set_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_set_clauseContext) GetColumn() antlr.Token { return s.column }

func (s *Update_set_clauseContext) SetColumn(v antlr.Token) { s.column = v }

func (s *Update_set_clauseContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEQUALS, 0)
}

func (s *Update_set_clauseContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Update_set_clauseContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *Update_set_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_set_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_set_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitUpdate_set_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Update_set_clause() (localctx IUpdate_set_clauseContext) {
	localctx = NewUpdate_set_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, KuneiformParserRULE_update_set_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(637)

		var _m = p.Match(KuneiformParserIDENTIFIER)

		localctx.(*Update_set_clauseContext).column = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(638)
		p.Match(KuneiformParserEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(639)
		p.sql_expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsert_statementContext is an interface to support dynamic dispatch.
type IInsert_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable_name returns the table_name token.
	GetTable_name() antlr.Token

	// GetAlias returns the alias token.
	GetAlias() antlr.Token

	// SetTable_name sets the table_name token.
	SetTable_name(antlr.Token)

	// SetAlias sets the alias token.
	SetAlias(antlr.Token)

	// GetTarget_columns returns the target_columns rule contexts.
	GetTarget_columns() IIdentifier_listContext

	// SetTarget_columns sets the target_columns rule contexts.
	SetTarget_columns(IIdentifier_listContext)

	// Getter signatures
	INSERT() antlr.TerminalNode
	INTO() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	AllSql_expr_list() []ISql_expr_listContext
	Sql_expr_list(i int) ISql_expr_listContext
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	AS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	Upsert_clause() IUpsert_clauseContext
	Identifier_list() IIdentifier_listContext

	// IsInsert_statementContext differentiates from other interfaces.
	IsInsert_statementContext()
}

type Insert_statementContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	table_name     antlr.Token
	alias          antlr.Token
	target_columns IIdentifier_listContext
}

func NewEmptyInsert_statementContext() *Insert_statementContext {
	var p = new(Insert_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_insert_statement
	return p
}

func InitEmptyInsert_statementContext(p *Insert_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_insert_statement
}

func (*Insert_statementContext) IsInsert_statementContext() {}

func NewInsert_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_statementContext {
	var p = new(Insert_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_insert_statement

	return p
}

func (s *Insert_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_statementContext) GetTable_name() antlr.Token { return s.table_name }

func (s *Insert_statementContext) GetAlias() antlr.Token { return s.alias }

func (s *Insert_statementContext) SetTable_name(v antlr.Token) { s.table_name = v }

func (s *Insert_statementContext) SetAlias(v antlr.Token) { s.alias = v }

func (s *Insert_statementContext) GetTarget_columns() IIdentifier_listContext {
	return s.target_columns
}

func (s *Insert_statementContext) SetTarget_columns(v IIdentifier_listContext) { s.target_columns = v }

func (s *Insert_statementContext) INSERT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserINSERT, 0)
}

func (s *Insert_statementContext) INTO() antlr.TerminalNode {
	return s.GetToken(KuneiformParserINTO, 0)
}

func (s *Insert_statementContext) VALUES() antlr.TerminalNode {
	return s.GetToken(KuneiformParserVALUES, 0)
}

func (s *Insert_statementContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserLPAREN)
}

func (s *Insert_statementContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, i)
}

func (s *Insert_statementContext) AllSql_expr_list() []ISql_expr_listContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_expr_listContext); ok {
			len++
		}
	}

	tst := make([]ISql_expr_listContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_expr_listContext); ok {
			tst[i] = t.(ISql_expr_listContext)
			i++
		}
	}

	return tst
}

func (s *Insert_statementContext) Sql_expr_list(i int) ISql_expr_listContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_expr_listContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_expr_listContext)
}

func (s *Insert_statementContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserRPAREN)
}

func (s *Insert_statementContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, i)
}

func (s *Insert_statementContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserIDENTIFIER)
}

func (s *Insert_statementContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, i)
}

func (s *Insert_statementContext) AS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAS, 0)
}

func (s *Insert_statementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Insert_statementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Insert_statementContext) Upsert_clause() IUpsert_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpsert_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpsert_clauseContext)
}

func (s *Insert_statementContext) Identifier_list() IIdentifier_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifier_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Insert_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Insert_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitInsert_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Insert_statement() (localctx IInsert_statementContext) {
	localctx = NewInsert_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, KuneiformParserRULE_insert_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(641)
		p.Match(KuneiformParserINSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(642)
		p.Match(KuneiformParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(643)

		var _m = p.Match(KuneiformParserIDENTIFIER)

		localctx.(*Insert_statementContext).table_name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(646)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserAS {
		{
			p.SetState(644)
			p.Match(KuneiformParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(645)

			var _m = p.Match(KuneiformParserIDENTIFIER)

			localctx.(*Insert_statementContext).alias = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(652)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserLPAREN {
		{
			p.SetState(648)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(649)

			var _x = p.Identifier_list()

			localctx.(*Insert_statementContext).target_columns = _x
		}
		{
			p.SetState(650)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(654)
		p.Match(KuneiformParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(655)
		p.Match(KuneiformParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(656)
		p.Sql_expr_list()
	}
	{
		p.SetState(657)
		p.Match(KuneiformParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(665)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCOMMA {
		{
			p.SetState(658)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(659)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(660)
			p.Sql_expr_list()
		}
		{
			p.SetState(661)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(667)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(669)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserON {
		{
			p.SetState(668)
			p.Upsert_clause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpsert_clauseContext is an interface to support dynamic dispatch.
type IUpsert_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConflict_columns returns the conflict_columns rule contexts.
	GetConflict_columns() IIdentifier_listContext

	// GetConflict_where returns the conflict_where rule contexts.
	GetConflict_where() ISql_exprContext

	// GetUpdate_where returns the update_where rule contexts.
	GetUpdate_where() ISql_exprContext

	// SetConflict_columns sets the conflict_columns rule contexts.
	SetConflict_columns(IIdentifier_listContext)

	// SetConflict_where sets the conflict_where rule contexts.
	SetConflict_where(ISql_exprContext)

	// SetUpdate_where sets the update_where rule contexts.
	SetUpdate_where(ISql_exprContext)

	// Getter signatures
	ON() antlr.TerminalNode
	CONFLICT() antlr.TerminalNode
	DO() antlr.TerminalNode
	NOTHING() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	SET() antlr.TerminalNode
	AllUpdate_set_clause() []IUpdate_set_clauseContext
	Update_set_clause(i int) IUpdate_set_clauseContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Identifier_list() IIdentifier_listContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllWHERE() []antlr.TerminalNode
	WHERE(i int) antlr.TerminalNode
	AllSql_expr() []ISql_exprContext
	Sql_expr(i int) ISql_exprContext

	// IsUpsert_clauseContext differentiates from other interfaces.
	IsUpsert_clauseContext()
}

type Upsert_clauseContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	conflict_columns IIdentifier_listContext
	conflict_where   ISql_exprContext
	update_where     ISql_exprContext
}

func NewEmptyUpsert_clauseContext() *Upsert_clauseContext {
	var p = new(Upsert_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_upsert_clause
	return p
}

func InitEmptyUpsert_clauseContext(p *Upsert_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_upsert_clause
}

func (*Upsert_clauseContext) IsUpsert_clauseContext() {}

func NewUpsert_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Upsert_clauseContext {
	var p = new(Upsert_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_upsert_clause

	return p
}

func (s *Upsert_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Upsert_clauseContext) GetConflict_columns() IIdentifier_listContext {
	return s.conflict_columns
}

func (s *Upsert_clauseContext) GetConflict_where() ISql_exprContext { return s.conflict_where }

func (s *Upsert_clauseContext) GetUpdate_where() ISql_exprContext { return s.update_where }

func (s *Upsert_clauseContext) SetConflict_columns(v IIdentifier_listContext) { s.conflict_columns = v }

func (s *Upsert_clauseContext) SetConflict_where(v ISql_exprContext) { s.conflict_where = v }

func (s *Upsert_clauseContext) SetUpdate_where(v ISql_exprContext) { s.update_where = v }

func (s *Upsert_clauseContext) ON() antlr.TerminalNode {
	return s.GetToken(KuneiformParserON, 0)
}

func (s *Upsert_clauseContext) CONFLICT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCONFLICT, 0)
}

func (s *Upsert_clauseContext) DO() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDO, 0)
}

func (s *Upsert_clauseContext) NOTHING() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOTHING, 0)
}

func (s *Upsert_clauseContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUPDATE, 0)
}

func (s *Upsert_clauseContext) SET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSET, 0)
}

func (s *Upsert_clauseContext) AllUpdate_set_clause() []IUpdate_set_clauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdate_set_clauseContext); ok {
			len++
		}
	}

	tst := make([]IUpdate_set_clauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdate_set_clauseContext); ok {
			tst[i] = t.(IUpdate_set_clauseContext)
			i++
		}
	}

	return tst
}

func (s *Upsert_clauseContext) Update_set_clause(i int) IUpdate_set_clauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_set_clauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_set_clauseContext)
}

func (s *Upsert_clauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Upsert_clauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Upsert_clauseContext) Identifier_list() IIdentifier_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifier_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Upsert_clauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Upsert_clauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Upsert_clauseContext) AllWHERE() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserWHERE)
}

func (s *Upsert_clauseContext) WHERE(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserWHERE, i)
}

func (s *Upsert_clauseContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Upsert_clauseContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Upsert_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Upsert_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Upsert_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitUpsert_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Upsert_clause() (localctx IUpsert_clauseContext) {
	localctx = NewUpsert_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, KuneiformParserRULE_upsert_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(671)
		p.Match(KuneiformParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(672)
		p.Match(KuneiformParserCONFLICT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(680)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserLPAREN {
		{
			p.SetState(673)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(674)

			var _x = p.Identifier_list()

			localctx.(*Upsert_clauseContext).conflict_columns = _x
		}
		{
			p.SetState(675)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(678)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserWHERE {
			{
				p.SetState(676)
				p.Match(KuneiformParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(677)

				var _x = p.sql_expr(0)

				localctx.(*Upsert_clauseContext).conflict_where = _x
			}

		}

	}
	{
		p.SetState(682)
		p.Match(KuneiformParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(698)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KuneiformParserNOTHING:
		{
			p.SetState(683)
			p.Match(KuneiformParserNOTHING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KuneiformParserUPDATE:
		{
			p.SetState(684)
			p.Match(KuneiformParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(685)
			p.Match(KuneiformParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(686)
			p.Update_set_clause()
		}
		p.SetState(691)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KuneiformParserCOMMA {
			{
				p.SetState(687)
				p.Match(KuneiformParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(688)
				p.Update_set_clause()
			}

			p.SetState(693)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(696)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserWHERE {
			{
				p.SetState(694)
				p.Match(KuneiformParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(695)

				var _x = p.sql_expr(0)

				localctx.(*Upsert_clauseContext).update_where = _x
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelete_statementContext is an interface to support dynamic dispatch.
type IDelete_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable_name returns the table_name token.
	GetTable_name() antlr.Token

	// GetAlias returns the alias token.
	GetAlias() antlr.Token

	// SetTable_name sets the table_name token.
	SetTable_name(antlr.Token)

	// SetAlias sets the alias token.
	SetAlias(antlr.Token)

	// GetWhere returns the where rule contexts.
	GetWhere() ISql_exprContext

	// SetWhere sets the where rule contexts.
	SetWhere(ISql_exprContext)

	// Getter signatures
	DELETE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	AS() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Sql_expr() ISql_exprContext

	// IsDelete_statementContext differentiates from other interfaces.
	IsDelete_statementContext()
}

type Delete_statementContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	table_name antlr.Token
	alias      antlr.Token
	where      ISql_exprContext
}

func NewEmptyDelete_statementContext() *Delete_statementContext {
	var p = new(Delete_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_delete_statement
	return p
}

func InitEmptyDelete_statementContext(p *Delete_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_delete_statement
}

func (*Delete_statementContext) IsDelete_statementContext() {}

func NewDelete_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delete_statementContext {
	var p = new(Delete_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_delete_statement

	return p
}

func (s *Delete_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Delete_statementContext) GetTable_name() antlr.Token { return s.table_name }

func (s *Delete_statementContext) GetAlias() antlr.Token { return s.alias }

func (s *Delete_statementContext) SetTable_name(v antlr.Token) { s.table_name = v }

func (s *Delete_statementContext) SetAlias(v antlr.Token) { s.alias = v }

func (s *Delete_statementContext) GetWhere() ISql_exprContext { return s.where }

func (s *Delete_statementContext) SetWhere(v ISql_exprContext) { s.where = v }

func (s *Delete_statementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDELETE, 0)
}

func (s *Delete_statementContext) FROM() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFROM, 0)
}

func (s *Delete_statementContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserIDENTIFIER)
}

func (s *Delete_statementContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, i)
}

func (s *Delete_statementContext) AS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAS, 0)
}

func (s *Delete_statementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserWHERE, 0)
}

func (s *Delete_statementContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Delete_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delete_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitDelete_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Delete_statement() (localctx IDelete_statementContext) {
	localctx = NewDelete_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, KuneiformParserRULE_delete_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(700)
		p.Match(KuneiformParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(701)
		p.Match(KuneiformParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(702)

		var _m = p.Match(KuneiformParserIDENTIFIER)

		localctx.(*Delete_statementContext).table_name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(705)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserAS {
		{
			p.SetState(703)
			p.Match(KuneiformParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(704)

			var _m = p.Match(KuneiformParserIDENTIFIER)

			localctx.(*Delete_statementContext).alias = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(709)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserWHERE {
		{
			p.SetState(707)
			p.Match(KuneiformParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(708)

			var _x = p.sql_expr(0)

			localctx.(*Delete_statementContext).where = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISql_exprContext is an interface to support dynamic dispatch.
type ISql_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSql_exprContext differentiates from other interfaces.
	IsSql_exprContext()
}

type Sql_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_exprContext() *Sql_exprContext {
	var p = new(Sql_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_sql_expr
	return p
}

func InitEmptySql_exprContext(p *Sql_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_sql_expr
}

func (*Sql_exprContext) IsSql_exprContext() {}

func NewSql_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_exprContext {
	var p = new(Sql_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_sql_expr

	return p
}

func (s *Sql_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_exprContext) CopyAll(ctx *Sql_exprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *Sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Column_sql_exprContext struct {
	Sql_exprContext
	table  antlr.Token
	column antlr.Token
}

func NewColumn_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Column_sql_exprContext {
	var p = new(Column_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Column_sql_exprContext) GetTable() antlr.Token { return s.table }

func (s *Column_sql_exprContext) GetColumn() antlr.Token { return s.column }

func (s *Column_sql_exprContext) SetTable(v antlr.Token) { s.table = v }

func (s *Column_sql_exprContext) SetColumn(v antlr.Token) { s.column = v }

func (s *Column_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_sql_exprContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserIDENTIFIER)
}

func (s *Column_sql_exprContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, i)
}

func (s *Column_sql_exprContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPERIOD, 0)
}

func (s *Column_sql_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Column_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitColumn_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Logical_sql_exprContext struct {
	Sql_exprContext
	left  ISql_exprContext
	right ISql_exprContext
}

func NewLogical_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Logical_sql_exprContext {
	var p = new(Logical_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Logical_sql_exprContext) GetLeft() ISql_exprContext { return s.left }

func (s *Logical_sql_exprContext) GetRight() ISql_exprContext { return s.right }

func (s *Logical_sql_exprContext) SetLeft(v ISql_exprContext) { s.left = v }

func (s *Logical_sql_exprContext) SetRight(v ISql_exprContext) { s.right = v }

func (s *Logical_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_sql_exprContext) AND() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAND, 0)
}

func (s *Logical_sql_exprContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Logical_sql_exprContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Logical_sql_exprContext) OR() antlr.TerminalNode {
	return s.GetToken(KuneiformParserOR, 0)
}

func (s *Logical_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitLogical_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Array_access_sql_exprContext struct {
	Sql_exprContext
}

func NewArray_access_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Array_access_sql_exprContext {
	var p = new(Array_access_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Array_access_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_access_sql_exprContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Array_access_sql_exprContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Array_access_sql_exprContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACKET, 0)
}

func (s *Array_access_sql_exprContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACKET, 0)
}

func (s *Array_access_sql_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Array_access_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitArray_access_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Field_access_sql_exprContext struct {
	Sql_exprContext
}

func NewField_access_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Field_access_sql_exprContext {
	var p = new(Field_access_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Field_access_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_access_sql_exprContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Field_access_sql_exprContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPERIOD, 0)
}

func (s *Field_access_sql_exprContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *Field_access_sql_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Field_access_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitField_access_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Comparison_sql_exprContext struct {
	Sql_exprContext
	left  ISql_exprContext
	right ISql_exprContext
}

func NewComparison_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Comparison_sql_exprContext {
	var p = new(Comparison_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Comparison_sql_exprContext) GetLeft() ISql_exprContext { return s.left }

func (s *Comparison_sql_exprContext) GetRight() ISql_exprContext { return s.right }

func (s *Comparison_sql_exprContext) SetLeft(v ISql_exprContext) { s.left = v }

func (s *Comparison_sql_exprContext) SetRight(v ISql_exprContext) { s.right = v }

func (s *Comparison_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comparison_sql_exprContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Comparison_sql_exprContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Comparison_sql_exprContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEQUALS, 0)
}

func (s *Comparison_sql_exprContext) EQUATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEQUATE, 0)
}

func (s *Comparison_sql_exprContext) NEQ() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNEQ, 0)
}

func (s *Comparison_sql_exprContext) LT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLT, 0)
}

func (s *Comparison_sql_exprContext) LTE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLTE, 0)
}

func (s *Comparison_sql_exprContext) GT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserGT, 0)
}

func (s *Comparison_sql_exprContext) GTE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserGTE, 0)
}

func (s *Comparison_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitComparison_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Literal_sql_exprContext struct {
	Sql_exprContext
}

func NewLiteral_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Literal_sql_exprContext {
	var p = new(Literal_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Literal_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Literal_sql_exprContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *Literal_sql_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Literal_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitLiteral_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Between_sql_exprContext struct {
	Sql_exprContext
	element ISql_exprContext
	lower   ISql_exprContext
	upper   ISql_exprContext
}

func NewBetween_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Between_sql_exprContext {
	var p = new(Between_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Between_sql_exprContext) GetElement() ISql_exprContext { return s.element }

func (s *Between_sql_exprContext) GetLower() ISql_exprContext { return s.lower }

func (s *Between_sql_exprContext) GetUpper() ISql_exprContext { return s.upper }

func (s *Between_sql_exprContext) SetElement(v ISql_exprContext) { s.element = v }

func (s *Between_sql_exprContext) SetLower(v ISql_exprContext) { s.lower = v }

func (s *Between_sql_exprContext) SetUpper(v ISql_exprContext) { s.upper = v }

func (s *Between_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Between_sql_exprContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserBETWEEN, 0)
}

func (s *Between_sql_exprContext) AND() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAND, 0)
}

func (s *Between_sql_exprContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Between_sql_exprContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Between_sql_exprContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Between_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitBetween_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Function_call_sql_exprContext struct {
	Sql_exprContext
}

func NewFunction_call_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Function_call_sql_exprContext {
	var p = new(Function_call_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Function_call_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_call_sql_exprContext) Sql_function_call() ISql_function_callContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_function_callContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_function_callContext)
}

func (s *Function_call_sql_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Function_call_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitFunction_call_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Paren_sql_exprContext struct {
	Sql_exprContext
}

func NewParen_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Paren_sql_exprContext {
	var p = new(Paren_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Paren_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Paren_sql_exprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Paren_sql_exprContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Paren_sql_exprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Paren_sql_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Paren_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitParen_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Collate_sql_exprContext struct {
	Sql_exprContext
}

func NewCollate_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Collate_sql_exprContext {
	var p = new(Collate_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Collate_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collate_sql_exprContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Collate_sql_exprContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOLLATE, 0)
}

func (s *Collate_sql_exprContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *Collate_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitCollate_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Variable_sql_exprContext struct {
	Sql_exprContext
}

func NewVariable_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Variable_sql_exprContext {
	var p = new(Variable_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Variable_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_sql_exprContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Variable_sql_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Variable_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitVariable_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Is_sql_exprContext struct {
	Sql_exprContext
	left  ISql_exprContext
	right ISql_exprContext
}

func NewIs_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Is_sql_exprContext {
	var p = new(Is_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Is_sql_exprContext) GetLeft() ISql_exprContext { return s.left }

func (s *Is_sql_exprContext) GetRight() ISql_exprContext { return s.right }

func (s *Is_sql_exprContext) SetLeft(v ISql_exprContext) { s.left = v }

func (s *Is_sql_exprContext) SetRight(v ISql_exprContext) { s.right = v }

func (s *Is_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Is_sql_exprContext) IS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIS, 0)
}

func (s *Is_sql_exprContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Is_sql_exprContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Is_sql_exprContext) NULL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNULL, 0)
}

func (s *Is_sql_exprContext) TRUE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserTRUE, 0)
}

func (s *Is_sql_exprContext) FALSE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFALSE, 0)
}

func (s *Is_sql_exprContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Is_sql_exprContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDISTINCT, 0)
}

func (s *Is_sql_exprContext) FROM() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFROM, 0)
}

func (s *Is_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitIs_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Like_sql_exprContext struct {
	Sql_exprContext
	left  ISql_exprContext
	right ISql_exprContext
}

func NewLike_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Like_sql_exprContext {
	var p = new(Like_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Like_sql_exprContext) GetLeft() ISql_exprContext { return s.left }

func (s *Like_sql_exprContext) GetRight() ISql_exprContext { return s.right }

func (s *Like_sql_exprContext) SetLeft(v ISql_exprContext) { s.left = v }

func (s *Like_sql_exprContext) SetRight(v ISql_exprContext) { s.right = v }

func (s *Like_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Like_sql_exprContext) LIKE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLIKE, 0)
}

func (s *Like_sql_exprContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Like_sql_exprContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Like_sql_exprContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Like_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitLike_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Arithmetic_sql_exprContext struct {
	Sql_exprContext
	left  ISql_exprContext
	right ISql_exprContext
}

func NewArithmetic_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Arithmetic_sql_exprContext {
	var p = new(Arithmetic_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Arithmetic_sql_exprContext) GetLeft() ISql_exprContext { return s.left }

func (s *Arithmetic_sql_exprContext) GetRight() ISql_exprContext { return s.right }

func (s *Arithmetic_sql_exprContext) SetLeft(v ISql_exprContext) { s.left = v }

func (s *Arithmetic_sql_exprContext) SetRight(v ISql_exprContext) { s.right = v }

func (s *Arithmetic_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arithmetic_sql_exprContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCONCAT, 0)
}

func (s *Arithmetic_sql_exprContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Arithmetic_sql_exprContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Arithmetic_sql_exprContext) STAR() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSTAR, 0)
}

func (s *Arithmetic_sql_exprContext) DIV() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDIV, 0)
}

func (s *Arithmetic_sql_exprContext) MOD() antlr.TerminalNode {
	return s.GetToken(KuneiformParserMOD, 0)
}

func (s *Arithmetic_sql_exprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPLUS, 0)
}

func (s *Arithmetic_sql_exprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserMINUS, 0)
}

func (s *Arithmetic_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitArithmetic_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Subquery_sql_exprContext struct {
	Sql_exprContext
}

func NewSubquery_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Subquery_sql_exprContext {
	var p = new(Subquery_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Subquery_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subquery_sql_exprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Subquery_sql_exprContext) Select_statement() ISelect_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *Subquery_sql_exprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Subquery_sql_exprContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEXISTS, 0)
}

func (s *Subquery_sql_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Subquery_sql_exprContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Subquery_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitSubquery_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Unary_sql_exprContext struct {
	Sql_exprContext
}

func NewUnary_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Unary_sql_exprContext {
	var p = new(Unary_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Unary_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_sql_exprContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Unary_sql_exprContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Unary_sql_exprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPLUS, 0)
}

func (s *Unary_sql_exprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserMINUS, 0)
}

func (s *Unary_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitUnary_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Case_exprContext struct {
	Sql_exprContext
	case_clause    ISql_exprContext
	when_condition ISql_exprContext
	then           ISql_exprContext
	else_clause    ISql_exprContext
}

func NewCase_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Case_exprContext {
	var p = new(Case_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Case_exprContext) GetCase_clause() ISql_exprContext { return s.case_clause }

func (s *Case_exprContext) GetWhen_condition() ISql_exprContext { return s.when_condition }

func (s *Case_exprContext) GetThen() ISql_exprContext { return s.then }

func (s *Case_exprContext) GetElse_clause() ISql_exprContext { return s.else_clause }

func (s *Case_exprContext) SetCase_clause(v ISql_exprContext) { s.case_clause = v }

func (s *Case_exprContext) SetWhen_condition(v ISql_exprContext) { s.when_condition = v }

func (s *Case_exprContext) SetThen(v ISql_exprContext) { s.then = v }

func (s *Case_exprContext) SetElse_clause(v ISql_exprContext) { s.else_clause = v }

func (s *Case_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_exprContext) CASE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCASE, 0)
}

func (s *Case_exprContext) END() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEND, 0)
}

func (s *Case_exprContext) AllWHEN() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserWHEN)
}

func (s *Case_exprContext) WHEN(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserWHEN, i)
}

func (s *Case_exprContext) AllTHEN() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserTHEN)
}

func (s *Case_exprContext) THEN(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserTHEN, i)
}

func (s *Case_exprContext) ELSE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserELSE, 0)
}

func (s *Case_exprContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Case_exprContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Case_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitCase_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type In_sql_exprContext struct {
	Sql_exprContext
}

func NewIn_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *In_sql_exprContext {
	var p = new(In_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *In_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *In_sql_exprContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *In_sql_exprContext) IN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIN, 0)
}

func (s *In_sql_exprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *In_sql_exprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *In_sql_exprContext) Sql_expr_list() ISql_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_expr_listContext)
}

func (s *In_sql_exprContext) Select_statement() ISelect_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *In_sql_exprContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *In_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitIn_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Sql_expr() (localctx ISql_exprContext) {
	return p.sql_expr(0)
}

func (p *KuneiformParser) sql_expr(_p int) (localctx ISql_exprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewSql_exprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISql_exprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 80
	p.EnterRecursionRule(localctx, 80, KuneiformParserRULE_sql_expr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(771)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLiteral_sql_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(712)
			p.Literal()
		}
		p.SetState(714)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(713)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewFunction_call_sql_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(716)
			p.Sql_function_call()
		}
		p.SetState(718)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(717)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewVariable_sql_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(720)
			p.Variable()
		}
		p.SetState(722)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(721)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewColumn_sql_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(726)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(724)

				var _m = p.Match(KuneiformParserIDENTIFIER)

				localctx.(*Column_sql_exprContext).table = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(725)
				p.Match(KuneiformParserPERIOD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(728)

			var _m = p.Match(KuneiformParserIDENTIFIER)

			localctx.(*Column_sql_exprContext).column = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(730)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(729)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		localctx = NewParen_sql_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(732)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(733)
			p.sql_expr(0)
		}
		{
			p.SetState(734)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(736)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(735)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		localctx = NewUnary_sql_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(738)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1152921504609992704) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(739)
			p.sql_expr(11)
		}

	case 7:
		localctx = NewCase_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(740)
			p.Match(KuneiformParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(742)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1188950301628956800) != 0) || ((int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&-2288391560656584703) != 0) {
			{
				p.SetState(741)

				var _x = p.sql_expr(0)

				localctx.(*Case_exprContext).case_clause = _x
			}

		}
		p.SetState(749)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == KuneiformParserWHEN {
			{
				p.SetState(744)
				p.Match(KuneiformParserWHEN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(745)

				var _x = p.sql_expr(0)

				localctx.(*Case_exprContext).when_condition = _x
			}
			{
				p.SetState(746)
				p.Match(KuneiformParserTHEN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(747)

				var _x = p.sql_expr(0)

				localctx.(*Case_exprContext).then = _x
			}

			p.SetState(751)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(755)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserELSE {
			{
				p.SetState(753)
				p.Match(KuneiformParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(754)

				var _x = p.sql_expr(0)

				localctx.(*Case_exprContext).else_clause = _x
			}

		}
		{
			p.SetState(757)
			p.Match(KuneiformParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewSubquery_sql_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(763)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserNOT || _la == KuneiformParserEXISTS {
			p.SetState(760)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == KuneiformParserNOT {
				{
					p.SetState(759)
					p.Match(KuneiformParserNOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(762)
				p.Match(KuneiformParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(765)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(766)
			p.Select_statement()
		}
		{
			p.SetState(767)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(769)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(768)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(849)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(847)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext()) {
			case 1:
				localctx = NewComparison_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				localctx.(*Comparison_sql_exprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(773)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(774)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&260145152) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(775)

					var _x = p.sql_expr(15)

					localctx.(*Comparison_sql_exprContext).right = _x
				}

			case 2:
				localctx = NewLike_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				localctx.(*Like_sql_exprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(776)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				p.SetState(778)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == KuneiformParserNOT {
					{
						p.SetState(777)
						p.Match(KuneiformParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(780)
					p.Match(KuneiformParserLIKE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(781)

					var _x = p.sql_expr(13)

					localctx.(*Like_sql_exprContext).right = _x
				}

			case 3:
				localctx = NewBetween_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				localctx.(*Between_sql_exprContext).element = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(782)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				p.SetState(784)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == KuneiformParserNOT {
					{
						p.SetState(783)
						p.Match(KuneiformParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(786)
					p.Match(KuneiformParserBETWEEN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(787)

					var _x = p.sql_expr(0)

					localctx.(*Between_sql_exprContext).lower = _x
				}
				{
					p.SetState(788)
					p.Match(KuneiformParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(789)

					var _x = p.sql_expr(11)

					localctx.(*Between_sql_exprContext).upper = _x
				}

			case 4:
				localctx = NewArithmetic_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				localctx.(*Arithmetic_sql_exprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(791)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(792)
					p.Match(KuneiformParserCONCAT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(793)

					var _x = p.sql_expr(6)

					localctx.(*Arithmetic_sql_exprContext).right = _x
				}

			case 5:
				localctx = NewArithmetic_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				localctx.(*Arithmetic_sql_exprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(794)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(795)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4734976) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(796)

					var _x = p.sql_expr(5)

					localctx.(*Arithmetic_sql_exprContext).right = _x
				}

			case 6:
				localctx = NewArithmetic_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				localctx.(*Arithmetic_sql_exprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(797)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(798)
					_la = p.GetTokenStream().LA(1)

					if !(_la == KuneiformParserPLUS || _la == KuneiformParserMINUS) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(799)

					var _x = p.sql_expr(4)

					localctx.(*Arithmetic_sql_exprContext).right = _x
				}

			case 7:
				localctx = NewLogical_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				localctx.(*Logical_sql_exprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(800)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(801)
					p.Match(KuneiformParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(802)

					var _x = p.sql_expr(3)

					localctx.(*Logical_sql_exprContext).right = _x
				}

			case 8:
				localctx = NewLogical_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				localctx.(*Logical_sql_exprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(803)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(804)
					p.Match(KuneiformParserOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(805)

					var _x = p.sql_expr(2)

					localctx.(*Logical_sql_exprContext).right = _x
				}

			case 9:
				localctx = NewArray_access_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(806)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
					goto errorExit
				}
				{
					p.SetState(807)
					p.Match(KuneiformParserLBRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(808)
					p.sql_expr(0)
				}
				{
					p.SetState(809)
					p.Match(KuneiformParserRBRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(811)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(810)
						p.Type_cast()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case 10:
				localctx = NewField_access_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(813)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
					goto errorExit
				}
				{
					p.SetState(814)
					p.Match(KuneiformParserPERIOD)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(815)
					p.Match(KuneiformParserIDENTIFIER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(817)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(816)
						p.Type_cast()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case 11:
				localctx = NewIn_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(819)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				p.SetState(821)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == KuneiformParserNOT {
					{
						p.SetState(820)
						p.Match(KuneiformParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(823)
					p.Match(KuneiformParserIN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(824)
					p.Match(KuneiformParserLPAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(827)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case KuneiformParserLPAREN, KuneiformParserPLUS, KuneiformParserMINUS, KuneiformParserNULL, KuneiformParserNOT, KuneiformParserEXISTS, KuneiformParserCASE, KuneiformParserSTRING_, KuneiformParserTRUE, KuneiformParserFALSE, KuneiformParserDIGITS_, KuneiformParserBINARY_, KuneiformParserIDENTIFIER, KuneiformParserVARIABLE, KuneiformParserCONTEXTUAL_VARIABLE:
					{
						p.SetState(825)
						p.Sql_expr_list()
					}

				case KuneiformParserSELECT:
					{
						p.SetState(826)
						p.Select_statement()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}
				{
					p.SetState(829)
					p.Match(KuneiformParserRPAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 12:
				localctx = NewIs_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				localctx.(*Is_sql_exprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(831)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				{
					p.SetState(832)
					p.Match(KuneiformParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(834)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == KuneiformParserNOT {
					{
						p.SetState(833)
						p.Match(KuneiformParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(842)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case KuneiformParserDISTINCT:
					{
						p.SetState(836)
						p.Match(KuneiformParserDISTINCT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(837)
						p.Match(KuneiformParserFROM)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(838)

						var _x = p.sql_expr(0)

						localctx.(*Is_sql_exprContext).right = _x
					}

				case KuneiformParserNULL:
					{
						p.SetState(839)
						p.Match(KuneiformParserNULL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case KuneiformParserTRUE:
					{
						p.SetState(840)
						p.Match(KuneiformParserTRUE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case KuneiformParserFALSE:
					{
						p.SetState(841)
						p.Match(KuneiformParserFALSE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			case 13:
				localctx = NewCollate_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(844)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(845)
					p.Match(KuneiformParserCOLLATE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(846)
					p.Match(KuneiformParserIDENTIFIER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(851)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISql_expr_listContext is an interface to support dynamic dispatch.
type ISql_expr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSql_expr() []ISql_exprContext
	Sql_expr(i int) ISql_exprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSql_expr_listContext differentiates from other interfaces.
	IsSql_expr_listContext()
}

type Sql_expr_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_expr_listContext() *Sql_expr_listContext {
	var p = new(Sql_expr_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_sql_expr_list
	return p
}

func InitEmptySql_expr_listContext(p *Sql_expr_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_sql_expr_list
}

func (*Sql_expr_listContext) IsSql_expr_listContext() {}

func NewSql_expr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_expr_listContext {
	var p = new(Sql_expr_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_sql_expr_list

	return p
}

func (s *Sql_expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_expr_listContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Sql_expr_listContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Sql_expr_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Sql_expr_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Sql_expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sql_expr_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitSql_expr_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Sql_expr_list() (localctx ISql_expr_listContext) {
	localctx = NewSql_expr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, KuneiformParserRULE_sql_expr_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(852)
		p.sql_expr(0)
	}
	p.SetState(857)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCOMMA {
		{
			p.SetState(853)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(854)
			p.sql_expr(0)
		}

		p.SetState(859)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISql_function_callContext is an interface to support dynamic dispatch.
type ISql_function_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSql_function_callContext differentiates from other interfaces.
	IsSql_function_callContext()
}

type Sql_function_callContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_function_callContext() *Sql_function_callContext {
	var p = new(Sql_function_callContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_sql_function_call
	return p
}

func InitEmptySql_function_callContext(p *Sql_function_callContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_sql_function_call
}

func (*Sql_function_callContext) IsSql_function_callContext() {}

func NewSql_function_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_function_callContext {
	var p = new(Sql_function_callContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_sql_function_call

	return p
}

func (s *Sql_function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_function_callContext) CopyAll(ctx *Sql_function_callContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *Sql_function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Normal_call_sqlContext struct {
	Sql_function_callContext
}

func NewNormal_call_sqlContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Normal_call_sqlContext {
	var p = new(Normal_call_sqlContext)

	InitEmptySql_function_callContext(&p.Sql_function_callContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_function_callContext))

	return p
}

func (s *Normal_call_sqlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Normal_call_sqlContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *Normal_call_sqlContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Normal_call_sqlContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Normal_call_sqlContext) Sql_expr_list() ISql_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_expr_listContext)
}

func (s *Normal_call_sqlContext) STAR() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSTAR, 0)
}

func (s *Normal_call_sqlContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDISTINCT, 0)
}

func (s *Normal_call_sqlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitNormal_call_sql(s)

	default:
		return t.VisitChildren(s)
	}
}

type Foreign_call_sqlContext struct {
	Sql_function_callContext
	dbid      ISql_exprContext
	procedure ISql_exprContext
}

func NewForeign_call_sqlContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Foreign_call_sqlContext {
	var p = new(Foreign_call_sqlContext)

	InitEmptySql_function_callContext(&p.Sql_function_callContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_function_callContext))

	return p
}

func (s *Foreign_call_sqlContext) GetDbid() ISql_exprContext { return s.dbid }

func (s *Foreign_call_sqlContext) GetProcedure() ISql_exprContext { return s.procedure }

func (s *Foreign_call_sqlContext) SetDbid(v ISql_exprContext) { s.dbid = v }

func (s *Foreign_call_sqlContext) SetProcedure(v ISql_exprContext) { s.procedure = v }

func (s *Foreign_call_sqlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Foreign_call_sqlContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *Foreign_call_sqlContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACKET, 0)
}

func (s *Foreign_call_sqlContext) COMMA() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, 0)
}

func (s *Foreign_call_sqlContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACKET, 0)
}

func (s *Foreign_call_sqlContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Foreign_call_sqlContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Foreign_call_sqlContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Foreign_call_sqlContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Foreign_call_sqlContext) Sql_expr_list() ISql_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_expr_listContext)
}

func (s *Foreign_call_sqlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitForeign_call_sql(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Sql_function_call() (localctx ISql_function_callContext) {
	localctx = NewSql_function_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, KuneiformParserRULE_sql_function_call)
	var _la int

	p.SetState(882)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNormal_call_sqlContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(860)
			p.Match(KuneiformParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(861)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(867)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case KuneiformParserLPAREN, KuneiformParserPLUS, KuneiformParserMINUS, KuneiformParserNULL, KuneiformParserNOT, KuneiformParserEXISTS, KuneiformParserCASE, KuneiformParserDISTINCT, KuneiformParserSTRING_, KuneiformParserTRUE, KuneiformParserFALSE, KuneiformParserDIGITS_, KuneiformParserBINARY_, KuneiformParserIDENTIFIER, KuneiformParserVARIABLE, KuneiformParserCONTEXTUAL_VARIABLE:
			p.SetState(863)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == KuneiformParserDISTINCT {
				{
					p.SetState(862)
					p.Match(KuneiformParserDISTINCT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(865)
				p.Sql_expr_list()
			}

		case KuneiformParserSTAR:
			{
				p.SetState(866)
				p.Match(KuneiformParserSTAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case KuneiformParserRPAREN:

		default:
		}
		{
			p.SetState(869)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewForeign_call_sqlContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(870)
			p.Match(KuneiformParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(871)
			p.Match(KuneiformParserLBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(872)

			var _x = p.sql_expr(0)

			localctx.(*Foreign_call_sqlContext).dbid = _x
		}
		{
			p.SetState(873)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(874)

			var _x = p.sql_expr(0)

			localctx.(*Foreign_call_sqlContext).procedure = _x
		}
		{
			p.SetState(875)
			p.Match(KuneiformParserRBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(876)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(878)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1188950301628956800) != 0) || ((int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&-2288391560656584703) != 0) {
			{
				p.SetState(877)
				p.Sql_expr_list()
			}

		}
		{
			p.SetState(880)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAction_blockContext is an interface to support dynamic dispatch.
type IAction_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAction_statement() []IAction_statementContext
	Action_statement(i int) IAction_statementContext
	AllSCOL() []antlr.TerminalNode
	SCOL(i int) antlr.TerminalNode

	// IsAction_blockContext differentiates from other interfaces.
	IsAction_blockContext()
}

type Action_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAction_blockContext() *Action_blockContext {
	var p = new(Action_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_action_block
	return p
}

func InitEmptyAction_blockContext(p *Action_blockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_action_block
}

func (*Action_blockContext) IsAction_blockContext() {}

func NewAction_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Action_blockContext {
	var p = new(Action_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_action_block

	return p
}

func (s *Action_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Action_blockContext) AllAction_statement() []IAction_statementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAction_statementContext); ok {
			len++
		}
	}

	tst := make([]IAction_statementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAction_statementContext); ok {
			tst[i] = t.(IAction_statementContext)
			i++
		}
	}

	return tst
}

func (s *Action_blockContext) Action_statement(i int) IAction_statementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_statementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_statementContext)
}

func (s *Action_blockContext) AllSCOL() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserSCOL)
}

func (s *Action_blockContext) SCOL(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, i)
}

func (s *Action_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Action_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Action_blockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitAction_block(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Action_block() (localctx IAction_blockContext) {
	localctx = NewAction_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, KuneiformParserRULE_action_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(889)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserDELETE || _la == KuneiformParserUPDATE || ((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&30786325579265) != 0) {
		{
			p.SetState(884)
			p.Action_statement()
		}
		{
			p.SetState(885)
			p.Match(KuneiformParserSCOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(891)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAction_statementContext is an interface to support dynamic dispatch.
type IAction_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAction_statementContext differentiates from other interfaces.
	IsAction_statementContext()
}

type Action_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAction_statementContext() *Action_statementContext {
	var p = new(Action_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_action_statement
	return p
}

func InitEmptyAction_statementContext(p *Action_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_action_statement
}

func (*Action_statementContext) IsAction_statementContext() {}

func NewAction_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Action_statementContext {
	var p = new(Action_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_action_statement

	return p
}

func (s *Action_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Action_statementContext) CopyAll(ctx *Action_statementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *Action_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Action_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Extension_actionContext struct {
	Action_statementContext
}

func NewExtension_actionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Extension_actionContext {
	var p = new(Extension_actionContext)

	InitEmptyAction_statementContext(&p.Action_statementContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_statementContext))

	return p
}

func (s *Extension_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Extension_actionContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserIDENTIFIER)
}

func (s *Extension_actionContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, i)
}

func (s *Extension_actionContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPERIOD, 0)
}

func (s *Extension_actionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Extension_actionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Extension_actionContext) Variable_list() IVariable_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariable_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariable_listContext)
}

func (s *Extension_actionContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEQUALS, 0)
}

func (s *Extension_actionContext) Procedure_expr_list() IProcedure_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_expr_listContext)
}

func (s *Extension_actionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitExtension_action(s)

	default:
		return t.VisitChildren(s)
	}
}

type Local_actionContext struct {
	Action_statementContext
}

func NewLocal_actionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Local_actionContext {
	var p = new(Local_actionContext)

	InitEmptyAction_statementContext(&p.Action_statementContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_statementContext))

	return p
}

func (s *Local_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Local_actionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *Local_actionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Local_actionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Local_actionContext) Procedure_expr_list() IProcedure_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_expr_listContext)
}

func (s *Local_actionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitLocal_action(s)

	default:
		return t.VisitChildren(s)
	}
}

type Sql_actionContext struct {
	Action_statementContext
}

func NewSql_actionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Sql_actionContext {
	var p = new(Sql_actionContext)

	InitEmptyAction_statementContext(&p.Action_statementContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_statementContext))

	return p
}

func (s *Sql_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_actionContext) Sql_statement() ISql_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_statementContext)
}

func (s *Sql_actionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitSql_action(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Action_statement() (localctx IAction_statementContext) {
	localctx = NewAction_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, KuneiformParserRULE_action_statement)
	var _la int

	p.SetState(912)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSql_actionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(892)
			p.Sql_statement()
		}

	case 2:
		localctx = NewLocal_actionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(893)
			p.Match(KuneiformParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(894)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(896)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&36028797022111880) != 0) || ((int64((_la-117)) & ^0x3f) == 0 && ((int64(1)<<(_la-117))&28703) != 0) {
			{
				p.SetState(895)
				p.Procedure_expr_list()
			}

		}
		{
			p.SetState(898)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewExtension_actionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(902)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserVARIABLE || _la == KuneiformParserCONTEXTUAL_VARIABLE {
			{
				p.SetState(899)
				p.Variable_list()
			}
			{
				p.SetState(900)
				p.Match(KuneiformParserEQUALS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(904)
			p.Match(KuneiformParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(905)
			p.Match(KuneiformParserPERIOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(906)
			p.Match(KuneiformParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(907)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(909)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&36028797022111880) != 0) || ((int64((_la-117)) & ^0x3f) == 0 && ((int64(1)<<(_la-117))&28703) != 0) {
			{
				p.SetState(908)
				p.Procedure_expr_list()
			}

		}
		{
			p.SetState(911)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedure_blockContext is an interface to support dynamic dispatch.
type IProcedure_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsProcedure_blockContext differentiates from other interfaces.
	IsProcedure_blockContext()
}

type Procedure_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedure_blockContext() *Procedure_blockContext {
	var p = new(Procedure_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_procedure_block
	return p
}

func InitEmptyProcedure_blockContext(p *Procedure_blockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_procedure_block
}

func (*Procedure_blockContext) IsProcedure_blockContext() {}

func NewProcedure_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedure_blockContext {
	var p = new(Procedure_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_procedure_block

	return p
}

func (s *Procedure_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedure_blockContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *Procedure_blockContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Procedure_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedure_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedure_blockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitProcedure_block(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Procedure_block() (localctx IProcedure_blockContext) {
	localctx = NewProcedure_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, KuneiformParserRULE_procedure_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(917)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&216172782650654720) != 0) || ((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&13194567353857) != 0) {
		{
			p.SetState(914)
			p.Statement()
		}

		p.SetState(919)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedure_exprContext is an interface to support dynamic dispatch.
type IProcedure_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsProcedure_exprContext differentiates from other interfaces.
	IsProcedure_exprContext()
}

type Procedure_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedure_exprContext() *Procedure_exprContext {
	var p = new(Procedure_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_procedure_expr
	return p
}

func InitEmptyProcedure_exprContext(p *Procedure_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_procedure_expr
}

func (*Procedure_exprContext) IsProcedure_exprContext() {}

func NewProcedure_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedure_exprContext {
	var p = new(Procedure_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_procedure_expr

	return p
}

func (s *Procedure_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedure_exprContext) CopyAll(ctx *Procedure_exprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *Procedure_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedure_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Field_access_procedure_exprContext struct {
	Procedure_exprContext
}

func NewField_access_procedure_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Field_access_procedure_exprContext {
	var p = new(Field_access_procedure_exprContext)

	InitEmptyProcedure_exprContext(&p.Procedure_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Procedure_exprContext))

	return p
}

func (s *Field_access_procedure_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_access_procedure_exprContext) Procedure_expr() IProcedure_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_exprContext)
}

func (s *Field_access_procedure_exprContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPERIOD, 0)
}

func (s *Field_access_procedure_exprContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *Field_access_procedure_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Field_access_procedure_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitField_access_procedure_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Literal_procedure_exprContext struct {
	Procedure_exprContext
}

func NewLiteral_procedure_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Literal_procedure_exprContext {
	var p = new(Literal_procedure_exprContext)

	InitEmptyProcedure_exprContext(&p.Procedure_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Procedure_exprContext))

	return p
}

func (s *Literal_procedure_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Literal_procedure_exprContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *Literal_procedure_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Literal_procedure_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitLiteral_procedure_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Paren_procedure_exprContext struct {
	Procedure_exprContext
}

func NewParen_procedure_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Paren_procedure_exprContext {
	var p = new(Paren_procedure_exprContext)

	InitEmptyProcedure_exprContext(&p.Procedure_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Procedure_exprContext))

	return p
}

func (s *Paren_procedure_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Paren_procedure_exprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Paren_procedure_exprContext) Procedure_expr() IProcedure_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_exprContext)
}

func (s *Paren_procedure_exprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Paren_procedure_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Paren_procedure_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitParen_procedure_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Variable_procedure_exprContext struct {
	Procedure_exprContext
}

func NewVariable_procedure_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Variable_procedure_exprContext {
	var p = new(Variable_procedure_exprContext)

	InitEmptyProcedure_exprContext(&p.Procedure_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Procedure_exprContext))

	return p
}

func (s *Variable_procedure_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_procedure_exprContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Variable_procedure_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Variable_procedure_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitVariable_procedure_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Make_array_procedure_exprContext struct {
	Procedure_exprContext
}

func NewMake_array_procedure_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Make_array_procedure_exprContext {
	var p = new(Make_array_procedure_exprContext)

	InitEmptyProcedure_exprContext(&p.Procedure_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Procedure_exprContext))

	return p
}

func (s *Make_array_procedure_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Make_array_procedure_exprContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACKET, 0)
}

func (s *Make_array_procedure_exprContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACKET, 0)
}

func (s *Make_array_procedure_exprContext) Procedure_expr_list() IProcedure_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_expr_listContext)
}

func (s *Make_array_procedure_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Make_array_procedure_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitMake_array_procedure_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Procedure_expr_arithmeticContext struct {
	Procedure_exprContext
}

func NewProcedure_expr_arithmeticContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Procedure_expr_arithmeticContext {
	var p = new(Procedure_expr_arithmeticContext)

	InitEmptyProcedure_exprContext(&p.Procedure_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Procedure_exprContext))

	return p
}

func (s *Procedure_expr_arithmeticContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedure_expr_arithmeticContext) AllProcedure_expr() []IProcedure_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedure_exprContext); ok {
			len++
		}
	}

	tst := make([]IProcedure_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedure_exprContext); ok {
			tst[i] = t.(IProcedure_exprContext)
			i++
		}
	}

	return tst
}

func (s *Procedure_expr_arithmeticContext) Procedure_expr(i int) IProcedure_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_exprContext)
}

func (s *Procedure_expr_arithmeticContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCONCAT, 0)
}

func (s *Procedure_expr_arithmeticContext) STAR() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSTAR, 0)
}

func (s *Procedure_expr_arithmeticContext) DIV() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDIV, 0)
}

func (s *Procedure_expr_arithmeticContext) MOD() antlr.TerminalNode {
	return s.GetToken(KuneiformParserMOD, 0)
}

func (s *Procedure_expr_arithmeticContext) PLUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPLUS, 0)
}

func (s *Procedure_expr_arithmeticContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserMINUS, 0)
}

func (s *Procedure_expr_arithmeticContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitProcedure_expr_arithmetic(s)

	default:
		return t.VisitChildren(s)
	}
}

type Unary_procedure_exprContext struct {
	Procedure_exprContext
}

func NewUnary_procedure_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Unary_procedure_exprContext {
	var p = new(Unary_procedure_exprContext)

	InitEmptyProcedure_exprContext(&p.Procedure_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Procedure_exprContext))

	return p
}

func (s *Unary_procedure_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_procedure_exprContext) Procedure_expr() IProcedure_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_exprContext)
}

func (s *Unary_procedure_exprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserMINUS, 0)
}

func (s *Unary_procedure_exprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPLUS, 0)
}

func (s *Unary_procedure_exprContext) EXCL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEXCL, 0)
}

func (s *Unary_procedure_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitUnary_procedure_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Comparison_procedure_exprContext struct {
	Procedure_exprContext
}

func NewComparison_procedure_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Comparison_procedure_exprContext {
	var p = new(Comparison_procedure_exprContext)

	InitEmptyProcedure_exprContext(&p.Procedure_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Procedure_exprContext))

	return p
}

func (s *Comparison_procedure_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comparison_procedure_exprContext) AllProcedure_expr() []IProcedure_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedure_exprContext); ok {
			len++
		}
	}

	tst := make([]IProcedure_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedure_exprContext); ok {
			tst[i] = t.(IProcedure_exprContext)
			i++
		}
	}

	return tst
}

func (s *Comparison_procedure_exprContext) Procedure_expr(i int) IProcedure_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_exprContext)
}

func (s *Comparison_procedure_exprContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEQUALS, 0)
}

func (s *Comparison_procedure_exprContext) EQUATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEQUATE, 0)
}

func (s *Comparison_procedure_exprContext) NEQ() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNEQ, 0)
}

func (s *Comparison_procedure_exprContext) LT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLT, 0)
}

func (s *Comparison_procedure_exprContext) LTE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLTE, 0)
}

func (s *Comparison_procedure_exprContext) GT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserGT, 0)
}

func (s *Comparison_procedure_exprContext) GTE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserGTE, 0)
}

func (s *Comparison_procedure_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitComparison_procedure_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Function_call_procedure_exprContext struct {
	Procedure_exprContext
}

func NewFunction_call_procedure_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Function_call_procedure_exprContext {
	var p = new(Function_call_procedure_exprContext)

	InitEmptyProcedure_exprContext(&p.Procedure_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Procedure_exprContext))

	return p
}

func (s *Function_call_procedure_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_call_procedure_exprContext) Procedure_function_call() IProcedure_function_callContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_function_callContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_function_callContext)
}

func (s *Function_call_procedure_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Function_call_procedure_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitFunction_call_procedure_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Array_access_procedure_exprContext struct {
	Procedure_exprContext
}

func NewArray_access_procedure_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Array_access_procedure_exprContext {
	var p = new(Array_access_procedure_exprContext)

	InitEmptyProcedure_exprContext(&p.Procedure_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Procedure_exprContext))

	return p
}

func (s *Array_access_procedure_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_access_procedure_exprContext) AllProcedure_expr() []IProcedure_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedure_exprContext); ok {
			len++
		}
	}

	tst := make([]IProcedure_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedure_exprContext); ok {
			tst[i] = t.(IProcedure_exprContext)
			i++
		}
	}

	return tst
}

func (s *Array_access_procedure_exprContext) Procedure_expr(i int) IProcedure_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_exprContext)
}

func (s *Array_access_procedure_exprContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACKET, 0)
}

func (s *Array_access_procedure_exprContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACKET, 0)
}

func (s *Array_access_procedure_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Array_access_procedure_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitArray_access_procedure_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Procedure_expr() (localctx IProcedure_exprContext) {
	return p.procedure_expr(0)
}

func (p *KuneiformParser) procedure_expr(_p int) (localctx IProcedure_exprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewProcedure_exprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IProcedure_exprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 92
	p.EnterRecursionRule(localctx, 92, KuneiformParserRULE_procedure_expr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(949)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLiteral_procedure_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(921)
			p.Literal()
		}
		p.SetState(923)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(922)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewFunction_call_procedure_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(925)
			p.Procedure_function_call()
		}
		p.SetState(927)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(926)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewVariable_procedure_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(929)
			p.Variable()
		}
		p.SetState(931)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(930)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewMake_array_procedure_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(933)
			p.Match(KuneiformParserLBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(935)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&36028797022111880) != 0) || ((int64((_la-117)) & ^0x3f) == 0 && ((int64(1)<<(_la-117))&28703) != 0) {
			{
				p.SetState(934)
				p.Procedure_expr_list()
			}

		}
		{
			p.SetState(937)
			p.Match(KuneiformParserRBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(939)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(938)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		localctx = NewParen_procedure_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(941)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(942)
			p.procedure_expr(0)
		}
		{
			p.SetState(943)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(945)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(944)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		localctx = NewUnary_procedure_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(947)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3147776) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(948)
			p.procedure_expr(4)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(978)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(976)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 134, p.GetParserRuleContext()) {
			case 1:
				localctx = NewComparison_procedure_exprContext(p, NewProcedure_exprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_procedure_expr)
				p.SetState(951)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(952)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&260145152) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(953)
					p.procedure_expr(6)
				}

			case 2:
				localctx = NewProcedure_expr_arithmeticContext(p, NewProcedure_exprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_procedure_expr)
				p.SetState(954)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(955)
					p.Match(KuneiformParserCONCAT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(956)
					p.procedure_expr(4)
				}

			case 3:
				localctx = NewProcedure_expr_arithmeticContext(p, NewProcedure_exprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_procedure_expr)
				p.SetState(957)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(958)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4734976) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(959)
					p.procedure_expr(3)
				}

			case 4:
				localctx = NewProcedure_expr_arithmeticContext(p, NewProcedure_exprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_procedure_expr)
				p.SetState(960)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(961)
					_la = p.GetTokenStream().LA(1)

					if !(_la == KuneiformParserPLUS || _la == KuneiformParserMINUS) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(962)
					p.procedure_expr(2)
				}

			case 5:
				localctx = NewArray_access_procedure_exprContext(p, NewProcedure_exprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_procedure_expr)
				p.SetState(963)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(964)
					p.Match(KuneiformParserLBRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(965)
					p.procedure_expr(0)
				}
				{
					p.SetState(966)
					p.Match(KuneiformParserRBRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(968)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 132, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(967)
						p.Type_cast()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case 6:
				localctx = NewField_access_procedure_exprContext(p, NewProcedure_exprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_procedure_expr)
				p.SetState(970)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(971)
					p.Match(KuneiformParserPERIOD)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(972)
					p.Match(KuneiformParserIDENTIFIER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(974)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(973)
						p.Type_cast()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(980)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedure_expr_listContext is an interface to support dynamic dispatch.
type IProcedure_expr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllProcedure_expr() []IProcedure_exprContext
	Procedure_expr(i int) IProcedure_exprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsProcedure_expr_listContext differentiates from other interfaces.
	IsProcedure_expr_listContext()
}

type Procedure_expr_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedure_expr_listContext() *Procedure_expr_listContext {
	var p = new(Procedure_expr_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_procedure_expr_list
	return p
}

func InitEmptyProcedure_expr_listContext(p *Procedure_expr_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_procedure_expr_list
}

func (*Procedure_expr_listContext) IsProcedure_expr_listContext() {}

func NewProcedure_expr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedure_expr_listContext {
	var p = new(Procedure_expr_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_procedure_expr_list

	return p
}

func (s *Procedure_expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedure_expr_listContext) AllProcedure_expr() []IProcedure_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedure_exprContext); ok {
			len++
		}
	}

	tst := make([]IProcedure_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedure_exprContext); ok {
			tst[i] = t.(IProcedure_exprContext)
			i++
		}
	}

	return tst
}

func (s *Procedure_expr_listContext) Procedure_expr(i int) IProcedure_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_exprContext)
}

func (s *Procedure_expr_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Procedure_expr_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Procedure_expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedure_expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedure_expr_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitProcedure_expr_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Procedure_expr_list() (localctx IProcedure_expr_listContext) {
	localctx = NewProcedure_expr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, KuneiformParserRULE_procedure_expr_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(981)
		p.procedure_expr(0)
	}
	p.SetState(986)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCOMMA {
		{
			p.SetState(982)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(983)
			p.procedure_expr(0)
		}

		p.SetState(988)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CopyAll(ctx *StatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Stmt_ifContext struct {
	StatementContext
}

func NewStmt_ifContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Stmt_ifContext {
	var p = new(Stmt_ifContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *Stmt_ifContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_ifContext) IF() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIF, 0)
}

func (s *Stmt_ifContext) AllIf_then_block() []IIf_then_blockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIf_then_blockContext); ok {
			len++
		}
	}

	tst := make([]IIf_then_blockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIf_then_blockContext); ok {
			tst[i] = t.(IIf_then_blockContext)
			i++
		}
	}

	return tst
}

func (s *Stmt_ifContext) If_then_block(i int) IIf_then_blockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_then_blockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_then_blockContext)
}

func (s *Stmt_ifContext) AllELSEIF() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserELSEIF)
}

func (s *Stmt_ifContext) ELSEIF(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserELSEIF, i)
}

func (s *Stmt_ifContext) ELSE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserELSE, 0)
}

func (s *Stmt_ifContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACE, 0)
}

func (s *Stmt_ifContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACE, 0)
}

func (s *Stmt_ifContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *Stmt_ifContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Stmt_ifContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitStmt_if(s)

	default:
		return t.VisitChildren(s)
	}
}

type Stmt_breakContext struct {
	StatementContext
}

func NewStmt_breakContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Stmt_breakContext {
	var p = new(Stmt_breakContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *Stmt_breakContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_breakContext) BREAK() antlr.TerminalNode {
	return s.GetToken(KuneiformParserBREAK, 0)
}

func (s *Stmt_breakContext) SCOL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, 0)
}

func (s *Stmt_breakContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitStmt_break(s)

	default:
		return t.VisitChildren(s)
	}
}

type Stmt_variable_assignment_with_declarationContext struct {
	StatementContext
}

func NewStmt_variable_assignment_with_declarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Stmt_variable_assignment_with_declarationContext {
	var p = new(Stmt_variable_assignment_with_declarationContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *Stmt_variable_assignment_with_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_variable_assignment_with_declarationContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserVARIABLE, 0)
}

func (s *Stmt_variable_assignment_with_declarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserASSIGN, 0)
}

func (s *Stmt_variable_assignment_with_declarationContext) Procedure_expr() IProcedure_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_exprContext)
}

func (s *Stmt_variable_assignment_with_declarationContext) SCOL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, 0)
}

func (s *Stmt_variable_assignment_with_declarationContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Stmt_variable_assignment_with_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitStmt_variable_assignment_with_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

type Stmt_variable_declarationContext struct {
	StatementContext
}

func NewStmt_variable_declarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Stmt_variable_declarationContext {
	var p = new(Stmt_variable_declarationContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *Stmt_variable_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_variable_declarationContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserVARIABLE, 0)
}

func (s *Stmt_variable_declarationContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Stmt_variable_declarationContext) SCOL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, 0)
}

func (s *Stmt_variable_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitStmt_variable_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

type Stmt_return_nextContext struct {
	StatementContext
}

func NewStmt_return_nextContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Stmt_return_nextContext {
	var p = new(Stmt_return_nextContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *Stmt_return_nextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_return_nextContext) RETURN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRETURN, 0)
}

func (s *Stmt_return_nextContext) NEXT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNEXT, 0)
}

func (s *Stmt_return_nextContext) Procedure_expr_list() IProcedure_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_expr_listContext)
}

func (s *Stmt_return_nextContext) SCOL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, 0)
}

func (s *Stmt_return_nextContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitStmt_return_next(s)

	default:
		return t.VisitChildren(s)
	}
}

type Stmt_for_loopContext struct {
	StatementContext
	receiver        antlr.Token
	target_variable IVariableContext
}

func NewStmt_for_loopContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Stmt_for_loopContext {
	var p = new(Stmt_for_loopContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *Stmt_for_loopContext) GetReceiver() antlr.Token { return s.receiver }

func (s *Stmt_for_loopContext) SetReceiver(v antlr.Token) { s.receiver = v }

func (s *Stmt_for_loopContext) GetTarget_variable() IVariableContext { return s.target_variable }

func (s *Stmt_for_loopContext) SetTarget_variable(v IVariableContext) { s.target_variable = v }

func (s *Stmt_for_loopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_for_loopContext) FOR() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFOR, 0)
}

func (s *Stmt_for_loopContext) IN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIN, 0)
}

func (s *Stmt_for_loopContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACE, 0)
}

func (s *Stmt_for_loopContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACE, 0)
}

func (s *Stmt_for_loopContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserVARIABLE, 0)
}

func (s *Stmt_for_loopContext) Range_() IRangeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeContext)
}

func (s *Stmt_for_loopContext) Sql_statement() ISql_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_statementContext)
}

func (s *Stmt_for_loopContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Stmt_for_loopContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *Stmt_for_loopContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Stmt_for_loopContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitStmt_for_loop(s)

	default:
		return t.VisitChildren(s)
	}
}

type Stmt_returnContext struct {
	StatementContext
}

func NewStmt_returnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Stmt_returnContext {
	var p = new(Stmt_returnContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *Stmt_returnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_returnContext) RETURN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRETURN, 0)
}

func (s *Stmt_returnContext) SCOL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, 0)
}

func (s *Stmt_returnContext) Procedure_expr_list() IProcedure_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_expr_listContext)
}

func (s *Stmt_returnContext) Sql_statement() ISql_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_statementContext)
}

func (s *Stmt_returnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitStmt_return(s)

	default:
		return t.VisitChildren(s)
	}
}

type Stmt_procedure_callContext struct {
	StatementContext
}

func NewStmt_procedure_callContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Stmt_procedure_callContext {
	var p = new(Stmt_procedure_callContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *Stmt_procedure_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_procedure_callContext) Procedure_function_call() IProcedure_function_callContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_function_callContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_function_callContext)
}

func (s *Stmt_procedure_callContext) SCOL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, 0)
}

func (s *Stmt_procedure_callContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserASSIGN, 0)
}

func (s *Stmt_procedure_callContext) AllVariable_or_underscore() []IVariable_or_underscoreContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariable_or_underscoreContext); ok {
			len++
		}
	}

	tst := make([]IVariable_or_underscoreContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariable_or_underscoreContext); ok {
			tst[i] = t.(IVariable_or_underscoreContext)
			i++
		}
	}

	return tst
}

func (s *Stmt_procedure_callContext) Variable_or_underscore(i int) IVariable_or_underscoreContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariable_or_underscoreContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariable_or_underscoreContext)
}

func (s *Stmt_procedure_callContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Stmt_procedure_callContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Stmt_procedure_callContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitStmt_procedure_call(s)

	default:
		return t.VisitChildren(s)
	}
}

type Stmt_variable_assignmentContext struct {
	StatementContext
}

func NewStmt_variable_assignmentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Stmt_variable_assignmentContext {
	var p = new(Stmt_variable_assignmentContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *Stmt_variable_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_variable_assignmentContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserVARIABLE, 0)
}

func (s *Stmt_variable_assignmentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserASSIGN, 0)
}

func (s *Stmt_variable_assignmentContext) Procedure_expr() IProcedure_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_exprContext)
}

func (s *Stmt_variable_assignmentContext) SCOL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, 0)
}

func (s *Stmt_variable_assignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitStmt_variable_assignment(s)

	default:
		return t.VisitChildren(s)
	}
}

type Stmt_sqlContext struct {
	StatementContext
}

func NewStmt_sqlContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Stmt_sqlContext {
	var p = new(Stmt_sqlContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *Stmt_sqlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_sqlContext) Sql_statement() ISql_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_statementContext)
}

func (s *Stmt_sqlContext) SCOL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, 0)
}

func (s *Stmt_sqlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitStmt_sql(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, KuneiformParserRULE_statement)
	var _la int

	p.SetState(1075)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStmt_variable_declarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(989)
			p.Match(KuneiformParserVARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(990)
			p.Type_()
		}
		{
			p.SetState(991)
			p.Match(KuneiformParserSCOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewStmt_procedure_callContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1003)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserUNDERSCORE || _la == KuneiformParserVARIABLE {
			{
				p.SetState(993)
				p.Variable_or_underscore()
			}

			p.SetState(998)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KuneiformParserCOMMA {
				{
					p.SetState(994)
					p.Match(KuneiformParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				{
					p.SetState(995)
					p.Variable_or_underscore()
				}

				p.SetState(1000)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1001)
				p.Match(KuneiformParserASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1005)
			p.Procedure_function_call()
		}
		{
			p.SetState(1006)
			p.Match(KuneiformParserSCOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewStmt_variable_assignmentContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1008)
			p.Match(KuneiformParserVARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1009)
			p.Match(KuneiformParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1010)
			p.procedure_expr(0)
		}
		{
			p.SetState(1011)
			p.Match(KuneiformParserSCOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewStmt_variable_assignment_with_declarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1013)
			p.Match(KuneiformParserVARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1015)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserIDENTIFIER {
			{
				p.SetState(1014)
				p.Type_()
			}

		}
		{
			p.SetState(1017)
			p.Match(KuneiformParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1018)
			p.procedure_expr(0)
		}
		{
			p.SetState(1019)
			p.Match(KuneiformParserSCOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewStmt_for_loopContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1021)
			p.Match(KuneiformParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1022)

			var _m = p.Match(KuneiformParserVARIABLE)

			localctx.(*Stmt_for_loopContext).receiver = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1023)
			p.Match(KuneiformParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1027)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 140, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1024)
				p.Range_()
			}

		case 2:
			{
				p.SetState(1025)

				var _x = p.Variable()

				localctx.(*Stmt_for_loopContext).target_variable = _x
			}

		case 3:
			{
				p.SetState(1026)
				p.Sql_statement()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(1029)
			p.Match(KuneiformParserLBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1033)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&216172782650654720) != 0) || ((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&13194567353857) != 0) {
			{
				p.SetState(1030)
				p.Statement()
			}

			p.SetState(1035)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1036)
			p.Match(KuneiformParserRBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewStmt_ifContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1038)
			p.Match(KuneiformParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1039)
			p.If_then_block()
		}
		p.SetState(1044)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KuneiformParserELSEIF {
			{
				p.SetState(1040)
				p.Match(KuneiformParserELSEIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1041)
				p.If_then_block()
			}

			p.SetState(1046)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1056)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserELSE {
			{
				p.SetState(1047)
				p.Match(KuneiformParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1048)
				p.Match(KuneiformParserLBRACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1052)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&216172782650654720) != 0) || ((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&13194567353857) != 0) {
				{
					p.SetState(1049)
					p.Statement()
				}

				p.SetState(1054)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1055)
				p.Match(KuneiformParserRBRACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 7:
		localctx = NewStmt_sqlContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1058)
			p.Sql_statement()
		}
		{
			p.SetState(1059)
			p.Match(KuneiformParserSCOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewStmt_breakContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1061)
			p.Match(KuneiformParserBREAK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1062)
			p.Match(KuneiformParserSCOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewStmt_returnContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1063)
			p.Match(KuneiformParserRETURN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1066)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case KuneiformParserLBRACKET, KuneiformParserLPAREN, KuneiformParserEXCL, KuneiformParserPLUS, KuneiformParserMINUS, KuneiformParserNULL, KuneiformParserSTRING_, KuneiformParserTRUE, KuneiformParserFALSE, KuneiformParserDIGITS_, KuneiformParserBINARY_, KuneiformParserIDENTIFIER, KuneiformParserVARIABLE, KuneiformParserCONTEXTUAL_VARIABLE:
			{
				p.SetState(1064)
				p.Procedure_expr_list()
			}

		case KuneiformParserDELETE, KuneiformParserUPDATE, KuneiformParserWITH, KuneiformParserSELECT, KuneiformParserINSERT:
			{
				p.SetState(1065)
				p.Sql_statement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(1068)
			p.Match(KuneiformParserSCOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewStmt_return_nextContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1070)
			p.Match(KuneiformParserRETURN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1071)
			p.Match(KuneiformParserNEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1072)
			p.Procedure_expr_list()
		}
		{
			p.SetState(1073)
			p.Match(KuneiformParserSCOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariable_or_underscoreContext is an interface to support dynamic dispatch.
type IVariable_or_underscoreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VARIABLE() antlr.TerminalNode
	UNDERSCORE() antlr.TerminalNode

	// IsVariable_or_underscoreContext differentiates from other interfaces.
	IsVariable_or_underscoreContext()
}

type Variable_or_underscoreContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_or_underscoreContext() *Variable_or_underscoreContext {
	var p = new(Variable_or_underscoreContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_variable_or_underscore
	return p
}

func InitEmptyVariable_or_underscoreContext(p *Variable_or_underscoreContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_variable_or_underscore
}

func (*Variable_or_underscoreContext) IsVariable_or_underscoreContext() {}

func NewVariable_or_underscoreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_or_underscoreContext {
	var p = new(Variable_or_underscoreContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_variable_or_underscore

	return p
}

func (s *Variable_or_underscoreContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_or_underscoreContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserVARIABLE, 0)
}

func (s *Variable_or_underscoreContext) UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUNDERSCORE, 0)
}

func (s *Variable_or_underscoreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_or_underscoreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_or_underscoreContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitVariable_or_underscore(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Variable_or_underscore() (localctx IVariable_or_underscoreContext) {
	localctx = NewVariable_or_underscoreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, KuneiformParserRULE_variable_or_underscore)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1077)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KuneiformParserUNDERSCORE || _la == KuneiformParserVARIABLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedure_function_callContext is an interface to support dynamic dispatch.
type IProcedure_function_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsProcedure_function_callContext differentiates from other interfaces.
	IsProcedure_function_callContext()
}

type Procedure_function_callContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedure_function_callContext() *Procedure_function_callContext {
	var p = new(Procedure_function_callContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_procedure_function_call
	return p
}

func InitEmptyProcedure_function_callContext(p *Procedure_function_callContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_procedure_function_call
}

func (*Procedure_function_callContext) IsProcedure_function_callContext() {}

func NewProcedure_function_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedure_function_callContext {
	var p = new(Procedure_function_callContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_procedure_function_call

	return p
}

func (s *Procedure_function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedure_function_callContext) CopyAll(ctx *Procedure_function_callContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *Procedure_function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedure_function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Foreign_call_procedureContext struct {
	Procedure_function_callContext
	dbid      IProcedure_exprContext
	procedure IProcedure_exprContext
}

func NewForeign_call_procedureContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Foreign_call_procedureContext {
	var p = new(Foreign_call_procedureContext)

	InitEmptyProcedure_function_callContext(&p.Procedure_function_callContext)
	p.parser = parser
	p.CopyAll(ctx.(*Procedure_function_callContext))

	return p
}

func (s *Foreign_call_procedureContext) GetDbid() IProcedure_exprContext { return s.dbid }

func (s *Foreign_call_procedureContext) GetProcedure() IProcedure_exprContext { return s.procedure }

func (s *Foreign_call_procedureContext) SetDbid(v IProcedure_exprContext) { s.dbid = v }

func (s *Foreign_call_procedureContext) SetProcedure(v IProcedure_exprContext) { s.procedure = v }

func (s *Foreign_call_procedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Foreign_call_procedureContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *Foreign_call_procedureContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACKET, 0)
}

func (s *Foreign_call_procedureContext) COMMA() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, 0)
}

func (s *Foreign_call_procedureContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACKET, 0)
}

func (s *Foreign_call_procedureContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Foreign_call_procedureContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Foreign_call_procedureContext) AllProcedure_expr() []IProcedure_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedure_exprContext); ok {
			len++
		}
	}

	tst := make([]IProcedure_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedure_exprContext); ok {
			tst[i] = t.(IProcedure_exprContext)
			i++
		}
	}

	return tst
}

func (s *Foreign_call_procedureContext) Procedure_expr(i int) IProcedure_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_exprContext)
}

func (s *Foreign_call_procedureContext) Procedure_expr_list() IProcedure_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_expr_listContext)
}

func (s *Foreign_call_procedureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitForeign_call_procedure(s)

	default:
		return t.VisitChildren(s)
	}
}

type Normal_call_procedureContext struct {
	Procedure_function_callContext
}

func NewNormal_call_procedureContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Normal_call_procedureContext {
	var p = new(Normal_call_procedureContext)

	InitEmptyProcedure_function_callContext(&p.Procedure_function_callContext)
	p.parser = parser
	p.CopyAll(ctx.(*Procedure_function_callContext))

	return p
}

func (s *Normal_call_procedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Normal_call_procedureContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *Normal_call_procedureContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Normal_call_procedureContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Normal_call_procedureContext) Procedure_expr_list() IProcedure_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_expr_listContext)
}

func (s *Normal_call_procedureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitNormal_call_procedure(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Procedure_function_call() (localctx IProcedure_function_callContext) {
	localctx = NewProcedure_function_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, KuneiformParserRULE_procedure_function_call)
	var _la int

	p.SetState(1097)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 149, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNormal_call_procedureContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1079)
			p.Match(KuneiformParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1080)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1082)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&36028797022111880) != 0) || ((int64((_la-117)) & ^0x3f) == 0 && ((int64(1)<<(_la-117))&28703) != 0) {
			{
				p.SetState(1081)
				p.Procedure_expr_list()
			}

		}
		{
			p.SetState(1084)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewForeign_call_procedureContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1085)
			p.Match(KuneiformParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1086)
			p.Match(KuneiformParserLBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1087)

			var _x = p.procedure_expr(0)

			localctx.(*Foreign_call_procedureContext).dbid = _x
		}
		{
			p.SetState(1088)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1089)

			var _x = p.procedure_expr(0)

			localctx.(*Foreign_call_procedureContext).procedure = _x
		}
		{
			p.SetState(1090)
			p.Match(KuneiformParserRBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1091)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1093)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&36028797022111880) != 0) || ((int64((_la-117)) & ^0x3f) == 0 && ((int64(1)<<(_la-117))&28703) != 0) {
			{
				p.SetState(1092)
				p.Procedure_expr_list()
			}

		}
		{
			p.SetState(1095)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIf_then_blockContext is an interface to support dynamic dispatch.
type IIf_then_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Procedure_expr() IProcedure_exprContext
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsIf_then_blockContext differentiates from other interfaces.
	IsIf_then_blockContext()
}

type If_then_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_then_blockContext() *If_then_blockContext {
	var p = new(If_then_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_if_then_block
	return p
}

func InitEmptyIf_then_blockContext(p *If_then_blockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_if_then_block
}

func (*If_then_blockContext) IsIf_then_blockContext() {}

func NewIf_then_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_then_blockContext {
	var p = new(If_then_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_if_then_block

	return p
}

func (s *If_then_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *If_then_blockContext) Procedure_expr() IProcedure_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_exprContext)
}

func (s *If_then_blockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACE, 0)
}

func (s *If_then_blockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACE, 0)
}

func (s *If_then_blockContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *If_then_blockContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *If_then_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_then_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_then_blockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitIf_then_block(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) If_then_block() (localctx IIf_then_blockContext) {
	localctx = NewIf_then_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, KuneiformParserRULE_if_then_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1099)
		p.procedure_expr(0)
	}
	{
		p.SetState(1100)
		p.Match(KuneiformParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1104)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&216172782650654720) != 0) || ((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&13194567353857) != 0) {
		{
			p.SetState(1101)
			p.Statement()
		}

		p.SetState(1106)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1107)
		p.Match(KuneiformParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeContext is an interface to support dynamic dispatch.
type IRangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllProcedure_expr() []IProcedure_exprContext
	Procedure_expr(i int) IProcedure_exprContext
	RANGE() antlr.TerminalNode

	// IsRangeContext differentiates from other interfaces.
	IsRangeContext()
}

type RangeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeContext() *RangeContext {
	var p = new(RangeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_range
	return p
}

func InitEmptyRangeContext(p *RangeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_range
}

func (*RangeContext) IsRangeContext() {}

func NewRangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeContext {
	var p = new(RangeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_range

	return p
}

func (s *RangeContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeContext) AllProcedure_expr() []IProcedure_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedure_exprContext); ok {
			len++
		}
	}

	tst := make([]IProcedure_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedure_exprContext); ok {
			tst[i] = t.(IProcedure_exprContext)
			i++
		}
	}

	return tst
}

func (s *RangeContext) Procedure_expr(i int) IProcedure_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedure_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedure_exprContext)
}

func (s *RangeContext) RANGE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRANGE, 0)
}

func (s *RangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitRange(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Range_() (localctx IRangeContext) {
	localctx = NewRangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, KuneiformParserRULE_range)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1109)
		p.procedure_expr(0)
	}
	{
		p.SetState(1110)
		p.Match(KuneiformParserRANGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1111)
		p.procedure_expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *KuneiformParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 40:
		var t *Sql_exprContext = nil
		if localctx != nil {
			t = localctx.(*Sql_exprContext)
		}
		return p.Sql_expr_Sempred(t, predIndex)

	case 46:
		var t *Procedure_exprContext = nil
		if localctx != nil {
			t = localctx.(*Procedure_exprContext)
		}
		return p.Procedure_expr_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *KuneiformParser) Sql_expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 8)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *KuneiformParser) Procedure_expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 13:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 6)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
