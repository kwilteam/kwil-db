// Code generated from KuneiformParser.g4 by ANTLR 4.13.1. DO NOT EDIT.

package gen // KuneiformParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type KuneiformParser struct {
	*antlr.BaseParser
}

var KuneiformParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func kuneiformparserParserInit() {
	staticData := &KuneiformParserParserStaticData
	staticData.LiteralNames = []string{
		"", "'{'", "'}'", "'['", "']'", "':'", "';'", "'('", "')'", "','", "'@'",
		"'!'", "'.'", "'||'", "'*'", "'='", "'=='", "'#'", "'$'", "'%'", "'+'",
		"'-'", "'/'", "'^'", "", "'<'", "'<='", "'>'", "'>='", "'::'", "'_'",
		"':='", "'..'", "'\"'", "'use'", "'unuse'", "'table'", "'action'", "'create'",
		"'alter'", "'column'", "'add'", "'drop'", "'rename'", "'to'", "'constraint'",
		"'check'", "'foreign'", "'primary'", "'key'", "'on'", "'do'", "'unique'",
		"'cascade'", "'restrict'", "'set'", "'default'", "'null'", "'delete'",
		"'update'", "'references'", "'ref'", "'not'", "'index'", "'and'", "'or'",
		"'like'", "'ilike'", "'in'", "'between'", "'is'", "'exists'", "'all'",
		"'any'", "'join'", "'left'", "'right'", "'inner'", "'as'", "'asc'",
		"'desc'", "'limit'", "'offset'", "'order'", "'by'", "'group'", "'having'",
		"'returns'", "'no'", "'with'", "'case'", "'when'", "'then'", "'end'",
		"'distinct'", "'from'", "'where'", "'collate'", "'select'", "'insert'",
		"'values'", "'full'", "'union'", "'intersect'", "'except'", "'nulls'",
		"'first'", "'last'", "'returning'", "'into'", "'conflict'", "'nothing'",
		"'for'", "'if'", "'elseif'", "'else'", "'break'", "'continue'", "'return'",
		"'next'", "'over'", "'partition'", "'window'", "'filter'", "'recursive'",
		"'grant'", "'granted'", "'revoke'", "'role'", "'replace'", "'array'",
		"'namespace'", "'roles'", "'call'", "", "'true'", "'false'", "", "",
		"", "'on_update'", "'on_delete'", "'set_default'", "'set_null'", "'no_action'",
	}
	staticData.SymbolicNames = []string{
		"", "LBRACE", "RBRACE", "LBRACKET", "RBRACKET", "COL", "SCOL", "LPAREN",
		"RPAREN", "COMMA", "AT", "EXCL", "PERIOD", "CONCAT", "STAR", "EQUALS",
		"EQUATE", "HASH", "DOLLAR", "MOD", "PLUS", "MINUS", "DIV", "EXP", "NEQ",
		"LT", "LTE", "GT", "GTE", "TYPE_CAST", "UNDERSCORE", "ASSIGN", "RANGE",
		"DOUBLE_QUOTE", "USE", "UNUSE", "TABLE", "ACTION", "CREATE", "ALTER",
		"COLUMN", "ADD", "DROP", "RENAME", "TO", "CONSTRAINT", "CHECK", "FOREIGN",
		"PRIMARY", "KEY", "ON", "DO", "UNIQUE", "CASCADE", "RESTRICT", "SET",
		"DEFAULT", "NULL", "DELETE", "UPDATE", "REFERENCES", "REF", "NOT", "INDEX",
		"AND", "OR", "LIKE", "ILIKE", "IN", "BETWEEN", "IS", "EXISTS", "ALL",
		"ANY", "JOIN", "LEFT", "RIGHT", "INNER", "AS", "ASC", "DESC", "LIMIT",
		"OFFSET", "ORDER", "BY", "GROUP", "HAVING", "RETURNS", "NO", "WITH",
		"CASE", "WHEN", "THEN", "END", "DISTINCT", "FROM", "WHERE", "COLLATE",
		"SELECT", "INSERT", "VALUES", "FULL", "UNION", "INTERSECT", "EXCEPT",
		"NULLS", "FIRST", "LAST", "RETURNING", "INTO", "CONFLICT", "NOTHING",
		"FOR", "IF", "ELSEIF", "ELSE", "BREAK", "CONTINUE", "RETURN", "NEXT",
		"OVER", "PARTITION", "WINDOW", "FILTER", "RECURSIVE", "GRANT", "GRANTED",
		"REVOKE", "ROLE", "REPLACE", "ARRAY", "NAMESPACE", "ROLES", "CALL",
		"STRING_", "TRUE", "FALSE", "DIGITS_", "BINARY_", "LEGACY_FOREIGN_KEY",
		"LEGACY_ON_UPDATE", "LEGACY_ON_DELETE", "LEGACY_SET_DEFAULT", "LEGACY_SET_NULL",
		"LEGACY_NO_ACTION", "IDENTIFIER", "VARIABLE", "CONTEXTUAL_VARIABLE",
		"HASH_IDENTIFIER", "WS", "BLOCK_COMMENT", "LINE_COMMENT", "SQL_COMMENT",
	}
	staticData.RuleNames = []string{
		"entry", "statement", "literal", "identifier", "allowed_identifier",
		"identifier_list", "type", "type_cast", "variable", "table_column_def",
		"type_list", "named_type_list", "inline_constraint", "fk_action", "fk_constraint",
		"action_return", "sql_statement", "common_table_expression", "create_table_statement",
		"table_constraint_def", "opt_drop_behavior", "drop_table_statement",
		"alter_table_statement", "alter_table_action", "create_index_statement",
		"drop_index_statement", "create_role_statement", "drop_role_statement",
		"grant_statement", "revoke_statement", "privilege_list", "privilege",
		"create_action_statement", "drop_action_statement", "use_extension_statement",
		"unuse_extension_statement", "create_namespace_statement", "drop_namespace_statement",
		"select_statement", "compound_operator", "ordering_term", "select_core",
		"relation", "join", "result_column", "update_statement", "update_set_clause",
		"insert_statement", "upsert_clause", "delete_statement", "sql_expr",
		"window", "when_then_clause", "sql_expr_list", "sql_function_call",
		"action_expr", "action_expr_list", "action_statement", "variable_or_underscore",
		"action_function_call", "if_then_block", "range",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 152, 1349, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 1, 0, 1, 0,
		1, 0, 5, 0, 128, 8, 0, 10, 0, 12, 0, 131, 9, 0, 1, 0, 3, 0, 134, 8, 0,
		1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 142, 8, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 3, 1, 160, 8, 1, 1, 2, 1, 2, 3, 2, 164, 8, 2, 1, 2, 1, 2, 3, 2, 168,
		8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 176, 8, 2, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 3, 3, 183, 8, 3, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 5, 5,
		190, 8, 5, 10, 5, 12, 5, 193, 9, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6,
		200, 8, 6, 1, 6, 3, 6, 203, 8, 6, 1, 6, 1, 6, 3, 6, 207, 8, 6, 1, 7, 1,
		7, 1, 7, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 5, 9, 217, 8, 9, 10, 9, 12, 9, 220,
		9, 9, 1, 10, 1, 10, 1, 10, 5, 10, 225, 8, 10, 10, 10, 12, 10, 228, 9, 10,
		1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 5, 11, 236, 8, 11, 10, 11, 12,
		11, 239, 9, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 254, 8, 12, 1, 13, 1, 13, 1,
		13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 266, 8, 13,
		1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 272, 8, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 3, 14, 280, 8, 14, 3, 14, 282, 8, 14, 1, 15, 1, 15, 3,
		15, 286, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15,
		3, 15, 296, 8, 15, 1, 16, 1, 16, 3, 16, 300, 8, 16, 1, 16, 1, 16, 1, 16,
		5, 16, 305, 8, 16, 10, 16, 12, 16, 308, 9, 16, 3, 16, 310, 8, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 3, 16, 316, 8, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1,
		17, 5, 17, 323, 8, 17, 10, 17, 12, 17, 326, 9, 17, 3, 17, 328, 8, 17, 1,
		17, 3, 17, 331, 8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 18, 1, 18,
		1, 18, 1, 18, 1, 18, 3, 18, 343, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3,
		18, 349, 8, 18, 1, 18, 1, 18, 1, 18, 3, 18, 354, 8, 18, 5, 18, 356, 8,
		18, 10, 18, 12, 18, 359, 9, 18, 1, 18, 1, 18, 1, 19, 1, 19, 3, 19, 365,
		8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19,
		1, 19, 1, 19, 1, 19, 3, 19, 390, 8, 19, 1, 20, 1, 20, 1, 21, 1, 21, 1,
		21, 1, 21, 3, 21, 398, 8, 21, 1, 21, 1, 21, 3, 21, 402, 8, 21, 1, 22, 1,
		22, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23,
		1, 23, 3, 23, 417, 8, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1,
		23, 3, 23, 426, 8, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23,
		1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1,
		23, 1, 23, 1, 23, 1, 23, 1, 23, 3, 23, 450, 8, 23, 1, 24, 1, 24, 3, 24,
		454, 8, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 460, 8, 24, 1, 24, 3, 24,
		463, 8, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1,
		25, 1, 25, 3, 25, 475, 8, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 26,
		1, 26, 3, 26, 484, 8, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 27, 3,
		27, 492, 8, 27, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 500, 8,
		28, 1, 28, 1, 28, 3, 28, 504, 8, 28, 1, 28, 1, 28, 3, 28, 508, 8, 28, 1,
		28, 1, 28, 1, 28, 1, 28, 3, 28, 514, 8, 28, 1, 29, 1, 29, 1, 29, 3, 29,
		519, 8, 29, 1, 29, 1, 29, 3, 29, 523, 8, 29, 1, 29, 1, 29, 3, 29, 527,
		8, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 533, 8, 29, 1, 30, 1, 30, 1,
		30, 5, 30, 538, 8, 30, 10, 30, 12, 30, 541, 9, 30, 1, 31, 1, 31, 1, 32,
		1, 32, 1, 32, 3, 32, 548, 8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 554,
		8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 5, 32, 563, 8,
		32, 10, 32, 12, 32, 566, 9, 32, 3, 32, 568, 8, 32, 1, 32, 1, 32, 5, 32,
		572, 8, 32, 10, 32, 12, 32, 575, 9, 32, 1, 32, 3, 32, 578, 8, 32, 1, 32,
		1, 32, 5, 32, 582, 8, 32, 10, 32, 12, 32, 585, 9, 32, 1, 32, 1, 32, 1,
		33, 1, 33, 1, 33, 1, 33, 3, 33, 593, 8, 33, 1, 33, 1, 33, 1, 34, 1, 34,
		1, 34, 1, 34, 3, 34, 601, 8, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1,
		34, 1, 34, 1, 34, 1, 34, 1, 34, 5, 34, 613, 8, 34, 10, 34, 12, 34, 616,
		9, 34, 3, 34, 618, 8, 34, 1, 34, 3, 34, 621, 8, 34, 1, 34, 1, 34, 1, 34,
		1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 630, 8, 35, 1, 36, 1, 36, 1, 36, 1,
		36, 1, 36, 3, 36, 637, 8, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 37,
		3, 37, 645, 8, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 1, 38, 5, 38, 653,
		8, 38, 10, 38, 12, 38, 656, 9, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 5,
		38, 663, 8, 38, 10, 38, 12, 38, 666, 9, 38, 3, 38, 668, 8, 38, 1, 38, 1,
		38, 3, 38, 672, 8, 38, 1, 38, 1, 38, 3, 38, 676, 8, 38, 1, 39, 1, 39, 3,
		39, 680, 8, 39, 1, 39, 1, 39, 3, 39, 684, 8, 39, 1, 40, 1, 40, 3, 40, 688,
		8, 40, 1, 40, 1, 40, 3, 40, 692, 8, 40, 1, 41, 1, 41, 3, 41, 696, 8, 41,
		1, 41, 1, 41, 1, 41, 5, 41, 701, 8, 41, 10, 41, 12, 41, 704, 9, 41, 1,
		41, 1, 41, 1, 41, 5, 41, 709, 8, 41, 10, 41, 12, 41, 712, 9, 41, 3, 41,
		714, 8, 41, 1, 41, 1, 41, 3, 41, 718, 8, 41, 1, 41, 1, 41, 1, 41, 1, 41,
		1, 41, 3, 41, 725, 8, 41, 3, 41, 727, 8, 41, 1, 41, 1, 41, 1, 41, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 5, 41, 738, 8, 41, 10, 41, 12, 41, 741,
		9, 41, 3, 41, 743, 8, 41, 1, 42, 1, 42, 1, 42, 3, 42, 748, 8, 42, 1, 42,
		1, 42, 3, 42, 752, 8, 42, 1, 42, 3, 42, 755, 8, 42, 1, 42, 1, 42, 1, 42,
		1, 42, 3, 42, 761, 8, 42, 1, 42, 3, 42, 764, 8, 42, 3, 42, 766, 8, 42,
		1, 43, 3, 43, 769, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 44, 1,
		44, 3, 44, 778, 8, 44, 1, 44, 3, 44, 781, 8, 44, 1, 44, 1, 44, 1, 44, 3,
		44, 786, 8, 44, 1, 44, 3, 44, 789, 8, 44, 1, 45, 1, 45, 1, 45, 3, 45, 794,
		8, 45, 1, 45, 3, 45, 797, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 5, 45, 803,
		8, 45, 10, 45, 12, 45, 806, 9, 45, 1, 45, 1, 45, 1, 45, 5, 45, 811, 8,
		45, 10, 45, 12, 45, 814, 9, 45, 3, 45, 816, 8, 45, 1, 45, 1, 45, 3, 45,
		820, 8, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 1, 47, 3,
		47, 830, 8, 47, 1, 47, 3, 47, 833, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3,
		47, 839, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47,
		1, 47, 5, 47, 850, 8, 47, 10, 47, 12, 47, 853, 9, 47, 1, 47, 3, 47, 856,
		8, 47, 1, 47, 3, 47, 859, 8, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1,
		48, 1, 48, 3, 48, 868, 8, 48, 3, 48, 870, 8, 48, 1, 48, 1, 48, 1, 48, 1,
		48, 1, 48, 1, 48, 1, 48, 5, 48, 879, 8, 48, 10, 48, 12, 48, 882, 9, 48,
		1, 48, 1, 48, 3, 48, 886, 8, 48, 3, 48, 888, 8, 48, 1, 49, 1, 49, 1, 49,
		1, 49, 3, 49, 894, 8, 49, 1, 49, 3, 49, 897, 8, 49, 1, 49, 1, 49, 3, 49,
		901, 8, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 908, 8, 50, 1, 50,
		1, 50, 1, 50, 1, 50, 3, 50, 914, 8, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1,
		50, 1, 50, 1, 50, 3, 50, 923, 8, 50, 1, 50, 1, 50, 1, 50, 3, 50, 928, 8,
		50, 1, 50, 1, 50, 3, 50, 932, 8, 50, 1, 50, 1, 50, 3, 50, 936, 8, 50, 1,
		50, 1, 50, 1, 50, 3, 50, 941, 8, 50, 1, 50, 1, 50, 3, 50, 945, 8, 50, 1,
		50, 1, 50, 1, 50, 3, 50, 950, 8, 50, 1, 50, 1, 50, 3, 50, 954, 8, 50, 1,
		50, 1, 50, 3, 50, 958, 8, 50, 1, 50, 4, 50, 961, 8, 50, 11, 50, 12, 50,
		962, 1, 50, 1, 50, 3, 50, 967, 8, 50, 1, 50, 1, 50, 1, 50, 3, 50, 972,
		8, 50, 1, 50, 3, 50, 975, 8, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 981,
		8, 50, 1, 50, 1, 50, 3, 50, 985, 8, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1,
		50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50,
		1001, 8, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 1007, 8, 50, 1, 50, 1,
		50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50,
		1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 1027, 8, 50, 1, 50, 1,
		50, 1, 50, 1, 50, 3, 50, 1033, 8, 50, 1, 50, 1, 50, 3, 50, 1037, 8, 50,
		3, 50, 1039, 8, 50, 1, 50, 1, 50, 3, 50, 1043, 8, 50, 1, 50, 1, 50, 1,
		50, 1, 50, 1, 50, 3, 50, 1050, 8, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50,
		1056, 8, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 1063, 8, 50, 1,
		50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 1071, 8, 50, 5, 50, 1073,
		8, 50, 10, 50, 12, 50, 1076, 9, 50, 1, 51, 1, 51, 1, 51, 1, 51, 3, 51,
		1082, 8, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 5, 51, 1089, 8, 51, 10,
		51, 12, 51, 1092, 9, 51, 3, 51, 1094, 8, 51, 1, 51, 1, 51, 1, 52, 1, 52,
		1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 5, 53, 1106, 8, 53, 10, 53, 12,
		53, 1109, 9, 53, 1, 54, 1, 54, 1, 54, 3, 54, 1114, 8, 54, 1, 54, 1, 54,
		3, 54, 1118, 8, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3,
		55, 1127, 8, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 1133, 8, 55, 1, 55,
		1, 55, 3, 55, 1137, 8, 55, 1, 55, 1, 55, 3, 55, 1141, 8, 55, 1, 55, 3,
		55, 1144, 8, 55, 1, 55, 1, 55, 3, 55, 1148, 8, 55, 1, 55, 1, 55, 3, 55,
		1152, 8, 55, 1, 55, 1, 55, 3, 55, 1156, 8, 55, 1, 55, 1, 55, 1, 55, 1,
		55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55,
		1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1,
		55, 3, 55, 1183, 8, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 1189, 8, 55,
		1, 55, 1, 55, 3, 55, 1193, 8, 55, 3, 55, 1195, 8, 55, 1, 55, 1, 55, 3,
		55, 1199, 8, 55, 1, 55, 1, 55, 1, 55, 3, 55, 1204, 8, 55, 1, 55, 1, 55,
		1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 1212, 8, 55, 5, 55, 1214, 8, 55, 10,
		55, 12, 55, 1217, 9, 55, 1, 56, 1, 56, 1, 56, 5, 56, 1222, 8, 56, 10, 56,
		12, 56, 1225, 9, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 5,
		57, 1234, 8, 57, 10, 57, 12, 57, 1237, 9, 57, 1, 57, 1, 57, 3, 57, 1241,
		8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 1248, 8, 57, 1, 57, 1,
		57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 1260,
		8, 57, 1, 57, 3, 57, 1263, 8, 57, 1, 57, 1, 57, 5, 57, 1267, 8, 57, 10,
		57, 12, 57, 1270, 9, 57, 1, 57, 1, 57, 3, 57, 1274, 8, 57, 1, 57, 1, 57,
		1, 57, 1, 57, 1, 57, 3, 57, 1281, 8, 57, 1, 57, 5, 57, 1284, 8, 57, 10,
		57, 12, 57, 1287, 9, 57, 1, 57, 1, 57, 1, 57, 5, 57, 1292, 8, 57, 10, 57,
		12, 57, 1295, 9, 57, 1, 57, 3, 57, 1298, 8, 57, 1, 57, 3, 57, 1301, 8,
		57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 1311,
		8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 1319, 8, 57, 1,
		58, 1, 58, 1, 59, 1, 59, 1, 59, 3, 59, 1326, 8, 59, 1, 59, 1, 59, 1, 59,
		3, 59, 1331, 8, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 5, 60, 1338, 8,
		60, 10, 60, 12, 60, 1341, 9, 60, 1, 60, 1, 60, 1, 61, 1, 61, 1, 61, 1,
		61, 1, 61, 0, 2, 100, 110, 62, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22,
		24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58,
		60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94,
		96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 0,
		17, 1, 0, 20, 21, 1, 0, 135, 136, 14, 0, 34, 35, 37, 39, 41, 43, 46, 49,
		52, 52, 54, 54, 56, 56, 63, 63, 87, 87, 110, 110, 112, 118, 125, 129, 131,
		133, 145, 145, 1, 0, 146, 147, 1, 0, 58, 59, 1, 0, 53, 54, 6, 0, 34, 34,
		38, 39, 42, 42, 58, 59, 98, 99, 132, 133, 1, 0, 79, 80, 1, 0, 106, 107,
		2, 0, 75, 77, 101, 101, 3, 0, 14, 14, 19, 19, 22, 22, 1, 0, 66, 67, 2,
		0, 15, 16, 24, 28, 2, 0, 11, 11, 20, 21, 2, 0, 15, 15, 31, 31, 1, 0, 116,
		117, 2, 0, 30, 30, 146, 146, 1562, 0, 124, 1, 0, 0, 0, 2, 141, 1, 0, 0,
		0, 4, 175, 1, 0, 0, 0, 6, 182, 1, 0, 0, 0, 8, 184, 1, 0, 0, 0, 10, 186,
		1, 0, 0, 0, 12, 194, 1, 0, 0, 0, 14, 208, 1, 0, 0, 0, 16, 211, 1, 0, 0,
		0, 18, 213, 1, 0, 0, 0, 20, 221, 1, 0, 0, 0, 22, 229, 1, 0, 0, 0, 24, 253,
		1, 0, 0, 0, 26, 255, 1, 0, 0, 0, 28, 267, 1, 0, 0, 0, 30, 283, 1, 0, 0,
		0, 32, 309, 1, 0, 0, 0, 34, 317, 1, 0, 0, 0, 36, 337, 1, 0, 0, 0, 38, 364,
		1, 0, 0, 0, 40, 391, 1, 0, 0, 0, 42, 393, 1, 0, 0, 0, 44, 403, 1, 0, 0,
		0, 46, 449, 1, 0, 0, 0, 48, 451, 1, 0, 0, 0, 50, 470, 1, 0, 0, 0, 52, 478,
		1, 0, 0, 0, 54, 487, 1, 0, 0, 0, 56, 495, 1, 0, 0, 0, 58, 515, 1, 0, 0,
		0, 60, 534, 1, 0, 0, 0, 62, 542, 1, 0, 0, 0, 64, 544, 1, 0, 0, 0, 66, 588,
		1, 0, 0, 0, 68, 596, 1, 0, 0, 0, 70, 625, 1, 0, 0, 0, 72, 631, 1, 0, 0,
		0, 74, 640, 1, 0, 0, 0, 76, 648, 1, 0, 0, 0, 78, 683, 1, 0, 0, 0, 80, 685,
		1, 0, 0, 0, 82, 693, 1, 0, 0, 0, 84, 765, 1, 0, 0, 0, 86, 768, 1, 0, 0,
		0, 88, 788, 1, 0, 0, 0, 90, 790, 1, 0, 0, 0, 92, 821, 1, 0, 0, 0, 94, 825,
		1, 0, 0, 0, 96, 860, 1, 0, 0, 0, 98, 889, 1, 0, 0, 0, 100, 984, 1, 0, 0,
		0, 102, 1077, 1, 0, 0, 0, 104, 1097, 1, 0, 0, 0, 106, 1102, 1, 0, 0, 0,
		108, 1110, 1, 0, 0, 0, 110, 1155, 1, 0, 0, 0, 112, 1218, 1, 0, 0, 0, 114,
		1318, 1, 0, 0, 0, 116, 1320, 1, 0, 0, 0, 118, 1325, 1, 0, 0, 0, 120, 1334,
		1, 0, 0, 0, 122, 1344, 1, 0, 0, 0, 124, 129, 3, 2, 1, 0, 125, 126, 5, 6,
		0, 0, 126, 128, 3, 2, 1, 0, 127, 125, 1, 0, 0, 0, 128, 131, 1, 0, 0, 0,
		129, 127, 1, 0, 0, 0, 129, 130, 1, 0, 0, 0, 130, 133, 1, 0, 0, 0, 131,
		129, 1, 0, 0, 0, 132, 134, 5, 6, 0, 0, 133, 132, 1, 0, 0, 0, 133, 134,
		1, 0, 0, 0, 134, 135, 1, 0, 0, 0, 135, 136, 5, 0, 0, 1, 136, 1, 1, 0, 0,
		0, 137, 138, 5, 1, 0, 0, 138, 139, 3, 6, 3, 0, 139, 140, 5, 2, 0, 0, 140,
		142, 1, 0, 0, 0, 141, 137, 1, 0, 0, 0, 141, 142, 1, 0, 0, 0, 142, 159,
		1, 0, 0, 0, 143, 160, 3, 32, 16, 0, 144, 160, 3, 36, 18, 0, 145, 160, 3,
		44, 22, 0, 146, 160, 3, 42, 21, 0, 147, 160, 3, 48, 24, 0, 148, 160, 3,
		50, 25, 0, 149, 160, 3, 52, 26, 0, 150, 160, 3, 54, 27, 0, 151, 160, 3,
		56, 28, 0, 152, 160, 3, 58, 29, 0, 153, 160, 3, 64, 32, 0, 154, 160, 3,
		66, 33, 0, 155, 160, 3, 68, 34, 0, 156, 160, 3, 70, 35, 0, 157, 160, 3,
		72, 36, 0, 158, 160, 3, 74, 37, 0, 159, 143, 1, 0, 0, 0, 159, 144, 1, 0,
		0, 0, 159, 145, 1, 0, 0, 0, 159, 146, 1, 0, 0, 0, 159, 147, 1, 0, 0, 0,
		159, 148, 1, 0, 0, 0, 159, 149, 1, 0, 0, 0, 159, 150, 1, 0, 0, 0, 159,
		151, 1, 0, 0, 0, 159, 152, 1, 0, 0, 0, 159, 153, 1, 0, 0, 0, 159, 154,
		1, 0, 0, 0, 159, 155, 1, 0, 0, 0, 159, 156, 1, 0, 0, 0, 159, 157, 1, 0,
		0, 0, 159, 158, 1, 0, 0, 0, 160, 3, 1, 0, 0, 0, 161, 176, 5, 134, 0, 0,
		162, 164, 7, 0, 0, 0, 163, 162, 1, 0, 0, 0, 163, 164, 1, 0, 0, 0, 164,
		165, 1, 0, 0, 0, 165, 176, 5, 137, 0, 0, 166, 168, 7, 0, 0, 0, 167, 166,
		1, 0, 0, 0, 167, 168, 1, 0, 0, 0, 168, 169, 1, 0, 0, 0, 169, 170, 5, 137,
		0, 0, 170, 171, 5, 12, 0, 0, 171, 176, 5, 137, 0, 0, 172, 176, 7, 1, 0,
		0, 173, 176, 5, 57, 0, 0, 174, 176, 5, 138, 0, 0, 175, 161, 1, 0, 0, 0,
		175, 163, 1, 0, 0, 0, 175, 167, 1, 0, 0, 0, 175, 172, 1, 0, 0, 0, 175,
		173, 1, 0, 0, 0, 175, 174, 1, 0, 0, 0, 176, 5, 1, 0, 0, 0, 177, 178, 5,
		33, 0, 0, 178, 179, 3, 8, 4, 0, 179, 180, 5, 33, 0, 0, 180, 183, 1, 0,
		0, 0, 181, 183, 3, 8, 4, 0, 182, 177, 1, 0, 0, 0, 182, 181, 1, 0, 0, 0,
		183, 7, 1, 0, 0, 0, 184, 185, 7, 2, 0, 0, 185, 9, 1, 0, 0, 0, 186, 191,
		3, 6, 3, 0, 187, 188, 5, 9, 0, 0, 188, 190, 3, 6, 3, 0, 189, 187, 1, 0,
		0, 0, 190, 193, 1, 0, 0, 0, 191, 189, 1, 0, 0, 0, 191, 192, 1, 0, 0, 0,
		192, 11, 1, 0, 0, 0, 193, 191, 1, 0, 0, 0, 194, 202, 3, 6, 3, 0, 195, 196,
		5, 7, 0, 0, 196, 199, 5, 137, 0, 0, 197, 198, 5, 9, 0, 0, 198, 200, 5,
		137, 0, 0, 199, 197, 1, 0, 0, 0, 199, 200, 1, 0, 0, 0, 200, 201, 1, 0,
		0, 0, 201, 203, 5, 8, 0, 0, 202, 195, 1, 0, 0, 0, 202, 203, 1, 0, 0, 0,
		203, 206, 1, 0, 0, 0, 204, 205, 5, 3, 0, 0, 205, 207, 5, 4, 0, 0, 206,
		204, 1, 0, 0, 0, 206, 207, 1, 0, 0, 0, 207, 13, 1, 0, 0, 0, 208, 209, 5,
		29, 0, 0, 209, 210, 3, 12, 6, 0, 210, 15, 1, 0, 0, 0, 211, 212, 7, 3, 0,
		0, 212, 17, 1, 0, 0, 0, 213, 214, 3, 6, 3, 0, 214, 218, 3, 12, 6, 0, 215,
		217, 3, 24, 12, 0, 216, 215, 1, 0, 0, 0, 217, 220, 1, 0, 0, 0, 218, 216,
		1, 0, 0, 0, 218, 219, 1, 0, 0, 0, 219, 19, 1, 0, 0, 0, 220, 218, 1, 0,
		0, 0, 221, 226, 3, 12, 6, 0, 222, 223, 5, 9, 0, 0, 223, 225, 3, 12, 6,
		0, 224, 222, 1, 0, 0, 0, 225, 228, 1, 0, 0, 0, 226, 224, 1, 0, 0, 0, 226,
		227, 1, 0, 0, 0, 227, 21, 1, 0, 0, 0, 228, 226, 1, 0, 0, 0, 229, 230, 3,
		6, 3, 0, 230, 237, 3, 12, 6, 0, 231, 232, 5, 9, 0, 0, 232, 233, 3, 6, 3,
		0, 233, 234, 3, 12, 6, 0, 234, 236, 1, 0, 0, 0, 235, 231, 1, 0, 0, 0, 236,
		239, 1, 0, 0, 0, 237, 235, 1, 0, 0, 0, 237, 238, 1, 0, 0, 0, 238, 23, 1,
		0, 0, 0, 239, 237, 1, 0, 0, 0, 240, 241, 5, 48, 0, 0, 241, 254, 5, 49,
		0, 0, 242, 254, 5, 52, 0, 0, 243, 244, 5, 62, 0, 0, 244, 254, 5, 57, 0,
		0, 245, 246, 5, 56, 0, 0, 246, 254, 3, 110, 55, 0, 247, 254, 3, 28, 14,
		0, 248, 249, 5, 46, 0, 0, 249, 250, 5, 7, 0, 0, 250, 251, 3, 100, 50, 0,
		251, 252, 5, 8, 0, 0, 252, 254, 1, 0, 0, 0, 253, 240, 1, 0, 0, 0, 253,
		242, 1, 0, 0, 0, 253, 243, 1, 0, 0, 0, 253, 245, 1, 0, 0, 0, 253, 247,
		1, 0, 0, 0, 253, 248, 1, 0, 0, 0, 254, 25, 1, 0, 0, 0, 255, 256, 5, 50,
		0, 0, 256, 265, 7, 4, 0, 0, 257, 258, 5, 55, 0, 0, 258, 266, 5, 57, 0,
		0, 259, 260, 5, 55, 0, 0, 260, 266, 5, 56, 0, 0, 261, 266, 5, 54, 0, 0,
		262, 263, 5, 88, 0, 0, 263, 266, 5, 37, 0, 0, 264, 266, 5, 53, 0, 0, 265,
		257, 1, 0, 0, 0, 265, 259, 1, 0, 0, 0, 265, 261, 1, 0, 0, 0, 265, 262,
		1, 0, 0, 0, 265, 264, 1, 0, 0, 0, 266, 27, 1, 0, 0, 0, 267, 271, 5, 60,
		0, 0, 268, 269, 3, 6, 3, 0, 269, 270, 5, 12, 0, 0, 270, 272, 1, 0, 0, 0,
		271, 268, 1, 0, 0, 0, 271, 272, 1, 0, 0, 0, 272, 273, 1, 0, 0, 0, 273,
		274, 3, 6, 3, 0, 274, 275, 5, 7, 0, 0, 275, 276, 3, 10, 5, 0, 276, 281,
		5, 8, 0, 0, 277, 279, 3, 26, 13, 0, 278, 280, 3, 26, 13, 0, 279, 278, 1,
		0, 0, 0, 279, 280, 1, 0, 0, 0, 280, 282, 1, 0, 0, 0, 281, 277, 1, 0, 0,
		0, 281, 282, 1, 0, 0, 0, 282, 29, 1, 0, 0, 0, 283, 295, 5, 87, 0, 0, 284,
		286, 5, 36, 0, 0, 285, 284, 1, 0, 0, 0, 285, 286, 1, 0, 0, 0, 286, 287,
		1, 0, 0, 0, 287, 288, 5, 7, 0, 0, 288, 289, 3, 22, 11, 0, 289, 290, 5,
		8, 0, 0, 290, 296, 1, 0, 0, 0, 291, 292, 5, 7, 0, 0, 292, 293, 3, 20, 10,
		0, 293, 294, 5, 8, 0, 0, 294, 296, 1, 0, 0, 0, 295, 285, 1, 0, 0, 0, 295,
		291, 1, 0, 0, 0, 296, 31, 1, 0, 0, 0, 297, 299, 5, 89, 0, 0, 298, 300,
		5, 124, 0, 0, 299, 298, 1, 0, 0, 0, 299, 300, 1, 0, 0, 0, 300, 301, 1,
		0, 0, 0, 301, 306, 3, 34, 17, 0, 302, 303, 5, 9, 0, 0, 303, 305, 3, 34,
		17, 0, 304, 302, 1, 0, 0, 0, 305, 308, 1, 0, 0, 0, 306, 304, 1, 0, 0, 0,
		306, 307, 1, 0, 0, 0, 307, 310, 1, 0, 0, 0, 308, 306, 1, 0, 0, 0, 309,
		297, 1, 0, 0, 0, 309, 310, 1, 0, 0, 0, 310, 315, 1, 0, 0, 0, 311, 316,
		3, 76, 38, 0, 312, 316, 3, 90, 45, 0, 313, 316, 3, 94, 47, 0, 314, 316,
		3, 98, 49, 0, 315, 311, 1, 0, 0, 0, 315, 312, 1, 0, 0, 0, 315, 313, 1,
		0, 0, 0, 315, 314, 1, 0, 0, 0, 316, 33, 1, 0, 0, 0, 317, 330, 3, 6, 3,
		0, 318, 327, 5, 7, 0, 0, 319, 324, 3, 6, 3, 0, 320, 321, 5, 9, 0, 0, 321,
		323, 3, 6, 3, 0, 322, 320, 1, 0, 0, 0, 323, 326, 1, 0, 0, 0, 324, 322,
		1, 0, 0, 0, 324, 325, 1, 0, 0, 0, 325, 328, 1, 0, 0, 0, 326, 324, 1, 0,
		0, 0, 327, 319, 1, 0, 0, 0, 327, 328, 1, 0, 0, 0, 328, 329, 1, 0, 0, 0,
		329, 331, 5, 8, 0, 0, 330, 318, 1, 0, 0, 0, 330, 331, 1, 0, 0, 0, 331,
		332, 1, 0, 0, 0, 332, 333, 5, 78, 0, 0, 333, 334, 5, 7, 0, 0, 334, 335,
		3, 76, 38, 0, 335, 336, 5, 8, 0, 0, 336, 35, 1, 0, 0, 0, 337, 338, 5, 38,
		0, 0, 338, 342, 5, 36, 0, 0, 339, 340, 5, 113, 0, 0, 340, 341, 5, 62, 0,
		0, 341, 343, 5, 71, 0, 0, 342, 339, 1, 0, 0, 0, 342, 343, 1, 0, 0, 0, 343,
		344, 1, 0, 0, 0, 344, 345, 3, 6, 3, 0, 345, 348, 5, 7, 0, 0, 346, 349,
		3, 18, 9, 0, 347, 349, 3, 38, 19, 0, 348, 346, 1, 0, 0, 0, 348, 347, 1,
		0, 0, 0, 349, 357, 1, 0, 0, 0, 350, 353, 5, 9, 0, 0, 351, 354, 3, 18, 9,
		0, 352, 354, 3, 38, 19, 0, 353, 351, 1, 0, 0, 0, 353, 352, 1, 0, 0, 0,
		354, 356, 1, 0, 0, 0, 355, 350, 1, 0, 0, 0, 356, 359, 1, 0, 0, 0, 357,
		355, 1, 0, 0, 0, 357, 358, 1, 0, 0, 0, 358, 360, 1, 0, 0, 0, 359, 357,
		1, 0, 0, 0, 360, 361, 5, 8, 0, 0, 361, 37, 1, 0, 0, 0, 362, 363, 5, 45,
		0, 0, 363, 365, 3, 6, 3, 0, 364, 362, 1, 0, 0, 0, 364, 365, 1, 0, 0, 0,
		365, 389, 1, 0, 0, 0, 366, 367, 5, 52, 0, 0, 367, 368, 5, 7, 0, 0, 368,
		369, 3, 10, 5, 0, 369, 370, 5, 8, 0, 0, 370, 390, 1, 0, 0, 0, 371, 372,
		5, 46, 0, 0, 372, 373, 5, 7, 0, 0, 373, 374, 3, 100, 50, 0, 374, 375, 5,
		8, 0, 0, 375, 390, 1, 0, 0, 0, 376, 377, 5, 47, 0, 0, 377, 378, 5, 49,
		0, 0, 378, 379, 5, 7, 0, 0, 379, 380, 3, 10, 5, 0, 380, 381, 5, 8, 0, 0,
		381, 382, 3, 28, 14, 0, 382, 390, 1, 0, 0, 0, 383, 384, 5, 48, 0, 0, 384,
		385, 5, 49, 0, 0, 385, 386, 5, 7, 0, 0, 386, 387, 3, 10, 5, 0, 387, 388,
		5, 8, 0, 0, 388, 390, 1, 0, 0, 0, 389, 366, 1, 0, 0, 0, 389, 371, 1, 0,
		0, 0, 389, 376, 1, 0, 0, 0, 389, 383, 1, 0, 0, 0, 390, 39, 1, 0, 0, 0,
		391, 392, 7, 5, 0, 0, 392, 41, 1, 0, 0, 0, 393, 394, 5, 42, 0, 0, 394,
		397, 5, 36, 0, 0, 395, 396, 5, 113, 0, 0, 396, 398, 5, 71, 0, 0, 397, 395,
		1, 0, 0, 0, 397, 398, 1, 0, 0, 0, 398, 399, 1, 0, 0, 0, 399, 401, 3, 10,
		5, 0, 400, 402, 3, 40, 20, 0, 401, 400, 1, 0, 0, 0, 401, 402, 1, 0, 0,
		0, 402, 43, 1, 0, 0, 0, 403, 404, 5, 39, 0, 0, 404, 405, 5, 36, 0, 0, 405,
		406, 3, 6, 3, 0, 406, 407, 3, 46, 23, 0, 407, 45, 1, 0, 0, 0, 408, 409,
		5, 39, 0, 0, 409, 410, 5, 40, 0, 0, 410, 411, 3, 6, 3, 0, 411, 416, 5,
		55, 0, 0, 412, 413, 5, 62, 0, 0, 413, 417, 5, 57, 0, 0, 414, 415, 5, 56,
		0, 0, 415, 417, 3, 110, 55, 0, 416, 412, 1, 0, 0, 0, 416, 414, 1, 0, 0,
		0, 417, 450, 1, 0, 0, 0, 418, 419, 5, 39, 0, 0, 419, 420, 5, 40, 0, 0,
		420, 421, 3, 6, 3, 0, 421, 425, 5, 42, 0, 0, 422, 423, 5, 62, 0, 0, 423,
		426, 5, 57, 0, 0, 424, 426, 5, 56, 0, 0, 425, 422, 1, 0, 0, 0, 425, 424,
		1, 0, 0, 0, 426, 450, 1, 0, 0, 0, 427, 428, 5, 41, 0, 0, 428, 429, 5, 40,
		0, 0, 429, 430, 3, 6, 3, 0, 430, 431, 3, 12, 6, 0, 431, 450, 1, 0, 0, 0,
		432, 433, 5, 42, 0, 0, 433, 434, 5, 40, 0, 0, 434, 450, 3, 6, 3, 0, 435,
		436, 5, 43, 0, 0, 436, 437, 5, 40, 0, 0, 437, 438, 3, 6, 3, 0, 438, 439,
		5, 44, 0, 0, 439, 440, 3, 6, 3, 0, 440, 450, 1, 0, 0, 0, 441, 442, 5, 43,
		0, 0, 442, 443, 5, 44, 0, 0, 443, 450, 3, 6, 3, 0, 444, 445, 5, 41, 0,
		0, 445, 450, 3, 38, 19, 0, 446, 447, 5, 42, 0, 0, 447, 448, 5, 45, 0, 0,
		448, 450, 3, 6, 3, 0, 449, 408, 1, 0, 0, 0, 449, 418, 1, 0, 0, 0, 449,
		427, 1, 0, 0, 0, 449, 432, 1, 0, 0, 0, 449, 435, 1, 0, 0, 0, 449, 441,
		1, 0, 0, 0, 449, 444, 1, 0, 0, 0, 449, 446, 1, 0, 0, 0, 450, 47, 1, 0,
		0, 0, 451, 453, 5, 38, 0, 0, 452, 454, 5, 52, 0, 0, 453, 452, 1, 0, 0,
		0, 453, 454, 1, 0, 0, 0, 454, 455, 1, 0, 0, 0, 455, 459, 5, 63, 0, 0, 456,
		457, 5, 113, 0, 0, 457, 458, 5, 62, 0, 0, 458, 460, 5, 71, 0, 0, 459, 456,
		1, 0, 0, 0, 459, 460, 1, 0, 0, 0, 460, 462, 1, 0, 0, 0, 461, 463, 3, 6,
		3, 0, 462, 461, 1, 0, 0, 0, 462, 463, 1, 0, 0, 0, 463, 464, 1, 0, 0, 0,
		464, 465, 5, 50, 0, 0, 465, 466, 3, 6, 3, 0, 466, 467, 5, 7, 0, 0, 467,
		468, 3, 10, 5, 0, 468, 469, 5, 8, 0, 0, 469, 49, 1, 0, 0, 0, 470, 471,
		5, 42, 0, 0, 471, 474, 5, 63, 0, 0, 472, 473, 5, 113, 0, 0, 473, 475, 5,
		71, 0, 0, 474, 472, 1, 0, 0, 0, 474, 475, 1, 0, 0, 0, 475, 476, 1, 0, 0,
		0, 476, 477, 3, 6, 3, 0, 477, 51, 1, 0, 0, 0, 478, 479, 5, 38, 0, 0, 479,
		483, 5, 128, 0, 0, 480, 481, 5, 113, 0, 0, 481, 482, 5, 62, 0, 0, 482,
		484, 5, 71, 0, 0, 483, 480, 1, 0, 0, 0, 483, 484, 1, 0, 0, 0, 484, 485,
		1, 0, 0, 0, 485, 486, 3, 6, 3, 0, 486, 53, 1, 0, 0, 0, 487, 488, 5, 42,
		0, 0, 488, 491, 5, 128, 0, 0, 489, 490, 5, 113, 0, 0, 490, 492, 5, 71,
		0, 0, 491, 489, 1, 0, 0, 0, 491, 492, 1, 0, 0, 0, 492, 493, 1, 0, 0, 0,
		493, 494, 3, 6, 3, 0, 494, 55, 1, 0, 0, 0, 495, 499, 5, 125, 0, 0, 496,
		497, 5, 113, 0, 0, 497, 498, 5, 62, 0, 0, 498, 500, 5, 126, 0, 0, 499,
		496, 1, 0, 0, 0, 499, 500, 1, 0, 0, 0, 500, 503, 1, 0, 0, 0, 501, 504,
		3, 60, 30, 0, 502, 504, 3, 6, 3, 0, 503, 501, 1, 0, 0, 0, 503, 502, 1,
		0, 0, 0, 504, 507, 1, 0, 0, 0, 505, 506, 5, 50, 0, 0, 506, 508, 3, 6, 3,
		0, 507, 505, 1, 0, 0, 0, 507, 508, 1, 0, 0, 0, 508, 509, 1, 0, 0, 0, 509,
		513, 5, 44, 0, 0, 510, 514, 3, 6, 3, 0, 511, 514, 5, 134, 0, 0, 512, 514,
		3, 110, 55, 0, 513, 510, 1, 0, 0, 0, 513, 511, 1, 0, 0, 0, 513, 512, 1,
		0, 0, 0, 514, 57, 1, 0, 0, 0, 515, 518, 5, 127, 0, 0, 516, 517, 5, 113,
		0, 0, 517, 519, 5, 126, 0, 0, 518, 516, 1, 0, 0, 0, 518, 519, 1, 0, 0,
		0, 519, 522, 1, 0, 0, 0, 520, 523, 3, 60, 30, 0, 521, 523, 3, 6, 3, 0,
		522, 520, 1, 0, 0, 0, 522, 521, 1, 0, 0, 0, 523, 526, 1, 0, 0, 0, 524,
		525, 5, 50, 0, 0, 525, 527, 3, 6, 3, 0, 526, 524, 1, 0, 0, 0, 526, 527,
		1, 0, 0, 0, 527, 528, 1, 0, 0, 0, 528, 532, 5, 95, 0, 0, 529, 533, 3, 6,
		3, 0, 530, 533, 5, 134, 0, 0, 531, 533, 3, 110, 55, 0, 532, 529, 1, 0,
		0, 0, 532, 530, 1, 0, 0, 0, 532, 531, 1, 0, 0, 0, 533, 59, 1, 0, 0, 0,
		534, 539, 3, 62, 31, 0, 535, 536, 5, 9, 0, 0, 536, 538, 3, 62, 31, 0, 537,
		535, 1, 0, 0, 0, 538, 541, 1, 0, 0, 0, 539, 537, 1, 0, 0, 0, 539, 540,
		1, 0, 0, 0, 540, 61, 1, 0, 0, 0, 541, 539, 1, 0, 0, 0, 542, 543, 7, 6,
		0, 0, 543, 63, 1, 0, 0, 0, 544, 547, 5, 38, 0, 0, 545, 546, 5, 65, 0, 0,
		546, 548, 5, 129, 0, 0, 547, 545, 1, 0, 0, 0, 547, 548, 1, 0, 0, 0, 548,
		549, 1, 0, 0, 0, 549, 553, 5, 37, 0, 0, 550, 551, 5, 113, 0, 0, 551, 552,
		5, 62, 0, 0, 552, 554, 5, 71, 0, 0, 553, 550, 1, 0, 0, 0, 553, 554, 1,
		0, 0, 0, 554, 555, 1, 0, 0, 0, 555, 556, 3, 6, 3, 0, 556, 567, 5, 7, 0,
		0, 557, 558, 5, 146, 0, 0, 558, 564, 3, 12, 6, 0, 559, 560, 5, 9, 0, 0,
		560, 561, 5, 146, 0, 0, 561, 563, 3, 12, 6, 0, 562, 559, 1, 0, 0, 0, 563,
		566, 1, 0, 0, 0, 564, 562, 1, 0, 0, 0, 564, 565, 1, 0, 0, 0, 565, 568,
		1, 0, 0, 0, 566, 564, 1, 0, 0, 0, 567, 557, 1, 0, 0, 0, 567, 568, 1, 0,
		0, 0, 568, 569, 1, 0, 0, 0, 569, 573, 5, 8, 0, 0, 570, 572, 3, 6, 3, 0,
		571, 570, 1, 0, 0, 0, 572, 575, 1, 0, 0, 0, 573, 571, 1, 0, 0, 0, 573,
		574, 1, 0, 0, 0, 574, 577, 1, 0, 0, 0, 575, 573, 1, 0, 0, 0, 576, 578,
		3, 30, 15, 0, 577, 576, 1, 0, 0, 0, 577, 578, 1, 0, 0, 0, 578, 579, 1,
		0, 0, 0, 579, 583, 5, 1, 0, 0, 580, 582, 3, 114, 57, 0, 581, 580, 1, 0,
		0, 0, 582, 585, 1, 0, 0, 0, 583, 581, 1, 0, 0, 0, 583, 584, 1, 0, 0, 0,
		584, 586, 1, 0, 0, 0, 585, 583, 1, 0, 0, 0, 586, 587, 5, 2, 0, 0, 587,
		65, 1, 0, 0, 0, 588, 589, 5, 42, 0, 0, 589, 592, 5, 37, 0, 0, 590, 591,
		5, 113, 0, 0, 591, 593, 5, 71, 0, 0, 592, 590, 1, 0, 0, 0, 592, 593, 1,
		0, 0, 0, 593, 594, 1, 0, 0, 0, 594, 595, 3, 6, 3, 0, 595, 67, 1, 0, 0,
		0, 596, 600, 5, 34, 0, 0, 597, 598, 5, 113, 0, 0, 598, 599, 5, 62, 0, 0,
		599, 601, 5, 71, 0, 0, 600, 597, 1, 0, 0, 0, 600, 601, 1, 0, 0, 0, 601,
		602, 1, 0, 0, 0, 602, 620, 3, 6, 3, 0, 603, 617, 5, 1, 0, 0, 604, 605,
		3, 6, 3, 0, 605, 606, 5, 5, 0, 0, 606, 614, 3, 110, 55, 0, 607, 608, 5,
		9, 0, 0, 608, 609, 3, 6, 3, 0, 609, 610, 5, 5, 0, 0, 610, 611, 3, 110,
		55, 0, 611, 613, 1, 0, 0, 0, 612, 607, 1, 0, 0, 0, 613, 616, 1, 0, 0, 0,
		614, 612, 1, 0, 0, 0, 614, 615, 1, 0, 0, 0, 615, 618, 1, 0, 0, 0, 616,
		614, 1, 0, 0, 0, 617, 604, 1, 0, 0, 0, 617, 618, 1, 0, 0, 0, 618, 619,
		1, 0, 0, 0, 619, 621, 5, 2, 0, 0, 620, 603, 1, 0, 0, 0, 620, 621, 1, 0,
		0, 0, 621, 622, 1, 0, 0, 0, 622, 623, 5, 78, 0, 0, 623, 624, 3, 6, 3, 0,
		624, 69, 1, 0, 0, 0, 625, 626, 5, 35, 0, 0, 626, 629, 3, 6, 3, 0, 627,
		628, 5, 113, 0, 0, 628, 630, 5, 71, 0, 0, 629, 627, 1, 0, 0, 0, 629, 630,
		1, 0, 0, 0, 630, 71, 1, 0, 0, 0, 631, 632, 5, 38, 0, 0, 632, 636, 5, 131,
		0, 0, 633, 634, 5, 113, 0, 0, 634, 635, 5, 62, 0, 0, 635, 637, 5, 71, 0,
		0, 636, 633, 1, 0, 0, 0, 636, 637, 1, 0, 0, 0, 637, 638, 1, 0, 0, 0, 638,
		639, 3, 6, 3, 0, 639, 73, 1, 0, 0, 0, 640, 641, 5, 42, 0, 0, 641, 644,
		5, 131, 0, 0, 642, 643, 5, 113, 0, 0, 643, 645, 5, 71, 0, 0, 644, 642,
		1, 0, 0, 0, 644, 645, 1, 0, 0, 0, 645, 646, 1, 0, 0, 0, 646, 647, 3, 6,
		3, 0, 647, 75, 1, 0, 0, 0, 648, 654, 3, 82, 41, 0, 649, 650, 3, 78, 39,
		0, 650, 651, 3, 82, 41, 0, 651, 653, 1, 0, 0, 0, 652, 649, 1, 0, 0, 0,
		653, 656, 1, 0, 0, 0, 654, 652, 1, 0, 0, 0, 654, 655, 1, 0, 0, 0, 655,
		667, 1, 0, 0, 0, 656, 654, 1, 0, 0, 0, 657, 658, 5, 83, 0, 0, 658, 659,
		5, 84, 0, 0, 659, 664, 3, 80, 40, 0, 660, 661, 5, 9, 0, 0, 661, 663, 3,
		80, 40, 0, 662, 660, 1, 0, 0, 0, 663, 666, 1, 0, 0, 0, 664, 662, 1, 0,
		0, 0, 664, 665, 1, 0, 0, 0, 665, 668, 1, 0, 0, 0, 666, 664, 1, 0, 0, 0,
		667, 657, 1, 0, 0, 0, 667, 668, 1, 0, 0, 0, 668, 671, 1, 0, 0, 0, 669,
		670, 5, 81, 0, 0, 670, 672, 3, 100, 50, 0, 671, 669, 1, 0, 0, 0, 671, 672,
		1, 0, 0, 0, 672, 675, 1, 0, 0, 0, 673, 674, 5, 82, 0, 0, 674, 676, 3, 100,
		50, 0, 675, 673, 1, 0, 0, 0, 675, 676, 1, 0, 0, 0, 676, 77, 1, 0, 0, 0,
		677, 679, 5, 102, 0, 0, 678, 680, 5, 72, 0, 0, 679, 678, 1, 0, 0, 0, 679,
		680, 1, 0, 0, 0, 680, 684, 1, 0, 0, 0, 681, 684, 5, 103, 0, 0, 682, 684,
		5, 104, 0, 0, 683, 677, 1, 0, 0, 0, 683, 681, 1, 0, 0, 0, 683, 682, 1,
		0, 0, 0, 684, 79, 1, 0, 0, 0, 685, 687, 3, 100, 50, 0, 686, 688, 7, 7,
		0, 0, 687, 686, 1, 0, 0, 0, 687, 688, 1, 0, 0, 0, 688, 691, 1, 0, 0, 0,
		689, 690, 5, 105, 0, 0, 690, 692, 7, 8, 0, 0, 691, 689, 1, 0, 0, 0, 691,
		692, 1, 0, 0, 0, 692, 81, 1, 0, 0, 0, 693, 695, 5, 98, 0, 0, 694, 696,
		5, 94, 0, 0, 695, 694, 1, 0, 0, 0, 695, 696, 1, 0, 0, 0, 696, 697, 1, 0,
		0, 0, 697, 702, 3, 88, 44, 0, 698, 699, 5, 9, 0, 0, 699, 701, 3, 88, 44,
		0, 700, 698, 1, 0, 0, 0, 701, 704, 1, 0, 0, 0, 702, 700, 1, 0, 0, 0, 702,
		703, 1, 0, 0, 0, 703, 713, 1, 0, 0, 0, 704, 702, 1, 0, 0, 0, 705, 706,
		5, 95, 0, 0, 706, 710, 3, 84, 42, 0, 707, 709, 3, 86, 43, 0, 708, 707,
		1, 0, 0, 0, 709, 712, 1, 0, 0, 0, 710, 708, 1, 0, 0, 0, 710, 711, 1, 0,
		0, 0, 711, 714, 1, 0, 0, 0, 712, 710, 1, 0, 0, 0, 713, 705, 1, 0, 0, 0,
		713, 714, 1, 0, 0, 0, 714, 717, 1, 0, 0, 0, 715, 716, 5, 96, 0, 0, 716,
		718, 3, 100, 50, 0, 717, 715, 1, 0, 0, 0, 717, 718, 1, 0, 0, 0, 718, 726,
		1, 0, 0, 0, 719, 720, 5, 85, 0, 0, 720, 721, 5, 84, 0, 0, 721, 724, 3,
		106, 53, 0, 722, 723, 5, 86, 0, 0, 723, 725, 3, 100, 50, 0, 724, 722, 1,
		0, 0, 0, 724, 725, 1, 0, 0, 0, 725, 727, 1, 0, 0, 0, 726, 719, 1, 0, 0,
		0, 726, 727, 1, 0, 0, 0, 727, 742, 1, 0, 0, 0, 728, 729, 5, 122, 0, 0,
		729, 730, 3, 6, 3, 0, 730, 731, 5, 78, 0, 0, 731, 739, 3, 102, 51, 0, 732,
		733, 5, 9, 0, 0, 733, 734, 3, 6, 3, 0, 734, 735, 5, 78, 0, 0, 735, 736,
		3, 102, 51, 0, 736, 738, 1, 0, 0, 0, 737, 732, 1, 0, 0, 0, 738, 741, 1,
		0, 0, 0, 739, 737, 1, 0, 0, 0, 739, 740, 1, 0, 0, 0, 740, 743, 1, 0, 0,
		0, 741, 739, 1, 0, 0, 0, 742, 728, 1, 0, 0, 0, 742, 743, 1, 0, 0, 0, 743,
		83, 1, 0, 0, 0, 744, 745, 3, 6, 3, 0, 745, 746, 5, 12, 0, 0, 746, 748,
		1, 0, 0, 0, 747, 744, 1, 0, 0, 0, 747, 748, 1, 0, 0, 0, 748, 749, 1, 0,
		0, 0, 749, 754, 3, 6, 3, 0, 750, 752, 5, 78, 0, 0, 751, 750, 1, 0, 0, 0,
		751, 752, 1, 0, 0, 0, 752, 753, 1, 0, 0, 0, 753, 755, 3, 6, 3, 0, 754,
		751, 1, 0, 0, 0, 754, 755, 1, 0, 0, 0, 755, 766, 1, 0, 0, 0, 756, 757,
		5, 7, 0, 0, 757, 758, 3, 76, 38, 0, 758, 763, 5, 8, 0, 0, 759, 761, 5,
		78, 0, 0, 760, 759, 1, 0, 0, 0, 760, 761, 1, 0, 0, 0, 761, 762, 1, 0, 0,
		0, 762, 764, 3, 6, 3, 0, 763, 760, 1, 0, 0, 0, 763, 764, 1, 0, 0, 0, 764,
		766, 1, 0, 0, 0, 765, 747, 1, 0, 0, 0, 765, 756, 1, 0, 0, 0, 766, 85, 1,
		0, 0, 0, 767, 769, 7, 9, 0, 0, 768, 767, 1, 0, 0, 0, 768, 769, 1, 0, 0,
		0, 769, 770, 1, 0, 0, 0, 770, 771, 5, 74, 0, 0, 771, 772, 3, 84, 42, 0,
		772, 773, 5, 50, 0, 0, 773, 774, 3, 100, 50, 0, 774, 87, 1, 0, 0, 0, 775,
		780, 3, 100, 50, 0, 776, 778, 5, 78, 0, 0, 777, 776, 1, 0, 0, 0, 777, 778,
		1, 0, 0, 0, 778, 779, 1, 0, 0, 0, 779, 781, 3, 6, 3, 0, 780, 777, 1, 0,
		0, 0, 780, 781, 1, 0, 0, 0, 781, 789, 1, 0, 0, 0, 782, 783, 3, 6, 3, 0,
		783, 784, 5, 12, 0, 0, 784, 786, 1, 0, 0, 0, 785, 782, 1, 0, 0, 0, 785,
		786, 1, 0, 0, 0, 786, 787, 1, 0, 0, 0, 787, 789, 5, 14, 0, 0, 788, 775,
		1, 0, 0, 0, 788, 785, 1, 0, 0, 0, 789, 89, 1, 0, 0, 0, 790, 791, 5, 59,
		0, 0, 791, 796, 3, 6, 3, 0, 792, 794, 5, 78, 0, 0, 793, 792, 1, 0, 0, 0,
		793, 794, 1, 0, 0, 0, 794, 795, 1, 0, 0, 0, 795, 797, 3, 6, 3, 0, 796,
		793, 1, 0, 0, 0, 796, 797, 1, 0, 0, 0, 797, 798, 1, 0, 0, 0, 798, 799,
		5, 55, 0, 0, 799, 804, 3, 92, 46, 0, 800, 801, 5, 9, 0, 0, 801, 803, 3,
		92, 46, 0, 802, 800, 1, 0, 0, 0, 803, 806, 1, 0, 0, 0, 804, 802, 1, 0,
		0, 0, 804, 805, 1, 0, 0, 0, 805, 815, 1, 0, 0, 0, 806, 804, 1, 0, 0, 0,
		807, 808, 5, 95, 0, 0, 808, 812, 3, 84, 42, 0, 809, 811, 3, 86, 43, 0,
		810, 809, 1, 0, 0, 0, 811, 814, 1, 0, 0, 0, 812, 810, 1, 0, 0, 0, 812,
		813, 1, 0, 0, 0, 813, 816, 1, 0, 0, 0, 814, 812, 1, 0, 0, 0, 815, 807,
		1, 0, 0, 0, 815, 816, 1, 0, 0, 0, 816, 819, 1, 0, 0, 0, 817, 818, 5, 96,
		0, 0, 818, 820, 3, 100, 50, 0, 819, 817, 1, 0, 0, 0, 819, 820, 1, 0, 0,
		0, 820, 91, 1, 0, 0, 0, 821, 822, 3, 6, 3, 0, 822, 823, 5, 15, 0, 0, 823,
		824, 3, 100, 50, 0, 824, 93, 1, 0, 0, 0, 825, 826, 5, 99, 0, 0, 826, 827,
		5, 109, 0, 0, 827, 832, 3, 6, 3, 0, 828, 830, 5, 78, 0, 0, 829, 828, 1,
		0, 0, 0, 829, 830, 1, 0, 0, 0, 830, 831, 1, 0, 0, 0, 831, 833, 3, 6, 3,
		0, 832, 829, 1, 0, 0, 0, 832, 833, 1, 0, 0, 0, 833, 838, 1, 0, 0, 0, 834,
		835, 5, 7, 0, 0, 835, 836, 3, 10, 5, 0, 836, 837, 5, 8, 0, 0, 837, 839,
		1, 0, 0, 0, 838, 834, 1, 0, 0, 0, 838, 839, 1, 0, 0, 0, 839, 855, 1, 0,
		0, 0, 840, 841, 5, 100, 0, 0, 841, 842, 5, 7, 0, 0, 842, 843, 3, 106, 53,
		0, 843, 851, 5, 8, 0, 0, 844, 845, 5, 9, 0, 0, 845, 846, 5, 7, 0, 0, 846,
		847, 3, 106, 53, 0, 847, 848, 5, 8, 0, 0, 848, 850, 1, 0, 0, 0, 849, 844,
		1, 0, 0, 0, 850, 853, 1, 0, 0, 0, 851, 849, 1, 0, 0, 0, 851, 852, 1, 0,
		0, 0, 852, 856, 1, 0, 0, 0, 853, 851, 1, 0, 0, 0, 854, 856, 3, 76, 38,
		0, 855, 840, 1, 0, 0, 0, 855, 854, 1, 0, 0, 0, 856, 858, 1, 0, 0, 0, 857,
		859, 3, 96, 48, 0, 858, 857, 1, 0, 0, 0, 858, 859, 1, 0, 0, 0, 859, 95,
		1, 0, 0, 0, 860, 861, 5, 50, 0, 0, 861, 869, 5, 110, 0, 0, 862, 863, 5,
		7, 0, 0, 863, 864, 3, 10, 5, 0, 864, 867, 5, 8, 0, 0, 865, 866, 5, 96,
		0, 0, 866, 868, 3, 100, 50, 0, 867, 865, 1, 0, 0, 0, 867, 868, 1, 0, 0,
		0, 868, 870, 1, 0, 0, 0, 869, 862, 1, 0, 0, 0, 869, 870, 1, 0, 0, 0, 870,
		871, 1, 0, 0, 0, 871, 887, 5, 51, 0, 0, 872, 888, 5, 111, 0, 0, 873, 874,
		5, 59, 0, 0, 874, 875, 5, 55, 0, 0, 875, 880, 3, 92, 46, 0, 876, 877, 5,
		9, 0, 0, 877, 879, 3, 92, 46, 0, 878, 876, 1, 0, 0, 0, 879, 882, 1, 0,
		0, 0, 880, 878, 1, 0, 0, 0, 880, 881, 1, 0, 0, 0, 881, 885, 1, 0, 0, 0,
		882, 880, 1, 0, 0, 0, 883, 884, 5, 96, 0, 0, 884, 886, 3, 100, 50, 0, 885,
		883, 1, 0, 0, 0, 885, 886, 1, 0, 0, 0, 886, 888, 1, 0, 0, 0, 887, 872,
		1, 0, 0, 0, 887, 873, 1, 0, 0, 0, 888, 97, 1, 0, 0, 0, 889, 890, 5, 58,
		0, 0, 890, 891, 5, 95, 0, 0, 891, 896, 3, 6, 3, 0, 892, 894, 5, 78, 0,
		0, 893, 892, 1, 0, 0, 0, 893, 894, 1, 0, 0, 0, 894, 895, 1, 0, 0, 0, 895,
		897, 3, 6, 3, 0, 896, 893, 1, 0, 0, 0, 896, 897, 1, 0, 0, 0, 897, 900,
		1, 0, 0, 0, 898, 899, 5, 96, 0, 0, 899, 901, 3, 100, 50, 0, 900, 898, 1,
		0, 0, 0, 900, 901, 1, 0, 0, 0, 901, 99, 1, 0, 0, 0, 902, 903, 6, 50, -1,
		0, 903, 904, 5, 7, 0, 0, 904, 905, 3, 100, 50, 0, 905, 907, 5, 8, 0, 0,
		906, 908, 3, 14, 7, 0, 907, 906, 1, 0, 0, 0, 907, 908, 1, 0, 0, 0, 908,
		985, 1, 0, 0, 0, 909, 910, 7, 0, 0, 0, 910, 985, 3, 100, 50, 22, 911, 913,
		3, 4, 2, 0, 912, 914, 3, 14, 7, 0, 913, 912, 1, 0, 0, 0, 913, 914, 1, 0,
		0, 0, 914, 985, 1, 0, 0, 0, 915, 922, 3, 108, 54, 0, 916, 917, 5, 123,
		0, 0, 917, 918, 5, 7, 0, 0, 918, 919, 5, 96, 0, 0, 919, 920, 3, 100, 50,
		0, 920, 921, 5, 8, 0, 0, 921, 923, 1, 0, 0, 0, 922, 916, 1, 0, 0, 0, 922,
		923, 1, 0, 0, 0, 923, 924, 1, 0, 0, 0, 924, 927, 5, 120, 0, 0, 925, 928,
		3, 102, 51, 0, 926, 928, 3, 6, 3, 0, 927, 925, 1, 0, 0, 0, 927, 926, 1,
		0, 0, 0, 928, 985, 1, 0, 0, 0, 929, 931, 3, 108, 54, 0, 930, 932, 3, 14,
		7, 0, 931, 930, 1, 0, 0, 0, 931, 932, 1, 0, 0, 0, 932, 985, 1, 0, 0, 0,
		933, 935, 3, 16, 8, 0, 934, 936, 3, 14, 7, 0, 935, 934, 1, 0, 0, 0, 935,
		936, 1, 0, 0, 0, 936, 985, 1, 0, 0, 0, 937, 938, 5, 130, 0, 0, 938, 940,
		5, 3, 0, 0, 939, 941, 3, 106, 53, 0, 940, 939, 1, 0, 0, 0, 940, 941, 1,
		0, 0, 0, 941, 942, 1, 0, 0, 0, 942, 944, 5, 4, 0, 0, 943, 945, 3, 14, 7,
		0, 944, 943, 1, 0, 0, 0, 944, 945, 1, 0, 0, 0, 945, 985, 1, 0, 0, 0, 946,
		947, 3, 6, 3, 0, 947, 948, 5, 12, 0, 0, 948, 950, 1, 0, 0, 0, 949, 946,
		1, 0, 0, 0, 949, 950, 1, 0, 0, 0, 950, 951, 1, 0, 0, 0, 951, 953, 3, 6,
		3, 0, 952, 954, 3, 14, 7, 0, 953, 952, 1, 0, 0, 0, 953, 954, 1, 0, 0, 0,
		954, 985, 1, 0, 0, 0, 955, 957, 5, 90, 0, 0, 956, 958, 3, 100, 50, 0, 957,
		956, 1, 0, 0, 0, 957, 958, 1, 0, 0, 0, 958, 960, 1, 0, 0, 0, 959, 961,
		3, 104, 52, 0, 960, 959, 1, 0, 0, 0, 961, 962, 1, 0, 0, 0, 962, 960, 1,
		0, 0, 0, 962, 963, 1, 0, 0, 0, 963, 966, 1, 0, 0, 0, 964, 965, 5, 115,
		0, 0, 965, 967, 3, 100, 50, 0, 966, 964, 1, 0, 0, 0, 966, 967, 1, 0, 0,
		0, 967, 968, 1, 0, 0, 0, 968, 969, 5, 93, 0, 0, 969, 985, 1, 0, 0, 0, 970,
		972, 5, 62, 0, 0, 971, 970, 1, 0, 0, 0, 971, 972, 1, 0, 0, 0, 972, 973,
		1, 0, 0, 0, 973, 975, 5, 71, 0, 0, 974, 971, 1, 0, 0, 0, 974, 975, 1, 0,
		0, 0, 975, 976, 1, 0, 0, 0, 976, 977, 5, 7, 0, 0, 977, 978, 3, 76, 38,
		0, 978, 980, 5, 8, 0, 0, 979, 981, 3, 14, 7, 0, 980, 979, 1, 0, 0, 0, 980,
		981, 1, 0, 0, 0, 981, 985, 1, 0, 0, 0, 982, 983, 5, 62, 0, 0, 983, 985,
		3, 100, 50, 3, 984, 902, 1, 0, 0, 0, 984, 909, 1, 0, 0, 0, 984, 911, 1,
		0, 0, 0, 984, 915, 1, 0, 0, 0, 984, 929, 1, 0, 0, 0, 984, 933, 1, 0, 0,
		0, 984, 937, 1, 0, 0, 0, 984, 949, 1, 0, 0, 0, 984, 955, 1, 0, 0, 0, 984,
		974, 1, 0, 0, 0, 984, 982, 1, 0, 0, 0, 985, 1074, 1, 0, 0, 0, 986, 987,
		10, 20, 0, 0, 987, 988, 5, 23, 0, 0, 988, 1073, 3, 100, 50, 21, 989, 990,
		10, 19, 0, 0, 990, 991, 7, 10, 0, 0, 991, 1073, 3, 100, 50, 20, 992, 993,
		10, 18, 0, 0, 993, 994, 7, 0, 0, 0, 994, 1073, 3, 100, 50, 19, 995, 996,
		10, 9, 0, 0, 996, 997, 5, 13, 0, 0, 997, 1073, 3, 100, 50, 10, 998, 1000,
		10, 7, 0, 0, 999, 1001, 5, 62, 0, 0, 1000, 999, 1, 0, 0, 0, 1000, 1001,
		1, 0, 0, 0, 1001, 1002, 1, 0, 0, 0, 1002, 1003, 7, 11, 0, 0, 1003, 1073,
		3, 100, 50, 8, 1004, 1006, 10, 6, 0, 0, 1005, 1007, 5, 62, 0, 0, 1006,
		1005, 1, 0, 0, 0, 1006, 1007, 1, 0, 0, 0, 1007, 1008, 1, 0, 0, 0, 1008,
		1009, 5, 69, 0, 0, 1009, 1010, 3, 100, 50, 0, 1010, 1011, 5, 64, 0, 0,
		1011, 1012, 3, 100, 50, 7, 1012, 1073, 1, 0, 0, 0, 1013, 1014, 10, 5, 0,
		0, 1014, 1015, 7, 12, 0, 0, 1015, 1073, 3, 100, 50, 6, 1016, 1017, 10,
		2, 0, 0, 1017, 1018, 5, 64, 0, 0, 1018, 1073, 3, 100, 50, 3, 1019, 1020,
		10, 1, 0, 0, 1020, 1021, 5, 65, 0, 0, 1021, 1073, 3, 100, 50, 2, 1022,
		1023, 10, 24, 0, 0, 1023, 1024, 5, 12, 0, 0, 1024, 1026, 3, 6, 3, 0, 1025,
		1027, 3, 14, 7, 0, 1026, 1025, 1, 0, 0, 0, 1026, 1027, 1, 0, 0, 0, 1027,
		1073, 1, 0, 0, 0, 1028, 1029, 10, 23, 0, 0, 1029, 1038, 5, 3, 0, 0, 1030,
		1039, 3, 100, 50, 0, 1031, 1033, 3, 100, 50, 0, 1032, 1031, 1, 0, 0, 0,
		1032, 1033, 1, 0, 0, 0, 1033, 1034, 1, 0, 0, 0, 1034, 1036, 5, 5, 0, 0,
		1035, 1037, 3, 100, 50, 0, 1036, 1035, 1, 0, 0, 0, 1036, 1037, 1, 0, 0,
		0, 1037, 1039, 1, 0, 0, 0, 1038, 1030, 1, 0, 0, 0, 1038, 1032, 1, 0, 0,
		0, 1039, 1040, 1, 0, 0, 0, 1040, 1042, 5, 4, 0, 0, 1041, 1043, 3, 14, 7,
		0, 1042, 1041, 1, 0, 0, 0, 1042, 1043, 1, 0, 0, 0, 1043, 1073, 1, 0, 0,
		0, 1044, 1045, 10, 21, 0, 0, 1045, 1046, 5, 97, 0, 0, 1046, 1073, 3, 6,
		3, 0, 1047, 1049, 10, 8, 0, 0, 1048, 1050, 5, 62, 0, 0, 1049, 1048, 1,
		0, 0, 0, 1049, 1050, 1, 0, 0, 0, 1050, 1051, 1, 0, 0, 0, 1051, 1052, 5,
		68, 0, 0, 1052, 1055, 5, 7, 0, 0, 1053, 1056, 3, 106, 53, 0, 1054, 1056,
		3, 76, 38, 0, 1055, 1053, 1, 0, 0, 0, 1055, 1054, 1, 0, 0, 0, 1056, 1057,
		1, 0, 0, 0, 1057, 1058, 5, 8, 0, 0, 1058, 1073, 1, 0, 0, 0, 1059, 1060,
		10, 4, 0, 0, 1060, 1062, 5, 70, 0, 0, 1061, 1063, 5, 62, 0, 0, 1062, 1061,
		1, 0, 0, 0, 1062, 1063, 1, 0, 0, 0, 1063, 1070, 1, 0, 0, 0, 1064, 1065,
		5, 94, 0, 0, 1065, 1066, 5, 95, 0, 0, 1066, 1071, 3, 100, 50, 0, 1067,
		1071, 5, 57, 0, 0, 1068, 1071, 5, 135, 0, 0, 1069, 1071, 5, 136, 0, 0,
		1070, 1064, 1, 0, 0, 0, 1070, 1067, 1, 0, 0, 0, 1070, 1068, 1, 0, 0, 0,
		1070, 1069, 1, 0, 0, 0, 1071, 1073, 1, 0, 0, 0, 1072, 986, 1, 0, 0, 0,
		1072, 989, 1, 0, 0, 0, 1072, 992, 1, 0, 0, 0, 1072, 995, 1, 0, 0, 0, 1072,
		998, 1, 0, 0, 0, 1072, 1004, 1, 0, 0, 0, 1072, 1013, 1, 0, 0, 0, 1072,
		1016, 1, 0, 0, 0, 1072, 1019, 1, 0, 0, 0, 1072, 1022, 1, 0, 0, 0, 1072,
		1028, 1, 0, 0, 0, 1072, 1044, 1, 0, 0, 0, 1072, 1047, 1, 0, 0, 0, 1072,
		1059, 1, 0, 0, 0, 1073, 1076, 1, 0, 0, 0, 1074, 1072, 1, 0, 0, 0, 1074,
		1075, 1, 0, 0, 0, 1075, 101, 1, 0, 0, 0, 1076, 1074, 1, 0, 0, 0, 1077,
		1081, 5, 7, 0, 0, 1078, 1079, 5, 121, 0, 0, 1079, 1080, 5, 84, 0, 0, 1080,
		1082, 3, 106, 53, 0, 1081, 1078, 1, 0, 0, 0, 1081, 1082, 1, 0, 0, 0, 1082,
		1093, 1, 0, 0, 0, 1083, 1084, 5, 83, 0, 0, 1084, 1085, 5, 84, 0, 0, 1085,
		1090, 3, 80, 40, 0, 1086, 1087, 5, 9, 0, 0, 1087, 1089, 3, 80, 40, 0, 1088,
		1086, 1, 0, 0, 0, 1089, 1092, 1, 0, 0, 0, 1090, 1088, 1, 0, 0, 0, 1090,
		1091, 1, 0, 0, 0, 1091, 1094, 1, 0, 0, 0, 1092, 1090, 1, 0, 0, 0, 1093,
		1083, 1, 0, 0, 0, 1093, 1094, 1, 0, 0, 0, 1094, 1095, 1, 0, 0, 0, 1095,
		1096, 5, 8, 0, 0, 1096, 103, 1, 0, 0, 0, 1097, 1098, 5, 91, 0, 0, 1098,
		1099, 3, 100, 50, 0, 1099, 1100, 5, 92, 0, 0, 1100, 1101, 3, 100, 50, 0,
		1101, 105, 1, 0, 0, 0, 1102, 1107, 3, 100, 50, 0, 1103, 1104, 5, 9, 0,
		0, 1104, 1106, 3, 100, 50, 0, 1105, 1103, 1, 0, 0, 0, 1106, 1109, 1, 0,
		0, 0, 1107, 1105, 1, 0, 0, 0, 1107, 1108, 1, 0, 0, 0, 1108, 107, 1, 0,
		0, 0, 1109, 1107, 1, 0, 0, 0, 1110, 1111, 3, 6, 3, 0, 1111, 1117, 5, 7,
		0, 0, 1112, 1114, 5, 94, 0, 0, 1113, 1112, 1, 0, 0, 0, 1113, 1114, 1, 0,
		0, 0, 1114, 1115, 1, 0, 0, 0, 1115, 1118, 3, 106, 53, 0, 1116, 1118, 5,
		14, 0, 0, 1117, 1113, 1, 0, 0, 0, 1117, 1116, 1, 0, 0, 0, 1117, 1118, 1,
		0, 0, 0, 1118, 1119, 1, 0, 0, 0, 1119, 1120, 5, 8, 0, 0, 1120, 109, 1,
		0, 0, 0, 1121, 1122, 6, 55, -1, 0, 1122, 1123, 5, 7, 0, 0, 1123, 1124,
		3, 110, 55, 0, 1124, 1126, 5, 8, 0, 0, 1125, 1127, 3, 14, 7, 0, 1126, 1125,
		1, 0, 0, 0, 1126, 1127, 1, 0, 0, 0, 1127, 1156, 1, 0, 0, 0, 1128, 1129,
		7, 13, 0, 0, 1129, 1156, 3, 110, 55, 14, 1130, 1132, 3, 4, 2, 0, 1131,
		1133, 3, 14, 7, 0, 1132, 1131, 1, 0, 0, 0, 1132, 1133, 1, 0, 0, 0, 1133,
		1156, 1, 0, 0, 0, 1134, 1136, 3, 118, 59, 0, 1135, 1137, 3, 14, 7, 0, 1136,
		1135, 1, 0, 0, 0, 1136, 1137, 1, 0, 0, 0, 1137, 1156, 1, 0, 0, 0, 1138,
		1140, 3, 16, 8, 0, 1139, 1141, 3, 14, 7, 0, 1140, 1139, 1, 0, 0, 0, 1140,
		1141, 1, 0, 0, 0, 1141, 1156, 1, 0, 0, 0, 1142, 1144, 5, 130, 0, 0, 1143,
		1142, 1, 0, 0, 0, 1143, 1144, 1, 0, 0, 0, 1144, 1145, 1, 0, 0, 0, 1145,
		1147, 5, 3, 0, 0, 1146, 1148, 3, 112, 56, 0, 1147, 1146, 1, 0, 0, 0, 1147,
		1148, 1, 0, 0, 0, 1148, 1149, 1, 0, 0, 0, 1149, 1151, 5, 4, 0, 0, 1150,
		1152, 3, 14, 7, 0, 1151, 1150, 1, 0, 0, 0, 1151, 1152, 1, 0, 0, 0, 1152,
		1156, 1, 0, 0, 0, 1153, 1154, 5, 62, 0, 0, 1154, 1156, 3, 110, 55, 3, 1155,
		1121, 1, 0, 0, 0, 1155, 1128, 1, 0, 0, 0, 1155, 1130, 1, 0, 0, 0, 1155,
		1134, 1, 0, 0, 0, 1155, 1138, 1, 0, 0, 0, 1155, 1143, 1, 0, 0, 0, 1155,
		1153, 1, 0, 0, 0, 1156, 1215, 1, 0, 0, 0, 1157, 1158, 10, 13, 0, 0, 1158,
		1159, 5, 23, 0, 0, 1159, 1214, 3, 110, 55, 14, 1160, 1161, 10, 12, 0, 0,
		1161, 1162, 7, 10, 0, 0, 1162, 1214, 3, 110, 55, 13, 1163, 1164, 10, 11,
		0, 0, 1164, 1165, 7, 0, 0, 0, 1165, 1214, 3, 110, 55, 12, 1166, 1167, 10,
		6, 0, 0, 1167, 1168, 5, 13, 0, 0, 1168, 1214, 3, 110, 55, 7, 1169, 1170,
		10, 5, 0, 0, 1170, 1171, 7, 12, 0, 0, 1171, 1214, 3, 110, 55, 6, 1172,
		1173, 10, 2, 0, 0, 1173, 1174, 5, 64, 0, 0, 1174, 1214, 3, 110, 55, 3,
		1175, 1176, 10, 1, 0, 0, 1176, 1177, 5, 65, 0, 0, 1177, 1214, 3, 110, 55,
		2, 1178, 1179, 10, 16, 0, 0, 1179, 1180, 5, 12, 0, 0, 1180, 1182, 3, 6,
		3, 0, 1181, 1183, 3, 14, 7, 0, 1182, 1181, 1, 0, 0, 0, 1182, 1183, 1, 0,
		0, 0, 1183, 1214, 1, 0, 0, 0, 1184, 1185, 10, 15, 0, 0, 1185, 1194, 5,
		3, 0, 0, 1186, 1195, 3, 110, 55, 0, 1187, 1189, 3, 110, 55, 0, 1188, 1187,
		1, 0, 0, 0, 1188, 1189, 1, 0, 0, 0, 1189, 1190, 1, 0, 0, 0, 1190, 1192,
		5, 5, 0, 0, 1191, 1193, 3, 110, 55, 0, 1192, 1191, 1, 0, 0, 0, 1192, 1193,
		1, 0, 0, 0, 1193, 1195, 1, 0, 0, 0, 1194, 1186, 1, 0, 0, 0, 1194, 1188,
		1, 0, 0, 0, 1195, 1196, 1, 0, 0, 0, 1196, 1198, 5, 4, 0, 0, 1197, 1199,
		3, 14, 7, 0, 1198, 1197, 1, 0, 0, 0, 1198, 1199, 1, 0, 0, 0, 1199, 1214,
		1, 0, 0, 0, 1200, 1201, 10, 4, 0, 0, 1201, 1203, 5, 70, 0, 0, 1202, 1204,
		5, 62, 0, 0, 1203, 1202, 1, 0, 0, 0, 1203, 1204, 1, 0, 0, 0, 1204, 1211,
		1, 0, 0, 0, 1205, 1206, 5, 94, 0, 0, 1206, 1207, 5, 95, 0, 0, 1207, 1212,
		3, 110, 55, 0, 1208, 1212, 5, 57, 0, 0, 1209, 1212, 5, 135, 0, 0, 1210,
		1212, 5, 136, 0, 0, 1211, 1205, 1, 0, 0, 0, 1211, 1208, 1, 0, 0, 0, 1211,
		1209, 1, 0, 0, 0, 1211, 1210, 1, 0, 0, 0, 1212, 1214, 1, 0, 0, 0, 1213,
		1157, 1, 0, 0, 0, 1213, 1160, 1, 0, 0, 0, 1213, 1163, 1, 0, 0, 0, 1213,
		1166, 1, 0, 0, 0, 1213, 1169, 1, 0, 0, 0, 1213, 1172, 1, 0, 0, 0, 1213,
		1175, 1, 0, 0, 0, 1213, 1178, 1, 0, 0, 0, 1213, 1184, 1, 0, 0, 0, 1213,
		1200, 1, 0, 0, 0, 1214, 1217, 1, 0, 0, 0, 1215, 1213, 1, 0, 0, 0, 1215,
		1216, 1, 0, 0, 0, 1216, 111, 1, 0, 0, 0, 1217, 1215, 1, 0, 0, 0, 1218,
		1223, 3, 110, 55, 0, 1219, 1220, 5, 9, 0, 0, 1220, 1222, 3, 110, 55, 0,
		1221, 1219, 1, 0, 0, 0, 1222, 1225, 1, 0, 0, 0, 1223, 1221, 1, 0, 0, 0,
		1223, 1224, 1, 0, 0, 0, 1224, 113, 1, 0, 0, 0, 1225, 1223, 1, 0, 0, 0,
		1226, 1227, 5, 146, 0, 0, 1227, 1228, 3, 12, 6, 0, 1228, 1229, 5, 6, 0,
		0, 1229, 1319, 1, 0, 0, 0, 1230, 1235, 3, 116, 58, 0, 1231, 1232, 5, 9,
		0, 0, 1232, 1234, 3, 116, 58, 0, 1233, 1231, 1, 0, 0, 0, 1234, 1237, 1,
		0, 0, 0, 1235, 1233, 1, 0, 0, 0, 1235, 1236, 1, 0, 0, 0, 1236, 1238, 1,
		0, 0, 0, 1237, 1235, 1, 0, 0, 0, 1238, 1239, 7, 14, 0, 0, 1239, 1241, 1,
		0, 0, 0, 1240, 1230, 1, 0, 0, 0, 1240, 1241, 1, 0, 0, 0, 1241, 1242, 1,
		0, 0, 0, 1242, 1243, 3, 118, 59, 0, 1243, 1244, 5, 6, 0, 0, 1244, 1319,
		1, 0, 0, 0, 1245, 1247, 3, 110, 55, 0, 1246, 1248, 3, 12, 6, 0, 1247, 1246,
		1, 0, 0, 0, 1247, 1248, 1, 0, 0, 0, 1248, 1249, 1, 0, 0, 0, 1249, 1250,
		7, 14, 0, 0, 1250, 1251, 3, 110, 55, 0, 1251, 1252, 5, 6, 0, 0, 1252, 1319,
		1, 0, 0, 0, 1253, 1254, 5, 112, 0, 0, 1254, 1255, 5, 146, 0, 0, 1255, 1262,
		5, 68, 0, 0, 1256, 1263, 3, 122, 61, 0, 1257, 1263, 3, 32, 16, 0, 1258,
		1260, 5, 130, 0, 0, 1259, 1258, 1, 0, 0, 0, 1259, 1260, 1, 0, 0, 0, 1260,
		1261, 1, 0, 0, 0, 1261, 1263, 3, 110, 55, 0, 1262, 1256, 1, 0, 0, 0, 1262,
		1257, 1, 0, 0, 0, 1262, 1259, 1, 0, 0, 0, 1263, 1264, 1, 0, 0, 0, 1264,
		1268, 5, 1, 0, 0, 1265, 1267, 3, 114, 57, 0, 1266, 1265, 1, 0, 0, 0, 1267,
		1270, 1, 0, 0, 0, 1268, 1266, 1, 0, 0, 0, 1268, 1269, 1, 0, 0, 0, 1269,
		1271, 1, 0, 0, 0, 1270, 1268, 1, 0, 0, 0, 1271, 1273, 5, 2, 0, 0, 1272,
		1274, 5, 6, 0, 0, 1273, 1272, 1, 0, 0, 0, 1273, 1274, 1, 0, 0, 0, 1274,
		1319, 1, 0, 0, 0, 1275, 1276, 5, 113, 0, 0, 1276, 1285, 3, 120, 60, 0,
		1277, 1281, 5, 114, 0, 0, 1278, 1279, 5, 115, 0, 0, 1279, 1281, 5, 113,
		0, 0, 1280, 1277, 1, 0, 0, 0, 1280, 1278, 1, 0, 0, 0, 1281, 1282, 1, 0,
		0, 0, 1282, 1284, 3, 120, 60, 0, 1283, 1280, 1, 0, 0, 0, 1284, 1287, 1,
		0, 0, 0, 1285, 1283, 1, 0, 0, 0, 1285, 1286, 1, 0, 0, 0, 1286, 1297, 1,
		0, 0, 0, 1287, 1285, 1, 0, 0, 0, 1288, 1289, 5, 115, 0, 0, 1289, 1293,
		5, 1, 0, 0, 1290, 1292, 3, 114, 57, 0, 1291, 1290, 1, 0, 0, 0, 1292, 1295,
		1, 0, 0, 0, 1293, 1291, 1, 0, 0, 0, 1293, 1294, 1, 0, 0, 0, 1294, 1296,
		1, 0, 0, 0, 1295, 1293, 1, 0, 0, 0, 1296, 1298, 5, 2, 0, 0, 1297, 1288,
		1, 0, 0, 0, 1297, 1298, 1, 0, 0, 0, 1298, 1300, 1, 0, 0, 0, 1299, 1301,
		5, 6, 0, 0, 1300, 1299, 1, 0, 0, 0, 1300, 1301, 1, 0, 0, 0, 1301, 1319,
		1, 0, 0, 0, 1302, 1303, 3, 32, 16, 0, 1303, 1304, 5, 6, 0, 0, 1304, 1319,
		1, 0, 0, 0, 1305, 1306, 7, 15, 0, 0, 1306, 1319, 5, 6, 0, 0, 1307, 1310,
		5, 118, 0, 0, 1308, 1311, 3, 112, 56, 0, 1309, 1311, 3, 32, 16, 0, 1310,
		1308, 1, 0, 0, 0, 1310, 1309, 1, 0, 0, 0, 1310, 1311, 1, 0, 0, 0, 1311,
		1312, 1, 0, 0, 0, 1312, 1319, 5, 6, 0, 0, 1313, 1314, 5, 118, 0, 0, 1314,
		1315, 5, 119, 0, 0, 1315, 1316, 3, 112, 56, 0, 1316, 1317, 5, 6, 0, 0,
		1317, 1319, 1, 0, 0, 0, 1318, 1226, 1, 0, 0, 0, 1318, 1240, 1, 0, 0, 0,
		1318, 1245, 1, 0, 0, 0, 1318, 1253, 1, 0, 0, 0, 1318, 1275, 1, 0, 0, 0,
		1318, 1302, 1, 0, 0, 0, 1318, 1305, 1, 0, 0, 0, 1318, 1307, 1, 0, 0, 0,
		1318, 1313, 1, 0, 0, 0, 1319, 115, 1, 0, 0, 0, 1320, 1321, 7, 16, 0, 0,
		1321, 117, 1, 0, 0, 0, 1322, 1323, 3, 6, 3, 0, 1323, 1324, 5, 12, 0, 0,
		1324, 1326, 1, 0, 0, 0, 1325, 1322, 1, 0, 0, 0, 1325, 1326, 1, 0, 0, 0,
		1326, 1327, 1, 0, 0, 0, 1327, 1328, 3, 6, 3, 0, 1328, 1330, 5, 7, 0, 0,
		1329, 1331, 3, 112, 56, 0, 1330, 1329, 1, 0, 0, 0, 1330, 1331, 1, 0, 0,
		0, 1331, 1332, 1, 0, 0, 0, 1332, 1333, 5, 8, 0, 0, 1333, 119, 1, 0, 0,
		0, 1334, 1335, 3, 110, 55, 0, 1335, 1339, 5, 1, 0, 0, 1336, 1338, 3, 114,
		57, 0, 1337, 1336, 1, 0, 0, 0, 1338, 1341, 1, 0, 0, 0, 1339, 1337, 1, 0,
		0, 0, 1339, 1340, 1, 0, 0, 0, 1340, 1342, 1, 0, 0, 0, 1341, 1339, 1, 0,
		0, 0, 1342, 1343, 5, 2, 0, 0, 1343, 121, 1, 0, 0, 0, 1344, 1345, 3, 110,
		55, 0, 1345, 1346, 5, 32, 0, 0, 1346, 1347, 3, 110, 55, 0, 1347, 123, 1,
		0, 0, 0, 190, 129, 133, 141, 159, 163, 167, 175, 182, 191, 199, 202, 206,
		218, 226, 237, 253, 265, 271, 279, 281, 285, 295, 299, 306, 309, 315, 324,
		327, 330, 342, 348, 353, 357, 364, 389, 397, 401, 416, 425, 449, 453, 459,
		462, 474, 483, 491, 499, 503, 507, 513, 518, 522, 526, 532, 539, 547, 553,
		564, 567, 573, 577, 583, 592, 600, 614, 617, 620, 629, 636, 644, 654, 664,
		667, 671, 675, 679, 683, 687, 691, 695, 702, 710, 713, 717, 724, 726, 739,
		742, 747, 751, 754, 760, 763, 765, 768, 777, 780, 785, 788, 793, 796, 804,
		812, 815, 819, 829, 832, 838, 851, 855, 858, 867, 869, 880, 885, 887, 893,
		896, 900, 907, 913, 922, 927, 931, 935, 940, 944, 949, 953, 957, 962, 966,
		971, 974, 980, 984, 1000, 1006, 1026, 1032, 1036, 1038, 1042, 1049, 1055,
		1062, 1070, 1072, 1074, 1081, 1090, 1093, 1107, 1113, 1117, 1126, 1132,
		1136, 1140, 1143, 1147, 1151, 1155, 1182, 1188, 1192, 1194, 1198, 1203,
		1211, 1213, 1215, 1223, 1235, 1240, 1247, 1259, 1262, 1268, 1273, 1280,
		1285, 1293, 1297, 1300, 1310, 1318, 1325, 1330, 1339,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// KuneiformParserInit initializes any static state used to implement KuneiformParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewKuneiformParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func KuneiformParserInit() {
	staticData := &KuneiformParserParserStaticData
	staticData.once.Do(kuneiformparserParserInit)
}

// NewKuneiformParser produces a new parser instance for the optional input antlr.TokenStream.
func NewKuneiformParser(input antlr.TokenStream) *KuneiformParser {
	KuneiformParserInit()
	this := new(KuneiformParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &KuneiformParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "KuneiformParser.g4"

	return this
}

// KuneiformParser tokens.
const (
	KuneiformParserEOF                 = antlr.TokenEOF
	KuneiformParserLBRACE              = 1
	KuneiformParserRBRACE              = 2
	KuneiformParserLBRACKET            = 3
	KuneiformParserRBRACKET            = 4
	KuneiformParserCOL                 = 5
	KuneiformParserSCOL                = 6
	KuneiformParserLPAREN              = 7
	KuneiformParserRPAREN              = 8
	KuneiformParserCOMMA               = 9
	KuneiformParserAT                  = 10
	KuneiformParserEXCL                = 11
	KuneiformParserPERIOD              = 12
	KuneiformParserCONCAT              = 13
	KuneiformParserSTAR                = 14
	KuneiformParserEQUALS              = 15
	KuneiformParserEQUATE              = 16
	KuneiformParserHASH                = 17
	KuneiformParserDOLLAR              = 18
	KuneiformParserMOD                 = 19
	KuneiformParserPLUS                = 20
	KuneiformParserMINUS               = 21
	KuneiformParserDIV                 = 22
	KuneiformParserEXP                 = 23
	KuneiformParserNEQ                 = 24
	KuneiformParserLT                  = 25
	KuneiformParserLTE                 = 26
	KuneiformParserGT                  = 27
	KuneiformParserGTE                 = 28
	KuneiformParserTYPE_CAST           = 29
	KuneiformParserUNDERSCORE          = 30
	KuneiformParserASSIGN              = 31
	KuneiformParserRANGE               = 32
	KuneiformParserDOUBLE_QUOTE        = 33
	KuneiformParserUSE                 = 34
	KuneiformParserUNUSE               = 35
	KuneiformParserTABLE               = 36
	KuneiformParserACTION              = 37
	KuneiformParserCREATE              = 38
	KuneiformParserALTER               = 39
	KuneiformParserCOLUMN              = 40
	KuneiformParserADD                 = 41
	KuneiformParserDROP                = 42
	KuneiformParserRENAME              = 43
	KuneiformParserTO                  = 44
	KuneiformParserCONSTRAINT          = 45
	KuneiformParserCHECK               = 46
	KuneiformParserFOREIGN             = 47
	KuneiformParserPRIMARY             = 48
	KuneiformParserKEY                 = 49
	KuneiformParserON                  = 50
	KuneiformParserDO                  = 51
	KuneiformParserUNIQUE              = 52
	KuneiformParserCASCADE             = 53
	KuneiformParserRESTRICT            = 54
	KuneiformParserSET                 = 55
	KuneiformParserDEFAULT             = 56
	KuneiformParserNULL                = 57
	KuneiformParserDELETE              = 58
	KuneiformParserUPDATE              = 59
	KuneiformParserREFERENCES          = 60
	KuneiformParserREF                 = 61
	KuneiformParserNOT                 = 62
	KuneiformParserINDEX               = 63
	KuneiformParserAND                 = 64
	KuneiformParserOR                  = 65
	KuneiformParserLIKE                = 66
	KuneiformParserILIKE               = 67
	KuneiformParserIN                  = 68
	KuneiformParserBETWEEN             = 69
	KuneiformParserIS                  = 70
	KuneiformParserEXISTS              = 71
	KuneiformParserALL                 = 72
	KuneiformParserANY                 = 73
	KuneiformParserJOIN                = 74
	KuneiformParserLEFT                = 75
	KuneiformParserRIGHT               = 76
	KuneiformParserINNER               = 77
	KuneiformParserAS                  = 78
	KuneiformParserASC                 = 79
	KuneiformParserDESC                = 80
	KuneiformParserLIMIT               = 81
	KuneiformParserOFFSET              = 82
	KuneiformParserORDER               = 83
	KuneiformParserBY                  = 84
	KuneiformParserGROUP               = 85
	KuneiformParserHAVING              = 86
	KuneiformParserRETURNS             = 87
	KuneiformParserNO                  = 88
	KuneiformParserWITH                = 89
	KuneiformParserCASE                = 90
	KuneiformParserWHEN                = 91
	KuneiformParserTHEN                = 92
	KuneiformParserEND                 = 93
	KuneiformParserDISTINCT            = 94
	KuneiformParserFROM                = 95
	KuneiformParserWHERE               = 96
	KuneiformParserCOLLATE             = 97
	KuneiformParserSELECT              = 98
	KuneiformParserINSERT              = 99
	KuneiformParserVALUES              = 100
	KuneiformParserFULL                = 101
	KuneiformParserUNION               = 102
	KuneiformParserINTERSECT           = 103
	KuneiformParserEXCEPT              = 104
	KuneiformParserNULLS               = 105
	KuneiformParserFIRST               = 106
	KuneiformParserLAST                = 107
	KuneiformParserRETURNING           = 108
	KuneiformParserINTO                = 109
	KuneiformParserCONFLICT            = 110
	KuneiformParserNOTHING             = 111
	KuneiformParserFOR                 = 112
	KuneiformParserIF                  = 113
	KuneiformParserELSEIF              = 114
	KuneiformParserELSE                = 115
	KuneiformParserBREAK               = 116
	KuneiformParserCONTINUE            = 117
	KuneiformParserRETURN              = 118
	KuneiformParserNEXT                = 119
	KuneiformParserOVER                = 120
	KuneiformParserPARTITION           = 121
	KuneiformParserWINDOW              = 122
	KuneiformParserFILTER              = 123
	KuneiformParserRECURSIVE           = 124
	KuneiformParserGRANT               = 125
	KuneiformParserGRANTED             = 126
	KuneiformParserREVOKE              = 127
	KuneiformParserROLE                = 128
	KuneiformParserREPLACE             = 129
	KuneiformParserARRAY               = 130
	KuneiformParserNAMESPACE           = 131
	KuneiformParserROLES               = 132
	KuneiformParserCALL                = 133
	KuneiformParserSTRING_             = 134
	KuneiformParserTRUE                = 135
	KuneiformParserFALSE               = 136
	KuneiformParserDIGITS_             = 137
	KuneiformParserBINARY_             = 138
	KuneiformParserLEGACY_FOREIGN_KEY  = 139
	KuneiformParserLEGACY_ON_UPDATE    = 140
	KuneiformParserLEGACY_ON_DELETE    = 141
	KuneiformParserLEGACY_SET_DEFAULT  = 142
	KuneiformParserLEGACY_SET_NULL     = 143
	KuneiformParserLEGACY_NO_ACTION    = 144
	KuneiformParserIDENTIFIER          = 145
	KuneiformParserVARIABLE            = 146
	KuneiformParserCONTEXTUAL_VARIABLE = 147
	KuneiformParserHASH_IDENTIFIER     = 148
	KuneiformParserWS                  = 149
	KuneiformParserBLOCK_COMMENT       = 150
	KuneiformParserLINE_COMMENT        = 151
	KuneiformParserSQL_COMMENT         = 152
)

// KuneiformParser rules.
const (
	KuneiformParserRULE_entry                      = 0
	KuneiformParserRULE_statement                  = 1
	KuneiformParserRULE_literal                    = 2
	KuneiformParserRULE_identifier                 = 3
	KuneiformParserRULE_allowed_identifier         = 4
	KuneiformParserRULE_identifier_list            = 5
	KuneiformParserRULE_type                       = 6
	KuneiformParserRULE_type_cast                  = 7
	KuneiformParserRULE_variable                   = 8
	KuneiformParserRULE_table_column_def           = 9
	KuneiformParserRULE_type_list                  = 10
	KuneiformParserRULE_named_type_list            = 11
	KuneiformParserRULE_inline_constraint          = 12
	KuneiformParserRULE_fk_action                  = 13
	KuneiformParserRULE_fk_constraint              = 14
	KuneiformParserRULE_action_return              = 15
	KuneiformParserRULE_sql_statement              = 16
	KuneiformParserRULE_common_table_expression    = 17
	KuneiformParserRULE_create_table_statement     = 18
	KuneiformParserRULE_table_constraint_def       = 19
	KuneiformParserRULE_opt_drop_behavior          = 20
	KuneiformParserRULE_drop_table_statement       = 21
	KuneiformParserRULE_alter_table_statement      = 22
	KuneiformParserRULE_alter_table_action         = 23
	KuneiformParserRULE_create_index_statement     = 24
	KuneiformParserRULE_drop_index_statement       = 25
	KuneiformParserRULE_create_role_statement      = 26
	KuneiformParserRULE_drop_role_statement        = 27
	KuneiformParserRULE_grant_statement            = 28
	KuneiformParserRULE_revoke_statement           = 29
	KuneiformParserRULE_privilege_list             = 30
	KuneiformParserRULE_privilege                  = 31
	KuneiformParserRULE_create_action_statement    = 32
	KuneiformParserRULE_drop_action_statement      = 33
	KuneiformParserRULE_use_extension_statement    = 34
	KuneiformParserRULE_unuse_extension_statement  = 35
	KuneiformParserRULE_create_namespace_statement = 36
	KuneiformParserRULE_drop_namespace_statement   = 37
	KuneiformParserRULE_select_statement           = 38
	KuneiformParserRULE_compound_operator          = 39
	KuneiformParserRULE_ordering_term              = 40
	KuneiformParserRULE_select_core                = 41
	KuneiformParserRULE_relation                   = 42
	KuneiformParserRULE_join                       = 43
	KuneiformParserRULE_result_column              = 44
	KuneiformParserRULE_update_statement           = 45
	KuneiformParserRULE_update_set_clause          = 46
	KuneiformParserRULE_insert_statement           = 47
	KuneiformParserRULE_upsert_clause              = 48
	KuneiformParserRULE_delete_statement           = 49
	KuneiformParserRULE_sql_expr                   = 50
	KuneiformParserRULE_window                     = 51
	KuneiformParserRULE_when_then_clause           = 52
	KuneiformParserRULE_sql_expr_list              = 53
	KuneiformParserRULE_sql_function_call          = 54
	KuneiformParserRULE_action_expr                = 55
	KuneiformParserRULE_action_expr_list           = 56
	KuneiformParserRULE_action_statement           = 57
	KuneiformParserRULE_variable_or_underscore     = 58
	KuneiformParserRULE_action_function_call       = 59
	KuneiformParserRULE_if_then_block              = 60
	KuneiformParserRULE_range                      = 61
)

// IEntryContext is an interface to support dynamic dispatch.
type IEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	EOF() antlr.TerminalNode
	AllSCOL() []antlr.TerminalNode
	SCOL(i int) antlr.TerminalNode

	// IsEntryContext differentiates from other interfaces.
	IsEntryContext()
}

type EntryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntryContext() *EntryContext {
	var p = new(EntryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_entry
	return p
}

func InitEmptyEntryContext(p *EntryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_entry
}

func (*EntryContext) IsEntryContext() {}

func NewEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EntryContext {
	var p = new(EntryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_entry

	return p
}

func (s *EntryContext) GetParser() antlr.Parser { return s.parser }

func (s *EntryContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *EntryContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *EntryContext) EOF() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEOF, 0)
}

func (s *EntryContext) AllSCOL() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserSCOL)
}

func (s *EntryContext) SCOL(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, i)
}

func (s *EntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Entry() (localctx IEntryContext) {
	localctx = NewEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, KuneiformParserRULE_entry)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(124)
		p.Statement()
	}
	p.SetState(129)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(125)
				p.Match(KuneiformParserSCOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(126)
				p.Statement()
			}

		}
		p.SetState(131)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(133)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserSCOL {
		{
			p.SetState(132)
			p.Match(KuneiformParserSCOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(135)
		p.Match(KuneiformParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNamespace returns the namespace rule contexts.
	GetNamespace() IIdentifierContext

	// SetNamespace sets the namespace rule contexts.
	SetNamespace(IIdentifierContext)

	// Getter signatures
	Sql_statement() ISql_statementContext
	Create_table_statement() ICreate_table_statementContext
	Alter_table_statement() IAlter_table_statementContext
	Drop_table_statement() IDrop_table_statementContext
	Create_index_statement() ICreate_index_statementContext
	Drop_index_statement() IDrop_index_statementContext
	Create_role_statement() ICreate_role_statementContext
	Drop_role_statement() IDrop_role_statementContext
	Grant_statement() IGrant_statementContext
	Revoke_statement() IRevoke_statementContext
	Create_action_statement() ICreate_action_statementContext
	Drop_action_statement() IDrop_action_statementContext
	Use_extension_statement() IUse_extension_statementContext
	Unuse_extension_statement() IUnuse_extension_statementContext
	Create_namespace_statement() ICreate_namespace_statementContext
	Drop_namespace_statement() IDrop_namespace_statementContext
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	namespace IIdentifierContext
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) GetNamespace() IIdentifierContext { return s.namespace }

func (s *StatementContext) SetNamespace(v IIdentifierContext) { s.namespace = v }

func (s *StatementContext) Sql_statement() ISql_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_statementContext)
}

func (s *StatementContext) Create_table_statement() ICreate_table_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_statementContext)
}

func (s *StatementContext) Alter_table_statement() IAlter_table_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_statementContext)
}

func (s *StatementContext) Drop_table_statement() IDrop_table_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_table_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_table_statementContext)
}

func (s *StatementContext) Create_index_statement() ICreate_index_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_index_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_index_statementContext)
}

func (s *StatementContext) Drop_index_statement() IDrop_index_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_index_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_index_statementContext)
}

func (s *StatementContext) Create_role_statement() ICreate_role_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_role_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_role_statementContext)
}

func (s *StatementContext) Drop_role_statement() IDrop_role_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_role_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_role_statementContext)
}

func (s *StatementContext) Grant_statement() IGrant_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrant_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrant_statementContext)
}

func (s *StatementContext) Revoke_statement() IRevoke_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevoke_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevoke_statementContext)
}

func (s *StatementContext) Create_action_statement() ICreate_action_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_action_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_action_statementContext)
}

func (s *StatementContext) Drop_action_statement() IDrop_action_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_action_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_action_statementContext)
}

func (s *StatementContext) Use_extension_statement() IUse_extension_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUse_extension_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUse_extension_statementContext)
}

func (s *StatementContext) Unuse_extension_statement() IUnuse_extension_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnuse_extension_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnuse_extension_statementContext)
}

func (s *StatementContext) Create_namespace_statement() ICreate_namespace_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_namespace_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_namespace_statementContext)
}

func (s *StatementContext) Drop_namespace_statement() IDrop_namespace_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_namespace_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_namespace_statementContext)
}

func (s *StatementContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACE, 0)
}

func (s *StatementContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACE, 0)
}

func (s *StatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, KuneiformParserRULE_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(141)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserLBRACE {
		{
			p.SetState(137)
			p.Match(KuneiformParserLBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(138)

			var _x = p.Identifier()

			localctx.(*StatementContext).namespace = _x
		}
		{
			p.SetState(139)
			p.Match(KuneiformParserRBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(159)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(143)
			p.Sql_statement()
		}

	case 2:
		{
			p.SetState(144)
			p.Create_table_statement()
		}

	case 3:
		{
			p.SetState(145)
			p.Alter_table_statement()
		}

	case 4:
		{
			p.SetState(146)
			p.Drop_table_statement()
		}

	case 5:
		{
			p.SetState(147)
			p.Create_index_statement()
		}

	case 6:
		{
			p.SetState(148)
			p.Drop_index_statement()
		}

	case 7:
		{
			p.SetState(149)
			p.Create_role_statement()
		}

	case 8:
		{
			p.SetState(150)
			p.Drop_role_statement()
		}

	case 9:
		{
			p.SetState(151)
			p.Grant_statement()
		}

	case 10:
		{
			p.SetState(152)
			p.Revoke_statement()
		}

	case 11:
		{
			p.SetState(153)
			p.Create_action_statement()
		}

	case 12:
		{
			p.SetState(154)
			p.Drop_action_statement()
		}

	case 13:
		{
			p.SetState(155)
			p.Use_extension_statement()
		}

	case 14:
		{
			p.SetState(156)
			p.Unuse_extension_statement()
		}

	case 15:
		{
			p.SetState(157)
			p.Create_namespace_statement()
		}

	case 16:
		{
			p.SetState(158)
			p.Drop_namespace_statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) CopyAll(ctx *LiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type String_literalContext struct {
	LiteralContext
}

func NewString_literalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *String_literalContext {
	var p = new(String_literalContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *String_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_literalContext) STRING_() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSTRING_, 0)
}

func (s *String_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitString_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

type Decimal_literalContext struct {
	LiteralContext
}

func NewDecimal_literalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Decimal_literalContext {
	var p = new(Decimal_literalContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *Decimal_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Decimal_literalContext) AllDIGITS_() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserDIGITS_)
}

func (s *Decimal_literalContext) DIGITS_(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserDIGITS_, i)
}

func (s *Decimal_literalContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPERIOD, 0)
}

func (s *Decimal_literalContext) PLUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPLUS, 0)
}

func (s *Decimal_literalContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserMINUS, 0)
}

func (s *Decimal_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitDecimal_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

type Null_literalContext struct {
	LiteralContext
}

func NewNull_literalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Null_literalContext {
	var p = new(Null_literalContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *Null_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Null_literalContext) NULL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNULL, 0)
}

func (s *Null_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitNull_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

type Boolean_literalContext struct {
	LiteralContext
}

func NewBoolean_literalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Boolean_literalContext {
	var p = new(Boolean_literalContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *Boolean_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Boolean_literalContext) TRUE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserTRUE, 0)
}

func (s *Boolean_literalContext) FALSE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFALSE, 0)
}

func (s *Boolean_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitBoolean_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

type Integer_literalContext struct {
	LiteralContext
}

func NewInteger_literalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Integer_literalContext {
	var p = new(Integer_literalContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *Integer_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_literalContext) DIGITS_() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDIGITS_, 0)
}

func (s *Integer_literalContext) PLUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPLUS, 0)
}

func (s *Integer_literalContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserMINUS, 0)
}

func (s *Integer_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitInteger_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

type Binary_literalContext struct {
	LiteralContext
}

func NewBinary_literalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Binary_literalContext {
	var p = new(Binary_literalContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *Binary_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Binary_literalContext) BINARY_() antlr.TerminalNode {
	return s.GetToken(KuneiformParserBINARY_, 0)
}

func (s *Binary_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitBinary_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, KuneiformParserRULE_literal)
	var _la int

	p.SetState(175)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) {
	case 1:
		localctx = NewString_literalContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(161)
			p.Match(KuneiformParserSTRING_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewInteger_literalContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(163)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserPLUS || _la == KuneiformParserMINUS {
			{
				p.SetState(162)
				_la = p.GetTokenStream().LA(1)

				if !(_la == KuneiformParserPLUS || _la == KuneiformParserMINUS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(165)
			p.Match(KuneiformParserDIGITS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewDecimal_literalContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(167)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserPLUS || _la == KuneiformParserMINUS {
			{
				p.SetState(166)
				_la = p.GetTokenStream().LA(1)

				if !(_la == KuneiformParserPLUS || _la == KuneiformParserMINUS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(169)
			p.Match(KuneiformParserDIGITS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(170)
			p.Match(KuneiformParserPERIOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(171)
			p.Match(KuneiformParserDIGITS_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewBoolean_literalContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(172)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KuneiformParserTRUE || _la == KuneiformParserFALSE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 5:
		localctx = NewNull_literalContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(173)
			p.Match(KuneiformParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewBinary_literalContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(174)
			p.Match(KuneiformParserBINARY_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDOUBLE_QUOTE() []antlr.TerminalNode
	DOUBLE_QUOTE(i int) antlr.TerminalNode
	Allowed_identifier() IAllowed_identifierContext

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) AllDOUBLE_QUOTE() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserDOUBLE_QUOTE)
}

func (s *IdentifierContext) DOUBLE_QUOTE(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserDOUBLE_QUOTE, i)
}

func (s *IdentifierContext) Allowed_identifier() IAllowed_identifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAllowed_identifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAllowed_identifierContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, KuneiformParserRULE_identifier)
	p.SetState(182)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KuneiformParserDOUBLE_QUOTE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(177)
			p.Match(KuneiformParserDOUBLE_QUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(178)
			p.Allowed_identifier()
		}
		{
			p.SetState(179)
			p.Match(KuneiformParserDOUBLE_QUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KuneiformParserUSE, KuneiformParserUNUSE, KuneiformParserACTION, KuneiformParserCREATE, KuneiformParserALTER, KuneiformParserADD, KuneiformParserDROP, KuneiformParserRENAME, KuneiformParserCHECK, KuneiformParserFOREIGN, KuneiformParserPRIMARY, KuneiformParserKEY, KuneiformParserUNIQUE, KuneiformParserRESTRICT, KuneiformParserDEFAULT, KuneiformParserINDEX, KuneiformParserRETURNS, KuneiformParserCONFLICT, KuneiformParserFOR, KuneiformParserIF, KuneiformParserELSEIF, KuneiformParserELSE, KuneiformParserBREAK, KuneiformParserCONTINUE, KuneiformParserRETURN, KuneiformParserGRANT, KuneiformParserGRANTED, KuneiformParserREVOKE, KuneiformParserROLE, KuneiformParserREPLACE, KuneiformParserNAMESPACE, KuneiformParserROLES, KuneiformParserCALL, KuneiformParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(181)
			p.Allowed_identifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAllowed_identifierContext is an interface to support dynamic dispatch.
type IAllowed_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	ADD() antlr.TerminalNode
	DROP() antlr.TerminalNode
	RENAME() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	FOREIGN() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	RESTRICT() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	CONFLICT() antlr.TerminalNode
	FOR() antlr.TerminalNode
	IF() antlr.TerminalNode
	ELSEIF() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	BREAK() antlr.TerminalNode
	CONTINUE() antlr.TerminalNode
	RETURN() antlr.TerminalNode
	GRANT() antlr.TerminalNode
	GRANTED() antlr.TerminalNode
	REVOKE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	NAMESPACE() antlr.TerminalNode
	ROLES() antlr.TerminalNode
	CALL() antlr.TerminalNode
	USE() antlr.TerminalNode
	UNUSE() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	ACTION() antlr.TerminalNode

	// IsAllowed_identifierContext differentiates from other interfaces.
	IsAllowed_identifierContext()
}

type Allowed_identifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAllowed_identifierContext() *Allowed_identifierContext {
	var p = new(Allowed_identifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_allowed_identifier
	return p
}

func InitEmptyAllowed_identifierContext(p *Allowed_identifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_allowed_identifier
}

func (*Allowed_identifierContext) IsAllowed_identifierContext() {}

func NewAllowed_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Allowed_identifierContext {
	var p = new(Allowed_identifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_allowed_identifier

	return p
}

func (s *Allowed_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Allowed_identifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIDENTIFIER, 0)
}

func (s *Allowed_identifierContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCREATE, 0)
}

func (s *Allowed_identifierContext) ALTER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserALTER, 0)
}

func (s *Allowed_identifierContext) ADD() antlr.TerminalNode {
	return s.GetToken(KuneiformParserADD, 0)
}

func (s *Allowed_identifierContext) DROP() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDROP, 0)
}

func (s *Allowed_identifierContext) RENAME() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRENAME, 0)
}

func (s *Allowed_identifierContext) CHECK() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCHECK, 0)
}

func (s *Allowed_identifierContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFOREIGN, 0)
}

func (s *Allowed_identifierContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPRIMARY, 0)
}

func (s *Allowed_identifierContext) KEY() antlr.TerminalNode {
	return s.GetToken(KuneiformParserKEY, 0)
}

func (s *Allowed_identifierContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUNIQUE, 0)
}

func (s *Allowed_identifierContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRESTRICT, 0)
}

func (s *Allowed_identifierContext) INDEX() antlr.TerminalNode {
	return s.GetToken(KuneiformParserINDEX, 0)
}

func (s *Allowed_identifierContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRETURNS, 0)
}

func (s *Allowed_identifierContext) CONFLICT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCONFLICT, 0)
}

func (s *Allowed_identifierContext) FOR() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFOR, 0)
}

func (s *Allowed_identifierContext) IF() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIF, 0)
}

func (s *Allowed_identifierContext) ELSEIF() antlr.TerminalNode {
	return s.GetToken(KuneiformParserELSEIF, 0)
}

func (s *Allowed_identifierContext) ELSE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserELSE, 0)
}

func (s *Allowed_identifierContext) BREAK() antlr.TerminalNode {
	return s.GetToken(KuneiformParserBREAK, 0)
}

func (s *Allowed_identifierContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCONTINUE, 0)
}

func (s *Allowed_identifierContext) RETURN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRETURN, 0)
}

func (s *Allowed_identifierContext) GRANT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserGRANT, 0)
}

func (s *Allowed_identifierContext) GRANTED() antlr.TerminalNode {
	return s.GetToken(KuneiformParserGRANTED, 0)
}

func (s *Allowed_identifierContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserREVOKE, 0)
}

func (s *Allowed_identifierContext) ROLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserROLE, 0)
}

func (s *Allowed_identifierContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserREPLACE, 0)
}

func (s *Allowed_identifierContext) NAMESPACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNAMESPACE, 0)
}

func (s *Allowed_identifierContext) ROLES() antlr.TerminalNode {
	return s.GetToken(KuneiformParserROLES, 0)
}

func (s *Allowed_identifierContext) CALL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCALL, 0)
}

func (s *Allowed_identifierContext) USE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUSE, 0)
}

func (s *Allowed_identifierContext) UNUSE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUNUSE, 0)
}

func (s *Allowed_identifierContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDEFAULT, 0)
}

func (s *Allowed_identifierContext) ACTION() antlr.TerminalNode {
	return s.GetToken(KuneiformParserACTION, 0)
}

func (s *Allowed_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Allowed_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Allowed_identifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitAllowed_identifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Allowed_identifier() (localctx IAllowed_identifierContext) {
	localctx = NewAllowed_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, KuneiformParserRULE_allowed_identifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(184)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9127724506742259712) != 0) || ((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&288362046938939393) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifier_listContext is an interface to support dynamic dispatch.
type IIdentifier_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentifier_listContext differentiates from other interfaces.
	IsIdentifier_listContext()
}

type Identifier_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifier_listContext() *Identifier_listContext {
	var p = new(Identifier_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_identifier_list
	return p
}

func InitEmptyIdentifier_listContext(p *Identifier_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_identifier_list
}

func (*Identifier_listContext) IsIdentifier_listContext() {}

func NewIdentifier_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Identifier_listContext {
	var p = new(Identifier_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_identifier_list

	return p
}

func (s *Identifier_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Identifier_listContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Identifier_listContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Identifier_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Identifier_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Identifier_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Identifier_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Identifier_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitIdentifier_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Identifier_list() (localctx IIdentifier_listContext) {
	localctx = NewIdentifier_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, KuneiformParserRULE_identifier_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(186)
		p.Identifier()
	}
	p.SetState(191)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCOMMA {
		{
			p.SetState(187)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(188)
			p.Identifier()
		}

		p.SetState(193)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPrecision returns the precision token.
	GetPrecision() antlr.Token

	// GetScale returns the scale token.
	GetScale() antlr.Token

	// SetPrecision sets the precision token.
	SetPrecision(antlr.Token)

	// SetScale sets the scale token.
	SetScale(antlr.Token)

	// Getter signatures
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	LBRACKET() antlr.TerminalNode
	RBRACKET() antlr.TerminalNode
	AllDIGITS_() []antlr.TerminalNode
	DIGITS_(i int) antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	precision antlr.Token
	scale     antlr.Token
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_type
	return p
}

func InitEmptyTypeContext(p *TypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_type
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) GetPrecision() antlr.Token { return s.precision }

func (s *TypeContext) GetScale() antlr.Token { return s.scale }

func (s *TypeContext) SetPrecision(v antlr.Token) { s.precision = v }

func (s *TypeContext) SetScale(v antlr.Token) { s.scale = v }

func (s *TypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *TypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *TypeContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACKET, 0)
}

func (s *TypeContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACKET, 0)
}

func (s *TypeContext) AllDIGITS_() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserDIGITS_)
}

func (s *TypeContext) DIGITS_(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserDIGITS_, i)
}

func (s *TypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, 0)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Type_() (localctx ITypeContext) {
	localctx = NewTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, KuneiformParserRULE_type)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(194)
		p.Identifier()
	}
	p.SetState(202)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(195)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(196)

			var _m = p.Match(KuneiformParserDIGITS_)

			localctx.(*TypeContext).precision = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(199)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserCOMMA {
			{
				p.SetState(197)
				p.Match(KuneiformParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(198)

				var _m = p.Match(KuneiformParserDIGITS_)

				localctx.(*TypeContext).scale = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(201)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(206)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(204)
			p.Match(KuneiformParserLBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(205)
			p.Match(KuneiformParserRBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_castContext is an interface to support dynamic dispatch.
type IType_castContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE_CAST() antlr.TerminalNode
	Type_() ITypeContext

	// IsType_castContext differentiates from other interfaces.
	IsType_castContext()
}

type Type_castContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_castContext() *Type_castContext {
	var p = new(Type_castContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_type_cast
	return p
}

func InitEmptyType_castContext(p *Type_castContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_type_cast
}

func (*Type_castContext) IsType_castContext() {}

func NewType_castContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_castContext {
	var p = new(Type_castContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_type_cast

	return p
}

func (s *Type_castContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_castContext) TYPE_CAST() antlr.TerminalNode {
	return s.GetToken(KuneiformParserTYPE_CAST, 0)
}

func (s *Type_castContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Type_castContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_castContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_castContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitType_cast(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Type_cast() (localctx IType_castContext) {
	localctx = NewType_castContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, KuneiformParserRULE_type_cast)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(208)
		p.Match(KuneiformParserTYPE_CAST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(209)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VARIABLE() antlr.TerminalNode
	CONTEXTUAL_VARIABLE() antlr.TerminalNode

	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_variable
	return p
}

func InitEmptyVariableContext(p *VariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_variable
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserVARIABLE, 0)
}

func (s *VariableContext) CONTEXTUAL_VARIABLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCONTEXTUAL_VARIABLE, 0)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Variable() (localctx IVariableContext) {
	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, KuneiformParserRULE_variable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(211)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KuneiformParserVARIABLE || _la == KuneiformParserCONTEXTUAL_VARIABLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_column_defContext is an interface to support dynamic dispatch.
type ITable_column_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	Type_() ITypeContext
	Identifier() IIdentifierContext
	AllInline_constraint() []IInline_constraintContext
	Inline_constraint(i int) IInline_constraintContext

	// IsTable_column_defContext differentiates from other interfaces.
	IsTable_column_defContext()
}

type Table_column_defContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyTable_column_defContext() *Table_column_defContext {
	var p = new(Table_column_defContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_table_column_def
	return p
}

func InitEmptyTable_column_defContext(p *Table_column_defContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_table_column_def
}

func (*Table_column_defContext) IsTable_column_defContext() {}

func NewTable_column_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_column_defContext {
	var p = new(Table_column_defContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_table_column_def

	return p
}

func (s *Table_column_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_column_defContext) GetName() IIdentifierContext { return s.name }

func (s *Table_column_defContext) SetName(v IIdentifierContext) { s.name = v }

func (s *Table_column_defContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Table_column_defContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Table_column_defContext) AllInline_constraint() []IInline_constraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInline_constraintContext); ok {
			len++
		}
	}

	tst := make([]IInline_constraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInline_constraintContext); ok {
			tst[i] = t.(IInline_constraintContext)
			i++
		}
	}

	return tst
}

func (s *Table_column_defContext) Inline_constraint(i int) IInline_constraintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInline_constraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInline_constraintContext)
}

func (s *Table_column_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_column_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_column_defContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitTable_column_def(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Table_column_def() (localctx ITable_column_defContext) {
	localctx = NewTable_column_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, KuneiformParserRULE_table_column_def)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(213)

		var _x = p.Identifier()

		localctx.(*Table_column_defContext).name = _x
	}
	{
		p.SetState(214)
		p.Type_()
	}
	p.SetState(218)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&5841520560420421632) != 0 {
		{
			p.SetState(215)
			p.Inline_constraint()
		}

		p.SetState(220)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_listContext is an interface to support dynamic dispatch.
type IType_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsType_listContext differentiates from other interfaces.
	IsType_listContext()
}

type Type_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_listContext() *Type_listContext {
	var p = new(Type_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_type_list
	return p
}

func InitEmptyType_listContext(p *Type_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_type_list
}

func (*Type_listContext) IsType_listContext() {}

func NewType_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_listContext {
	var p = new(Type_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_type_list

	return p
}

func (s *Type_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_listContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *Type_listContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Type_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Type_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Type_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitType_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Type_list() (localctx IType_listContext) {
	localctx = NewType_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, KuneiformParserRULE_type_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(221)
		p.Type_()
	}
	p.SetState(226)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCOMMA {
		{
			p.SetState(222)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(223)
			p.Type_()
		}

		p.SetState(228)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamed_type_listContext is an interface to support dynamic dispatch.
type INamed_type_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNamed_type_listContext differentiates from other interfaces.
	IsNamed_type_listContext()
}

type Named_type_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_type_listContext() *Named_type_listContext {
	var p = new(Named_type_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_named_type_list
	return p
}

func InitEmptyNamed_type_listContext(p *Named_type_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_named_type_list
}

func (*Named_type_listContext) IsNamed_type_listContext() {}

func NewNamed_type_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_type_listContext {
	var p = new(Named_type_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_named_type_list

	return p
}

func (s *Named_type_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_type_listContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Named_type_listContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Named_type_listContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *Named_type_listContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Named_type_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Named_type_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Named_type_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_type_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_type_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitNamed_type_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Named_type_list() (localctx INamed_type_listContext) {
	localctx = NewNamed_type_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, KuneiformParserRULE_named_type_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(229)
		p.Identifier()
	}
	{
		p.SetState(230)
		p.Type_()
	}
	p.SetState(237)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCOMMA {
		{
			p.SetState(231)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(232)
			p.Identifier()
		}
		{
			p.SetState(233)
			p.Type_()
		}

		p.SetState(239)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInline_constraintContext is an interface to support dynamic dispatch.
type IInline_constraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	NOT() antlr.TerminalNode
	NULL() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	Action_expr() IAction_exprContext
	Fk_constraint() IFk_constraintContext
	CHECK() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Sql_expr() ISql_exprContext
	RPAREN() antlr.TerminalNode

	// IsInline_constraintContext differentiates from other interfaces.
	IsInline_constraintContext()
}

type Inline_constraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInline_constraintContext() *Inline_constraintContext {
	var p = new(Inline_constraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_inline_constraint
	return p
}

func InitEmptyInline_constraintContext(p *Inline_constraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_inline_constraint
}

func (*Inline_constraintContext) IsInline_constraintContext() {}

func NewInline_constraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inline_constraintContext {
	var p = new(Inline_constraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_inline_constraint

	return p
}

func (s *Inline_constraintContext) GetParser() antlr.Parser { return s.parser }

func (s *Inline_constraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPRIMARY, 0)
}

func (s *Inline_constraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(KuneiformParserKEY, 0)
}

func (s *Inline_constraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUNIQUE, 0)
}

func (s *Inline_constraintContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Inline_constraintContext) NULL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNULL, 0)
}

func (s *Inline_constraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDEFAULT, 0)
}

func (s *Inline_constraintContext) Action_expr() IAction_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_exprContext)
}

func (s *Inline_constraintContext) Fk_constraint() IFk_constraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFk_constraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFk_constraintContext)
}

func (s *Inline_constraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCHECK, 0)
}

func (s *Inline_constraintContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Inline_constraintContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Inline_constraintContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Inline_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inline_constraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inline_constraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitInline_constraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Inline_constraint() (localctx IInline_constraintContext) {
	localctx = NewInline_constraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, KuneiformParserRULE_inline_constraint)
	p.SetState(253)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KuneiformParserPRIMARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(240)
			p.Match(KuneiformParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(241)
			p.Match(KuneiformParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KuneiformParserUNIQUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(242)
			p.Match(KuneiformParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KuneiformParserNOT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(243)
			p.Match(KuneiformParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(244)
			p.Match(KuneiformParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KuneiformParserDEFAULT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(245)
			p.Match(KuneiformParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(246)
			p.action_expr(0)
		}

	case KuneiformParserREFERENCES:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(247)
			p.Fk_constraint()
		}

	case KuneiformParserCHECK:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(248)
			p.Match(KuneiformParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(249)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(250)
			p.sql_expr(0)
		}
		{
			p.SetState(251)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFk_actionContext is an interface to support dynamic dispatch.
type IFk_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	SET() antlr.TerminalNode
	NULL() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	RESTRICT() antlr.TerminalNode
	NO() antlr.TerminalNode
	ACTION() antlr.TerminalNode
	CASCADE() antlr.TerminalNode

	// IsFk_actionContext differentiates from other interfaces.
	IsFk_actionContext()
}

type Fk_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFk_actionContext() *Fk_actionContext {
	var p = new(Fk_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_fk_action
	return p
}

func InitEmptyFk_actionContext(p *Fk_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_fk_action
}

func (*Fk_actionContext) IsFk_actionContext() {}

func NewFk_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fk_actionContext {
	var p = new(Fk_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_fk_action

	return p
}

func (s *Fk_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Fk_actionContext) ON() antlr.TerminalNode {
	return s.GetToken(KuneiformParserON, 0)
}

func (s *Fk_actionContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUPDATE, 0)
}

func (s *Fk_actionContext) DELETE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDELETE, 0)
}

func (s *Fk_actionContext) SET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSET, 0)
}

func (s *Fk_actionContext) NULL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNULL, 0)
}

func (s *Fk_actionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDEFAULT, 0)
}

func (s *Fk_actionContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRESTRICT, 0)
}

func (s *Fk_actionContext) NO() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNO, 0)
}

func (s *Fk_actionContext) ACTION() antlr.TerminalNode {
	return s.GetToken(KuneiformParserACTION, 0)
}

func (s *Fk_actionContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCASCADE, 0)
}

func (s *Fk_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fk_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fk_actionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitFk_action(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Fk_action() (localctx IFk_actionContext) {
	localctx = NewFk_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, KuneiformParserRULE_fk_action)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(255)
		p.Match(KuneiformParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(256)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KuneiformParserDELETE || _la == KuneiformParserUPDATE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(265)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(257)
			p.Match(KuneiformParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(258)
			p.Match(KuneiformParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(259)
			p.Match(KuneiformParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(260)
			p.Match(KuneiformParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(261)
			p.Match(KuneiformParserRESTRICT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(262)
			p.Match(KuneiformParserNO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(263)
			p.Match(KuneiformParserACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		{
			p.SetState(264)
			p.Match(KuneiformParserCASCADE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFk_constraintContext is an interface to support dynamic dispatch.
type IFk_constraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNamespace returns the namespace rule contexts.
	GetNamespace() IIdentifierContext

	// GetTable returns the table rule contexts.
	GetTable() IIdentifierContext

	// SetNamespace sets the namespace rule contexts.
	SetNamespace(IIdentifierContext)

	// SetTable sets the table rule contexts.
	SetTable(IIdentifierContext)

	// Getter signatures
	REFERENCES() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Identifier_list() IIdentifier_listContext
	RPAREN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	PERIOD() antlr.TerminalNode
	AllFk_action() []IFk_actionContext
	Fk_action(i int) IFk_actionContext

	// IsFk_constraintContext differentiates from other interfaces.
	IsFk_constraintContext()
}

type Fk_constraintContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	namespace IIdentifierContext
	table     IIdentifierContext
}

func NewEmptyFk_constraintContext() *Fk_constraintContext {
	var p = new(Fk_constraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_fk_constraint
	return p
}

func InitEmptyFk_constraintContext(p *Fk_constraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_fk_constraint
}

func (*Fk_constraintContext) IsFk_constraintContext() {}

func NewFk_constraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fk_constraintContext {
	var p = new(Fk_constraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_fk_constraint

	return p
}

func (s *Fk_constraintContext) GetParser() antlr.Parser { return s.parser }

func (s *Fk_constraintContext) GetNamespace() IIdentifierContext { return s.namespace }

func (s *Fk_constraintContext) GetTable() IIdentifierContext { return s.table }

func (s *Fk_constraintContext) SetNamespace(v IIdentifierContext) { s.namespace = v }

func (s *Fk_constraintContext) SetTable(v IIdentifierContext) { s.table = v }

func (s *Fk_constraintContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(KuneiformParserREFERENCES, 0)
}

func (s *Fk_constraintContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Fk_constraintContext) Identifier_list() IIdentifier_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifier_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Fk_constraintContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Fk_constraintContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Fk_constraintContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Fk_constraintContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPERIOD, 0)
}

func (s *Fk_constraintContext) AllFk_action() []IFk_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFk_actionContext); ok {
			len++
		}
	}

	tst := make([]IFk_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFk_actionContext); ok {
			tst[i] = t.(IFk_actionContext)
			i++
		}
	}

	return tst
}

func (s *Fk_constraintContext) Fk_action(i int) IFk_actionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFk_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFk_actionContext)
}

func (s *Fk_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fk_constraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fk_constraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitFk_constraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Fk_constraint() (localctx IFk_constraintContext) {
	localctx = NewFk_constraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, KuneiformParserRULE_fk_constraint)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(267)
		p.Match(KuneiformParserREFERENCES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(271)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(268)

			var _x = p.Identifier()

			localctx.(*Fk_constraintContext).namespace = _x
		}
		{
			p.SetState(269)
			p.Match(KuneiformParserPERIOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(273)

		var _x = p.Identifier()

		localctx.(*Fk_constraintContext).table = _x
	}
	{
		p.SetState(274)
		p.Match(KuneiformParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(275)
		p.Identifier_list()
	}
	{
		p.SetState(276)
		p.Match(KuneiformParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(281)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserON {
		{
			p.SetState(277)
			p.Fk_action()
		}
		p.SetState(279)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserON {
			{
				p.SetState(278)
				p.Fk_action()
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAction_returnContext is an interface to support dynamic dispatch.
type IAction_returnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetReturn_columns returns the return_columns rule contexts.
	GetReturn_columns() INamed_type_listContext

	// GetUnnamed_return_types returns the unnamed_return_types rule contexts.
	GetUnnamed_return_types() IType_listContext

	// SetReturn_columns sets the return_columns rule contexts.
	SetReturn_columns(INamed_type_listContext)

	// SetUnnamed_return_types sets the unnamed_return_types rule contexts.
	SetUnnamed_return_types(IType_listContext)

	// Getter signatures
	RETURNS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Named_type_list() INamed_type_listContext
	Type_list() IType_listContext
	TABLE() antlr.TerminalNode

	// IsAction_returnContext differentiates from other interfaces.
	IsAction_returnContext()
}

type Action_returnContext struct {
	antlr.BaseParserRuleContext
	parser               antlr.Parser
	return_columns       INamed_type_listContext
	unnamed_return_types IType_listContext
}

func NewEmptyAction_returnContext() *Action_returnContext {
	var p = new(Action_returnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_action_return
	return p
}

func InitEmptyAction_returnContext(p *Action_returnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_action_return
}

func (*Action_returnContext) IsAction_returnContext() {}

func NewAction_returnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Action_returnContext {
	var p = new(Action_returnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_action_return

	return p
}

func (s *Action_returnContext) GetParser() antlr.Parser { return s.parser }

func (s *Action_returnContext) GetReturn_columns() INamed_type_listContext { return s.return_columns }

func (s *Action_returnContext) GetUnnamed_return_types() IType_listContext {
	return s.unnamed_return_types
}

func (s *Action_returnContext) SetReturn_columns(v INamed_type_listContext) { s.return_columns = v }

func (s *Action_returnContext) SetUnnamed_return_types(v IType_listContext) {
	s.unnamed_return_types = v
}

func (s *Action_returnContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRETURNS, 0)
}

func (s *Action_returnContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Action_returnContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Action_returnContext) Named_type_list() INamed_type_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_type_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_type_listContext)
}

func (s *Action_returnContext) Type_list() IType_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_listContext)
}

func (s *Action_returnContext) TABLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserTABLE, 0)
}

func (s *Action_returnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Action_returnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Action_returnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitAction_return(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Action_return() (localctx IAction_returnContext) {
	localctx = NewAction_returnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, KuneiformParserRULE_action_return)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(283)
		p.Match(KuneiformParserRETURNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) {
	case 1:
		p.SetState(285)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserTABLE {
			{
				p.SetState(284)
				p.Match(KuneiformParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(287)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(288)

			var _x = p.Named_type_list()

			localctx.(*Action_returnContext).return_columns = _x
		}
		{
			p.SetState(289)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(291)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(292)

			var _x = p.Type_list()

			localctx.(*Action_returnContext).unnamed_return_types = _x
		}
		{
			p.SetState(293)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISql_statementContext is an interface to support dynamic dispatch.
type ISql_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_statement() ISelect_statementContext
	Update_statement() IUpdate_statementContext
	Insert_statement() IInsert_statementContext
	Delete_statement() IDelete_statementContext
	WITH() antlr.TerminalNode
	AllCommon_table_expression() []ICommon_table_expressionContext
	Common_table_expression(i int) ICommon_table_expressionContext
	RECURSIVE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSql_statementContext differentiates from other interfaces.
	IsSql_statementContext()
}

type Sql_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_statementContext() *Sql_statementContext {
	var p = new(Sql_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_sql_statement
	return p
}

func InitEmptySql_statementContext(p *Sql_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_sql_statement
}

func (*Sql_statementContext) IsSql_statementContext() {}

func NewSql_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_statementContext {
	var p = new(Sql_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_sql_statement

	return p
}

func (s *Sql_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_statementContext) Select_statement() ISelect_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *Sql_statementContext) Update_statement() IUpdate_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_statementContext)
}

func (s *Sql_statementContext) Insert_statement() IInsert_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_statementContext)
}

func (s *Sql_statementContext) Delete_statement() IDelete_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelete_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelete_statementContext)
}

func (s *Sql_statementContext) WITH() antlr.TerminalNode {
	return s.GetToken(KuneiformParserWITH, 0)
}

func (s *Sql_statementContext) AllCommon_table_expression() []ICommon_table_expressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommon_table_expressionContext); ok {
			len++
		}
	}

	tst := make([]ICommon_table_expressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommon_table_expressionContext); ok {
			tst[i] = t.(ICommon_table_expressionContext)
			i++
		}
	}

	return tst
}

func (s *Sql_statementContext) Common_table_expression(i int) ICommon_table_expressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommon_table_expressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommon_table_expressionContext)
}

func (s *Sql_statementContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRECURSIVE, 0)
}

func (s *Sql_statementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Sql_statementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Sql_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sql_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitSql_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Sql_statement() (localctx ISql_statementContext) {
	localctx = NewSql_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, KuneiformParserRULE_sql_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(309)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserWITH {
		{
			p.SetState(297)
			p.Match(KuneiformParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(299)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserRECURSIVE {
			{
				p.SetState(298)
				p.Match(KuneiformParserRECURSIVE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(301)
			p.Common_table_expression()
		}
		p.SetState(306)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KuneiformParserCOMMA {
			{
				p.SetState(302)
				p.Match(KuneiformParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(303)
				p.Common_table_expression()
			}

			p.SetState(308)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(315)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KuneiformParserSELECT:
		{
			p.SetState(311)
			p.Select_statement()
		}

	case KuneiformParserUPDATE:
		{
			p.SetState(312)
			p.Update_statement()
		}

	case KuneiformParserINSERT:
		{
			p.SetState(313)
			p.Insert_statement()
		}

	case KuneiformParserDELETE:
		{
			p.SetState(314)
			p.Delete_statement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommon_table_expressionContext is an interface to support dynamic dispatch.
type ICommon_table_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AS() antlr.TerminalNode
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	Select_statement() ISelect_statementContext
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCommon_table_expressionContext differentiates from other interfaces.
	IsCommon_table_expressionContext()
}

type Common_table_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommon_table_expressionContext() *Common_table_expressionContext {
	var p = new(Common_table_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_common_table_expression
	return p
}

func InitEmptyCommon_table_expressionContext(p *Common_table_expressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_common_table_expression
}

func (*Common_table_expressionContext) IsCommon_table_expressionContext() {}

func NewCommon_table_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Common_table_expressionContext {
	var p = new(Common_table_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_common_table_expression

	return p
}

func (s *Common_table_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Common_table_expressionContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Common_table_expressionContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Common_table_expressionContext) AS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAS, 0)
}

func (s *Common_table_expressionContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserLPAREN)
}

func (s *Common_table_expressionContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, i)
}

func (s *Common_table_expressionContext) Select_statement() ISelect_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *Common_table_expressionContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserRPAREN)
}

func (s *Common_table_expressionContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, i)
}

func (s *Common_table_expressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Common_table_expressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Common_table_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Common_table_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Common_table_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitCommon_table_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Common_table_expression() (localctx ICommon_table_expressionContext) {
	localctx = NewCommon_table_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, KuneiformParserRULE_common_table_expression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(317)
		p.Identifier()
	}
	p.SetState(330)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserLPAREN {
		{
			p.SetState(318)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(327)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9127724498152325120) != 0) || ((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&288362046938939393) != 0) {
			{
				p.SetState(319)
				p.Identifier()
			}
			p.SetState(324)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KuneiformParserCOMMA {
				{
					p.SetState(320)
					p.Match(KuneiformParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(321)
					p.Identifier()
				}

				p.SetState(326)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(329)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(332)
		p.Match(KuneiformParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(333)
		p.Match(KuneiformParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(334)
		p.Select_statement()
	}
	{
		p.SetState(335)
		p.Match(KuneiformParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_statementContext is an interface to support dynamic dispatch.
type ICreate_table_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllTable_column_def() []ITable_column_defContext
	Table_column_def(i int) ITable_column_defContext
	AllTable_constraint_def() []ITable_constraint_defContext
	Table_constraint_def(i int) ITable_constraint_defContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreate_table_statementContext differentiates from other interfaces.
	IsCreate_table_statementContext()
}

type Create_table_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyCreate_table_statementContext() *Create_table_statementContext {
	var p = new(Create_table_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_create_table_statement
	return p
}

func InitEmptyCreate_table_statementContext(p *Create_table_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_create_table_statement
}

func (*Create_table_statementContext) IsCreate_table_statementContext() {}

func NewCreate_table_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_statementContext {
	var p = new(Create_table_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_create_table_statement

	return p
}

func (s *Create_table_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_statementContext) GetName() IIdentifierContext { return s.name }

func (s *Create_table_statementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *Create_table_statementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCREATE, 0)
}

func (s *Create_table_statementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserTABLE, 0)
}

func (s *Create_table_statementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Create_table_statementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Create_table_statementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Create_table_statementContext) AllTable_column_def() []ITable_column_defContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITable_column_defContext); ok {
			len++
		}
	}

	tst := make([]ITable_column_defContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITable_column_defContext); ok {
			tst[i] = t.(ITable_column_defContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_statementContext) Table_column_def(i int) ITable_column_defContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_column_defContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_column_defContext)
}

func (s *Create_table_statementContext) AllTable_constraint_def() []ITable_constraint_defContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITable_constraint_defContext); ok {
			len++
		}
	}

	tst := make([]ITable_constraint_defContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITable_constraint_defContext); ok {
			tst[i] = t.(ITable_constraint_defContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_statementContext) Table_constraint_def(i int) ITable_constraint_defContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_constraint_defContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_constraint_defContext)
}

func (s *Create_table_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIF, 0)
}

func (s *Create_table_statementContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Create_table_statementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEXISTS, 0)
}

func (s *Create_table_statementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Create_table_statementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Create_table_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitCreate_table_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Create_table_statement() (localctx ICreate_table_statementContext) {
	localctx = NewCreate_table_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, KuneiformParserRULE_create_table_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(337)
		p.Match(KuneiformParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(338)
		p.Match(KuneiformParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(342)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(339)
			p.Match(KuneiformParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(340)
			p.Match(KuneiformParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(341)
			p.Match(KuneiformParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(344)

		var _x = p.Identifier()

		localctx.(*Create_table_statementContext).name = _x
	}
	{
		p.SetState(345)
		p.Match(KuneiformParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(348)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(346)
			p.Table_column_def()
		}

	case 2:
		{
			p.SetState(347)
			p.Table_constraint_def()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(357)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCOMMA {
		{
			p.SetState(350)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(353)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(351)
				p.Table_column_def()
			}

		case 2:
			{
				p.SetState(352)
				p.Table_constraint_def()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(359)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(360)
		p.Match(KuneiformParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_constraint_defContext is an interface to support dynamic dispatch.
type ITable_constraint_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	UNIQUE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Identifier_list() IIdentifier_listContext
	RPAREN() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	Sql_expr() ISql_exprContext
	FOREIGN() antlr.TerminalNode
	KEY() antlr.TerminalNode
	Fk_constraint() IFk_constraintContext
	PRIMARY() antlr.TerminalNode
	CONSTRAINT() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsTable_constraint_defContext differentiates from other interfaces.
	IsTable_constraint_defContext()
}

type Table_constraint_defContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyTable_constraint_defContext() *Table_constraint_defContext {
	var p = new(Table_constraint_defContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_table_constraint_def
	return p
}

func InitEmptyTable_constraint_defContext(p *Table_constraint_defContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_table_constraint_def
}

func (*Table_constraint_defContext) IsTable_constraint_defContext() {}

func NewTable_constraint_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_constraint_defContext {
	var p = new(Table_constraint_defContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_table_constraint_def

	return p
}

func (s *Table_constraint_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_constraint_defContext) GetName() IIdentifierContext { return s.name }

func (s *Table_constraint_defContext) SetName(v IIdentifierContext) { s.name = v }

func (s *Table_constraint_defContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUNIQUE, 0)
}

func (s *Table_constraint_defContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Table_constraint_defContext) Identifier_list() IIdentifier_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifier_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Table_constraint_defContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Table_constraint_defContext) CHECK() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCHECK, 0)
}

func (s *Table_constraint_defContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Table_constraint_defContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFOREIGN, 0)
}

func (s *Table_constraint_defContext) KEY() antlr.TerminalNode {
	return s.GetToken(KuneiformParserKEY, 0)
}

func (s *Table_constraint_defContext) Fk_constraint() IFk_constraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFk_constraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFk_constraintContext)
}

func (s *Table_constraint_defContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPRIMARY, 0)
}

func (s *Table_constraint_defContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCONSTRAINT, 0)
}

func (s *Table_constraint_defContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Table_constraint_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_constraint_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_constraint_defContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitTable_constraint_def(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Table_constraint_def() (localctx ITable_constraint_defContext) {
	localctx = NewTable_constraint_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, KuneiformParserRULE_table_constraint_def)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserCONSTRAINT {
		{
			p.SetState(362)
			p.Match(KuneiformParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(363)

			var _x = p.Identifier()

			localctx.(*Table_constraint_defContext).name = _x
		}

	}
	p.SetState(389)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KuneiformParserUNIQUE:
		{
			p.SetState(366)
			p.Match(KuneiformParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(367)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(368)
			p.Identifier_list()
		}
		{
			p.SetState(369)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KuneiformParserCHECK:
		{
			p.SetState(371)
			p.Match(KuneiformParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(372)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(373)
			p.sql_expr(0)
		}
		{
			p.SetState(374)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KuneiformParserFOREIGN:
		{
			p.SetState(376)
			p.Match(KuneiformParserFOREIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(377)
			p.Match(KuneiformParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(378)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(379)
			p.Identifier_list()
		}
		{
			p.SetState(380)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(381)
			p.Fk_constraint()
		}

	case KuneiformParserPRIMARY:
		{
			p.SetState(383)
			p.Match(KuneiformParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(384)
			p.Match(KuneiformParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(385)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(386)
			p.Identifier_list()
		}
		{
			p.SetState(387)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_drop_behaviorContext is an interface to support dynamic dispatch.
type IOpt_drop_behaviorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASCADE() antlr.TerminalNode
	RESTRICT() antlr.TerminalNode

	// IsOpt_drop_behaviorContext differentiates from other interfaces.
	IsOpt_drop_behaviorContext()
}

type Opt_drop_behaviorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_drop_behaviorContext() *Opt_drop_behaviorContext {
	var p = new(Opt_drop_behaviorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_opt_drop_behavior
	return p
}

func InitEmptyOpt_drop_behaviorContext(p *Opt_drop_behaviorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_opt_drop_behavior
}

func (*Opt_drop_behaviorContext) IsOpt_drop_behaviorContext() {}

func NewOpt_drop_behaviorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_drop_behaviorContext {
	var p = new(Opt_drop_behaviorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_opt_drop_behavior

	return p
}

func (s *Opt_drop_behaviorContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_drop_behaviorContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCASCADE, 0)
}

func (s *Opt_drop_behaviorContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRESTRICT, 0)
}

func (s *Opt_drop_behaviorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_drop_behaviorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_drop_behaviorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitOpt_drop_behavior(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Opt_drop_behavior() (localctx IOpt_drop_behaviorContext) {
	localctx = NewOpt_drop_behaviorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, KuneiformParserRULE_opt_drop_behavior)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(391)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KuneiformParserCASCADE || _la == KuneiformParserRESTRICT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_table_statementContext is an interface to support dynamic dispatch.
type IDrop_table_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTables returns the tables rule contexts.
	GetTables() IIdentifier_listContext

	// SetTables sets the tables rule contexts.
	SetTables(IIdentifier_listContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Identifier_list() IIdentifier_listContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Opt_drop_behavior() IOpt_drop_behaviorContext

	// IsDrop_table_statementContext differentiates from other interfaces.
	IsDrop_table_statementContext()
}

type Drop_table_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	tables IIdentifier_listContext
}

func NewEmptyDrop_table_statementContext() *Drop_table_statementContext {
	var p = new(Drop_table_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_drop_table_statement
	return p
}

func InitEmptyDrop_table_statementContext(p *Drop_table_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_drop_table_statement
}

func (*Drop_table_statementContext) IsDrop_table_statementContext() {}

func NewDrop_table_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_table_statementContext {
	var p = new(Drop_table_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_drop_table_statement

	return p
}

func (s *Drop_table_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_table_statementContext) GetTables() IIdentifier_listContext { return s.tables }

func (s *Drop_table_statementContext) SetTables(v IIdentifier_listContext) { s.tables = v }

func (s *Drop_table_statementContext) DROP() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDROP, 0)
}

func (s *Drop_table_statementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserTABLE, 0)
}

func (s *Drop_table_statementContext) Identifier_list() IIdentifier_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifier_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Drop_table_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIF, 0)
}

func (s *Drop_table_statementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEXISTS, 0)
}

func (s *Drop_table_statementContext) Opt_drop_behavior() IOpt_drop_behaviorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_drop_behaviorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_drop_behaviorContext)
}

func (s *Drop_table_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_table_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_table_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitDrop_table_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Drop_table_statement() (localctx IDrop_table_statementContext) {
	localctx = NewDrop_table_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, KuneiformParserRULE_drop_table_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(393)
		p.Match(KuneiformParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(394)
		p.Match(KuneiformParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(397)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(395)
			p.Match(KuneiformParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(396)
			p.Match(KuneiformParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(399)

		var _x = p.Identifier_list()

		localctx.(*Drop_table_statementContext).tables = _x
	}
	p.SetState(401)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserCASCADE || _la == KuneiformParserRESTRICT {
		{
			p.SetState(400)
			p.Opt_drop_behavior()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_statementContext is an interface to support dynamic dispatch.
type IAlter_table_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IIdentifierContext

	// SetTable sets the table rule contexts.
	SetTable(IIdentifierContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Alter_table_action() IAlter_table_actionContext
	Identifier() IIdentifierContext

	// IsAlter_table_statementContext differentiates from other interfaces.
	IsAlter_table_statementContext()
}

type Alter_table_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	table  IIdentifierContext
}

func NewEmptyAlter_table_statementContext() *Alter_table_statementContext {
	var p = new(Alter_table_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_alter_table_statement
	return p
}

func InitEmptyAlter_table_statementContext(p *Alter_table_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_alter_table_statement
}

func (*Alter_table_statementContext) IsAlter_table_statementContext() {}

func NewAlter_table_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_statementContext {
	var p = new(Alter_table_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_alter_table_statement

	return p
}

func (s *Alter_table_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_statementContext) GetTable() IIdentifierContext { return s.table }

func (s *Alter_table_statementContext) SetTable(v IIdentifierContext) { s.table = v }

func (s *Alter_table_statementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserALTER, 0)
}

func (s *Alter_table_statementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserTABLE, 0)
}

func (s *Alter_table_statementContext) Alter_table_action() IAlter_table_actionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_actionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_actionContext)
}

func (s *Alter_table_statementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Alter_table_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitAlter_table_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Alter_table_statement() (localctx IAlter_table_statementContext) {
	localctx = NewAlter_table_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, KuneiformParserRULE_alter_table_statement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(403)
		p.Match(KuneiformParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(404)
		p.Match(KuneiformParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(405)

		var _x = p.Identifier()

		localctx.(*Alter_table_statementContext).table = _x
	}
	{
		p.SetState(406)
		p.Alter_table_action()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_actionContext is an interface to support dynamic dispatch.
type IAlter_table_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlter_table_actionContext differentiates from other interfaces.
	IsAlter_table_actionContext()
}

type Alter_table_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_actionContext() *Alter_table_actionContext {
	var p = new(Alter_table_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_alter_table_action
	return p
}

func InitEmptyAlter_table_actionContext(p *Alter_table_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_alter_table_action
}

func (*Alter_table_actionContext) IsAlter_table_actionContext() {}

func NewAlter_table_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_actionContext {
	var p = new(Alter_table_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_alter_table_action

	return p
}

func (s *Alter_table_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_actionContext) CopyAll(ctx *Alter_table_actionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *Alter_table_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Drop_column_constraintContext struct {
	Alter_table_actionContext
	column IIdentifierContext
}

func NewDrop_column_constraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Drop_column_constraintContext {
	var p = new(Drop_column_constraintContext)

	InitEmptyAlter_table_actionContext(&p.Alter_table_actionContext)
	p.parser = parser
	p.CopyAll(ctx.(*Alter_table_actionContext))

	return p
}

func (s *Drop_column_constraintContext) GetColumn() IIdentifierContext { return s.column }

func (s *Drop_column_constraintContext) SetColumn(v IIdentifierContext) { s.column = v }

func (s *Drop_column_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_column_constraintContext) ALTER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserALTER, 0)
}

func (s *Drop_column_constraintContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOLUMN, 0)
}

func (s *Drop_column_constraintContext) DROP() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDROP, 0)
}

func (s *Drop_column_constraintContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Drop_column_constraintContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Drop_column_constraintContext) NULL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNULL, 0)
}

func (s *Drop_column_constraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDEFAULT, 0)
}

func (s *Drop_column_constraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitDrop_column_constraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type Add_columnContext struct {
	Alter_table_actionContext
	column IIdentifierContext
}

func NewAdd_columnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Add_columnContext {
	var p = new(Add_columnContext)

	InitEmptyAlter_table_actionContext(&p.Alter_table_actionContext)
	p.parser = parser
	p.CopyAll(ctx.(*Alter_table_actionContext))

	return p
}

func (s *Add_columnContext) GetColumn() IIdentifierContext { return s.column }

func (s *Add_columnContext) SetColumn(v IIdentifierContext) { s.column = v }

func (s *Add_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Add_columnContext) ADD() antlr.TerminalNode {
	return s.GetToken(KuneiformParserADD, 0)
}

func (s *Add_columnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOLUMN, 0)
}

func (s *Add_columnContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Add_columnContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Add_columnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitAdd_column(s)

	default:
		return t.VisitChildren(s)
	}
}

type Rename_columnContext struct {
	Alter_table_actionContext
	old_column IIdentifierContext
	new_column IIdentifierContext
}

func NewRename_columnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rename_columnContext {
	var p = new(Rename_columnContext)

	InitEmptyAlter_table_actionContext(&p.Alter_table_actionContext)
	p.parser = parser
	p.CopyAll(ctx.(*Alter_table_actionContext))

	return p
}

func (s *Rename_columnContext) GetOld_column() IIdentifierContext { return s.old_column }

func (s *Rename_columnContext) GetNew_column() IIdentifierContext { return s.new_column }

func (s *Rename_columnContext) SetOld_column(v IIdentifierContext) { s.old_column = v }

func (s *Rename_columnContext) SetNew_column(v IIdentifierContext) { s.new_column = v }

func (s *Rename_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rename_columnContext) RENAME() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRENAME, 0)
}

func (s *Rename_columnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOLUMN, 0)
}

func (s *Rename_columnContext) TO() antlr.TerminalNode {
	return s.GetToken(KuneiformParserTO, 0)
}

func (s *Rename_columnContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Rename_columnContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Rename_columnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitRename_column(s)

	default:
		return t.VisitChildren(s)
	}
}

type Add_table_constraintContext struct {
	Alter_table_actionContext
}

func NewAdd_table_constraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Add_table_constraintContext {
	var p = new(Add_table_constraintContext)

	InitEmptyAlter_table_actionContext(&p.Alter_table_actionContext)
	p.parser = parser
	p.CopyAll(ctx.(*Alter_table_actionContext))

	return p
}

func (s *Add_table_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Add_table_constraintContext) ADD() antlr.TerminalNode {
	return s.GetToken(KuneiformParserADD, 0)
}

func (s *Add_table_constraintContext) Table_constraint_def() ITable_constraint_defContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_constraint_defContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_constraint_defContext)
}

func (s *Add_table_constraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitAdd_table_constraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type Add_column_constraintContext struct {
	Alter_table_actionContext
	column IIdentifierContext
}

func NewAdd_column_constraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Add_column_constraintContext {
	var p = new(Add_column_constraintContext)

	InitEmptyAlter_table_actionContext(&p.Alter_table_actionContext)
	p.parser = parser
	p.CopyAll(ctx.(*Alter_table_actionContext))

	return p
}

func (s *Add_column_constraintContext) GetColumn() IIdentifierContext { return s.column }

func (s *Add_column_constraintContext) SetColumn(v IIdentifierContext) { s.column = v }

func (s *Add_column_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Add_column_constraintContext) ALTER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserALTER, 0)
}

func (s *Add_column_constraintContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOLUMN, 0)
}

func (s *Add_column_constraintContext) SET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSET, 0)
}

func (s *Add_column_constraintContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Add_column_constraintContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Add_column_constraintContext) NULL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNULL, 0)
}

func (s *Add_column_constraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDEFAULT, 0)
}

func (s *Add_column_constraintContext) Action_expr() IAction_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_exprContext)
}

func (s *Add_column_constraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitAdd_column_constraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type Rename_tableContext struct {
	Alter_table_actionContext
	new_table IIdentifierContext
}

func NewRename_tableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rename_tableContext {
	var p = new(Rename_tableContext)

	InitEmptyAlter_table_actionContext(&p.Alter_table_actionContext)
	p.parser = parser
	p.CopyAll(ctx.(*Alter_table_actionContext))

	return p
}

func (s *Rename_tableContext) GetNew_table() IIdentifierContext { return s.new_table }

func (s *Rename_tableContext) SetNew_table(v IIdentifierContext) { s.new_table = v }

func (s *Rename_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rename_tableContext) RENAME() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRENAME, 0)
}

func (s *Rename_tableContext) TO() antlr.TerminalNode {
	return s.GetToken(KuneiformParserTO, 0)
}

func (s *Rename_tableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Rename_tableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitRename_table(s)

	default:
		return t.VisitChildren(s)
	}
}

type Drop_table_constraintContext struct {
	Alter_table_actionContext
}

func NewDrop_table_constraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Drop_table_constraintContext {
	var p = new(Drop_table_constraintContext)

	InitEmptyAlter_table_actionContext(&p.Alter_table_actionContext)
	p.parser = parser
	p.CopyAll(ctx.(*Alter_table_actionContext))

	return p
}

func (s *Drop_table_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_table_constraintContext) DROP() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDROP, 0)
}

func (s *Drop_table_constraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCONSTRAINT, 0)
}

func (s *Drop_table_constraintContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Drop_table_constraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitDrop_table_constraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type Drop_columnContext struct {
	Alter_table_actionContext
	column IIdentifierContext
}

func NewDrop_columnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Drop_columnContext {
	var p = new(Drop_columnContext)

	InitEmptyAlter_table_actionContext(&p.Alter_table_actionContext)
	p.parser = parser
	p.CopyAll(ctx.(*Alter_table_actionContext))

	return p
}

func (s *Drop_columnContext) GetColumn() IIdentifierContext { return s.column }

func (s *Drop_columnContext) SetColumn(v IIdentifierContext) { s.column = v }

func (s *Drop_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_columnContext) DROP() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDROP, 0)
}

func (s *Drop_columnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOLUMN, 0)
}

func (s *Drop_columnContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Drop_columnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitDrop_column(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Alter_table_action() (localctx IAlter_table_actionContext) {
	localctx = NewAlter_table_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, KuneiformParserRULE_alter_table_action)
	p.SetState(449)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAdd_column_constraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(408)
			p.Match(KuneiformParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(409)
			p.Match(KuneiformParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(410)

			var _x = p.Identifier()

			localctx.(*Add_column_constraintContext).column = _x
		}
		{
			p.SetState(411)
			p.Match(KuneiformParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(416)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case KuneiformParserNOT:
			{
				p.SetState(412)
				p.Match(KuneiformParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(413)
				p.Match(KuneiformParserNULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case KuneiformParserDEFAULT:
			{
				p.SetState(414)
				p.Match(KuneiformParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(415)
				p.action_expr(0)
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		localctx = NewDrop_column_constraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(418)
			p.Match(KuneiformParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(419)
			p.Match(KuneiformParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(420)

			var _x = p.Identifier()

			localctx.(*Drop_column_constraintContext).column = _x
		}
		{
			p.SetState(421)
			p.Match(KuneiformParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(425)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case KuneiformParserNOT:
			{
				p.SetState(422)
				p.Match(KuneiformParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(423)
				p.Match(KuneiformParserNULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case KuneiformParserDEFAULT:
			{
				p.SetState(424)
				p.Match(KuneiformParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		localctx = NewAdd_columnContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(427)
			p.Match(KuneiformParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(428)
			p.Match(KuneiformParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(429)

			var _x = p.Identifier()

			localctx.(*Add_columnContext).column = _x
		}
		{
			p.SetState(430)
			p.Type_()
		}

	case 4:
		localctx = NewDrop_columnContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(432)
			p.Match(KuneiformParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(433)
			p.Match(KuneiformParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(434)

			var _x = p.Identifier()

			localctx.(*Drop_columnContext).column = _x
		}

	case 5:
		localctx = NewRename_columnContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(435)
			p.Match(KuneiformParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(436)
			p.Match(KuneiformParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(437)

			var _x = p.Identifier()

			localctx.(*Rename_columnContext).old_column = _x
		}
		{
			p.SetState(438)
			p.Match(KuneiformParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(439)

			var _x = p.Identifier()

			localctx.(*Rename_columnContext).new_column = _x
		}

	case 6:
		localctx = NewRename_tableContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(441)
			p.Match(KuneiformParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(442)
			p.Match(KuneiformParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(443)

			var _x = p.Identifier()

			localctx.(*Rename_tableContext).new_table = _x
		}

	case 7:
		localctx = NewAdd_table_constraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(444)
			p.Match(KuneiformParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(445)
			p.Table_constraint_def()
		}

	case 8:
		localctx = NewDrop_table_constraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(446)
			p.Match(KuneiformParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(447)
			p.Match(KuneiformParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(448)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_index_statementContext is an interface to support dynamic dispatch.
type ICreate_index_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// GetTable returns the table rule contexts.
	GetTable() IIdentifierContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IIdentifier_listContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// SetTable sets the table rule contexts.
	SetTable(IIdentifierContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IIdentifier_listContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	ON() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	Identifier_list() IIdentifier_listContext
	UNIQUE() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsCreate_index_statementContext differentiates from other interfaces.
	IsCreate_index_statementContext()
}

type Create_index_statementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	name    IIdentifierContext
	table   IIdentifierContext
	columns IIdentifier_listContext
}

func NewEmptyCreate_index_statementContext() *Create_index_statementContext {
	var p = new(Create_index_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_create_index_statement
	return p
}

func InitEmptyCreate_index_statementContext(p *Create_index_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_create_index_statement
}

func (*Create_index_statementContext) IsCreate_index_statementContext() {}

func NewCreate_index_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_index_statementContext {
	var p = new(Create_index_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_create_index_statement

	return p
}

func (s *Create_index_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_index_statementContext) GetName() IIdentifierContext { return s.name }

func (s *Create_index_statementContext) GetTable() IIdentifierContext { return s.table }

func (s *Create_index_statementContext) GetColumns() IIdentifier_listContext { return s.columns }

func (s *Create_index_statementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *Create_index_statementContext) SetTable(v IIdentifierContext) { s.table = v }

func (s *Create_index_statementContext) SetColumns(v IIdentifier_listContext) { s.columns = v }

func (s *Create_index_statementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCREATE, 0)
}

func (s *Create_index_statementContext) INDEX() antlr.TerminalNode {
	return s.GetToken(KuneiformParserINDEX, 0)
}

func (s *Create_index_statementContext) ON() antlr.TerminalNode {
	return s.GetToken(KuneiformParserON, 0)
}

func (s *Create_index_statementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Create_index_statementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Create_index_statementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Create_index_statementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Create_index_statementContext) Identifier_list() IIdentifier_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifier_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Create_index_statementContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUNIQUE, 0)
}

func (s *Create_index_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIF, 0)
}

func (s *Create_index_statementContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Create_index_statementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEXISTS, 0)
}

func (s *Create_index_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_index_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_index_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitCreate_index_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Create_index_statement() (localctx ICreate_index_statementContext) {
	localctx = NewCreate_index_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, KuneiformParserRULE_create_index_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(451)
		p.Match(KuneiformParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserUNIQUE {
		{
			p.SetState(452)
			p.Match(KuneiformParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(455)
		p.Match(KuneiformParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(459)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(456)
			p.Match(KuneiformParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(457)
			p.Match(KuneiformParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(458)
			p.Match(KuneiformParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(462)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9127724498152325120) != 0) || ((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&288362046938939393) != 0) {
		{
			p.SetState(461)

			var _x = p.Identifier()

			localctx.(*Create_index_statementContext).name = _x
		}

	}
	{
		p.SetState(464)
		p.Match(KuneiformParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(465)

		var _x = p.Identifier()

		localctx.(*Create_index_statementContext).table = _x
	}
	{
		p.SetState(466)
		p.Match(KuneiformParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(467)

		var _x = p.Identifier_list()

		localctx.(*Create_index_statementContext).columns = _x
	}
	{
		p.SetState(468)
		p.Match(KuneiformParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_index_statementContext is an interface to support dynamic dispatch.
type IDrop_index_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDrop_index_statementContext differentiates from other interfaces.
	IsDrop_index_statementContext()
}

type Drop_index_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyDrop_index_statementContext() *Drop_index_statementContext {
	var p = new(Drop_index_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_drop_index_statement
	return p
}

func InitEmptyDrop_index_statementContext(p *Drop_index_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_drop_index_statement
}

func (*Drop_index_statementContext) IsDrop_index_statementContext() {}

func NewDrop_index_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_index_statementContext {
	var p = new(Drop_index_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_drop_index_statement

	return p
}

func (s *Drop_index_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_index_statementContext) GetName() IIdentifierContext { return s.name }

func (s *Drop_index_statementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *Drop_index_statementContext) DROP() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDROP, 0)
}

func (s *Drop_index_statementContext) INDEX() antlr.TerminalNode {
	return s.GetToken(KuneiformParserINDEX, 0)
}

func (s *Drop_index_statementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Drop_index_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIF, 0)
}

func (s *Drop_index_statementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEXISTS, 0)
}

func (s *Drop_index_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_index_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_index_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitDrop_index_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Drop_index_statement() (localctx IDrop_index_statementContext) {
	localctx = NewDrop_index_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, KuneiformParserRULE_drop_index_statement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(470)
		p.Match(KuneiformParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(471)
		p.Match(KuneiformParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(474)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(472)
			p.Match(KuneiformParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(473)
			p.Match(KuneiformParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(476)

		var _x = p.Identifier()

		localctx.(*Drop_index_statementContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_role_statementContext is an interface to support dynamic dispatch.
type ICreate_role_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsCreate_role_statementContext differentiates from other interfaces.
	IsCreate_role_statementContext()
}

type Create_role_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_role_statementContext() *Create_role_statementContext {
	var p = new(Create_role_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_create_role_statement
	return p
}

func InitEmptyCreate_role_statementContext(p *Create_role_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_create_role_statement
}

func (*Create_role_statementContext) IsCreate_role_statementContext() {}

func NewCreate_role_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_role_statementContext {
	var p = new(Create_role_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_create_role_statement

	return p
}

func (s *Create_role_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_role_statementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCREATE, 0)
}

func (s *Create_role_statementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserROLE, 0)
}

func (s *Create_role_statementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Create_role_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIF, 0)
}

func (s *Create_role_statementContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Create_role_statementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEXISTS, 0)
}

func (s *Create_role_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_role_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_role_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitCreate_role_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Create_role_statement() (localctx ICreate_role_statementContext) {
	localctx = NewCreate_role_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, KuneiformParserRULE_create_role_statement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(478)
		p.Match(KuneiformParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(479)
		p.Match(KuneiformParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(483)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(480)
			p.Match(KuneiformParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(481)
			p.Match(KuneiformParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(482)
			p.Match(KuneiformParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(485)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_role_statementContext is an interface to support dynamic dispatch.
type IDrop_role_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDrop_role_statementContext differentiates from other interfaces.
	IsDrop_role_statementContext()
}

type Drop_role_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_role_statementContext() *Drop_role_statementContext {
	var p = new(Drop_role_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_drop_role_statement
	return p
}

func InitEmptyDrop_role_statementContext(p *Drop_role_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_drop_role_statement
}

func (*Drop_role_statementContext) IsDrop_role_statementContext() {}

func NewDrop_role_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_role_statementContext {
	var p = new(Drop_role_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_drop_role_statement

	return p
}

func (s *Drop_role_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_role_statementContext) DROP() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDROP, 0)
}

func (s *Drop_role_statementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserROLE, 0)
}

func (s *Drop_role_statementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Drop_role_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIF, 0)
}

func (s *Drop_role_statementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEXISTS, 0)
}

func (s *Drop_role_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_role_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_role_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitDrop_role_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Drop_role_statement() (localctx IDrop_role_statementContext) {
	localctx = NewDrop_role_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, KuneiformParserRULE_drop_role_statement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(487)
		p.Match(KuneiformParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(488)
		p.Match(KuneiformParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(491)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(489)
			p.Match(KuneiformParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(490)
			p.Match(KuneiformParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(493)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrant_statementContext is an interface to support dynamic dispatch.
type IGrant_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUser returns the user token.
	GetUser() antlr.Token

	// SetUser sets the user token.
	SetUser(antlr.Token)

	// GetGrant_role returns the grant_role rule contexts.
	GetGrant_role() IIdentifierContext

	// GetNamespace returns the namespace rule contexts.
	GetNamespace() IIdentifierContext

	// GetRole returns the role rule contexts.
	GetRole() IIdentifierContext

	// GetUser_var returns the user_var rule contexts.
	GetUser_var() IAction_exprContext

	// SetGrant_role sets the grant_role rule contexts.
	SetGrant_role(IIdentifierContext)

	// SetNamespace sets the namespace rule contexts.
	SetNamespace(IIdentifierContext)

	// SetRole sets the role rule contexts.
	SetRole(IIdentifierContext)

	// SetUser_var sets the user_var rule contexts.
	SetUser_var(IAction_exprContext)

	// Getter signatures
	GRANT() antlr.TerminalNode
	TO() antlr.TerminalNode
	Privilege_list() IPrivilege_listContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	GRANTED() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	ON() antlr.TerminalNode
	STRING_() antlr.TerminalNode
	Action_expr() IAction_exprContext

	// IsGrant_statementContext differentiates from other interfaces.
	IsGrant_statementContext()
}

type Grant_statementContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	grant_role IIdentifierContext
	namespace  IIdentifierContext
	role       IIdentifierContext
	user       antlr.Token
	user_var   IAction_exprContext
}

func NewEmptyGrant_statementContext() *Grant_statementContext {
	var p = new(Grant_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_grant_statement
	return p
}

func InitEmptyGrant_statementContext(p *Grant_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_grant_statement
}

func (*Grant_statementContext) IsGrant_statementContext() {}

func NewGrant_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grant_statementContext {
	var p = new(Grant_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_grant_statement

	return p
}

func (s *Grant_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Grant_statementContext) GetUser() antlr.Token { return s.user }

func (s *Grant_statementContext) SetUser(v antlr.Token) { s.user = v }

func (s *Grant_statementContext) GetGrant_role() IIdentifierContext { return s.grant_role }

func (s *Grant_statementContext) GetNamespace() IIdentifierContext { return s.namespace }

func (s *Grant_statementContext) GetRole() IIdentifierContext { return s.role }

func (s *Grant_statementContext) GetUser_var() IAction_exprContext { return s.user_var }

func (s *Grant_statementContext) SetGrant_role(v IIdentifierContext) { s.grant_role = v }

func (s *Grant_statementContext) SetNamespace(v IIdentifierContext) { s.namespace = v }

func (s *Grant_statementContext) SetRole(v IIdentifierContext) { s.role = v }

func (s *Grant_statementContext) SetUser_var(v IAction_exprContext) { s.user_var = v }

func (s *Grant_statementContext) GRANT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserGRANT, 0)
}

func (s *Grant_statementContext) TO() antlr.TerminalNode {
	return s.GetToken(KuneiformParserTO, 0)
}

func (s *Grant_statementContext) Privilege_list() IPrivilege_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilege_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilege_listContext)
}

func (s *Grant_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIF, 0)
}

func (s *Grant_statementContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Grant_statementContext) GRANTED() antlr.TerminalNode {
	return s.GetToken(KuneiformParserGRANTED, 0)
}

func (s *Grant_statementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Grant_statementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Grant_statementContext) ON() antlr.TerminalNode {
	return s.GetToken(KuneiformParserON, 0)
}

func (s *Grant_statementContext) STRING_() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSTRING_, 0)
}

func (s *Grant_statementContext) Action_expr() IAction_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_exprContext)
}

func (s *Grant_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grant_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Grant_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitGrant_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Grant_statement() (localctx IGrant_statementContext) {
	localctx = NewGrant_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, KuneiformParserRULE_grant_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(495)
		p.Match(KuneiformParserGRANT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(499)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(496)
			p.Match(KuneiformParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(497)
			p.Match(KuneiformParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(498)
			p.Match(KuneiformParserGRANTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(501)
			p.Privilege_list()
		}

	case 2:
		{
			p.SetState(502)

			var _x = p.Identifier()

			localctx.(*Grant_statementContext).grant_role = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserON {
		{
			p.SetState(505)
			p.Match(KuneiformParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(506)

			var _x = p.Identifier()

			localctx.(*Grant_statementContext).namespace = _x
		}

	}
	{
		p.SetState(509)
		p.Match(KuneiformParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(513)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(510)

			var _x = p.Identifier()

			localctx.(*Grant_statementContext).role = _x
		}

	case 2:
		{
			p.SetState(511)

			var _m = p.Match(KuneiformParserSTRING_)

			localctx.(*Grant_statementContext).user = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(512)

			var _x = p.action_expr(0)

			localctx.(*Grant_statementContext).user_var = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevoke_statementContext is an interface to support dynamic dispatch.
type IRevoke_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUser returns the user token.
	GetUser() antlr.Token

	// SetUser sets the user token.
	SetUser(antlr.Token)

	// GetGrant_role returns the grant_role rule contexts.
	GetGrant_role() IIdentifierContext

	// GetNamespace returns the namespace rule contexts.
	GetNamespace() IIdentifierContext

	// GetRole returns the role rule contexts.
	GetRole() IIdentifierContext

	// GetUser_var returns the user_var rule contexts.
	GetUser_var() IAction_exprContext

	// SetGrant_role sets the grant_role rule contexts.
	SetGrant_role(IIdentifierContext)

	// SetNamespace sets the namespace rule contexts.
	SetNamespace(IIdentifierContext)

	// SetRole sets the role rule contexts.
	SetRole(IIdentifierContext)

	// SetUser_var sets the user_var rule contexts.
	SetUser_var(IAction_exprContext)

	// Getter signatures
	REVOKE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	Privilege_list() IPrivilege_listContext
	IF() antlr.TerminalNode
	GRANTED() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	ON() antlr.TerminalNode
	STRING_() antlr.TerminalNode
	Action_expr() IAction_exprContext

	// IsRevoke_statementContext differentiates from other interfaces.
	IsRevoke_statementContext()
}

type Revoke_statementContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	grant_role IIdentifierContext
	namespace  IIdentifierContext
	role       IIdentifierContext
	user       antlr.Token
	user_var   IAction_exprContext
}

func NewEmptyRevoke_statementContext() *Revoke_statementContext {
	var p = new(Revoke_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_revoke_statement
	return p
}

func InitEmptyRevoke_statementContext(p *Revoke_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_revoke_statement
}

func (*Revoke_statementContext) IsRevoke_statementContext() {}

func NewRevoke_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Revoke_statementContext {
	var p = new(Revoke_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_revoke_statement

	return p
}

func (s *Revoke_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Revoke_statementContext) GetUser() antlr.Token { return s.user }

func (s *Revoke_statementContext) SetUser(v antlr.Token) { s.user = v }

func (s *Revoke_statementContext) GetGrant_role() IIdentifierContext { return s.grant_role }

func (s *Revoke_statementContext) GetNamespace() IIdentifierContext { return s.namespace }

func (s *Revoke_statementContext) GetRole() IIdentifierContext { return s.role }

func (s *Revoke_statementContext) GetUser_var() IAction_exprContext { return s.user_var }

func (s *Revoke_statementContext) SetGrant_role(v IIdentifierContext) { s.grant_role = v }

func (s *Revoke_statementContext) SetNamespace(v IIdentifierContext) { s.namespace = v }

func (s *Revoke_statementContext) SetRole(v IIdentifierContext) { s.role = v }

func (s *Revoke_statementContext) SetUser_var(v IAction_exprContext) { s.user_var = v }

func (s *Revoke_statementContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserREVOKE, 0)
}

func (s *Revoke_statementContext) FROM() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFROM, 0)
}

func (s *Revoke_statementContext) Privilege_list() IPrivilege_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilege_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilege_listContext)
}

func (s *Revoke_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIF, 0)
}

func (s *Revoke_statementContext) GRANTED() antlr.TerminalNode {
	return s.GetToken(KuneiformParserGRANTED, 0)
}

func (s *Revoke_statementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Revoke_statementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Revoke_statementContext) ON() antlr.TerminalNode {
	return s.GetToken(KuneiformParserON, 0)
}

func (s *Revoke_statementContext) STRING_() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSTRING_, 0)
}

func (s *Revoke_statementContext) Action_expr() IAction_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_exprContext)
}

func (s *Revoke_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Revoke_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Revoke_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitRevoke_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Revoke_statement() (localctx IRevoke_statementContext) {
	localctx = NewRevoke_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, KuneiformParserRULE_revoke_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(515)
		p.Match(KuneiformParserREVOKE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(518)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(516)
			p.Match(KuneiformParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(517)
			p.Match(KuneiformParserGRANTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(522)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(520)
			p.Privilege_list()
		}

	case 2:
		{
			p.SetState(521)

			var _x = p.Identifier()

			localctx.(*Revoke_statementContext).grant_role = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(526)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserON {
		{
			p.SetState(524)
			p.Match(KuneiformParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(525)

			var _x = p.Identifier()

			localctx.(*Revoke_statementContext).namespace = _x
		}

	}
	{
		p.SetState(528)
		p.Match(KuneiformParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(532)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(529)

			var _x = p.Identifier()

			localctx.(*Revoke_statementContext).role = _x
		}

	case 2:
		{
			p.SetState(530)

			var _m = p.Match(KuneiformParserSTRING_)

			localctx.(*Revoke_statementContext).user = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(531)

			var _x = p.action_expr(0)

			localctx.(*Revoke_statementContext).user_var = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilege_listContext is an interface to support dynamic dispatch.
type IPrivilege_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrivilege() []IPrivilegeContext
	Privilege(i int) IPrivilegeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPrivilege_listContext differentiates from other interfaces.
	IsPrivilege_listContext()
}

type Privilege_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilege_listContext() *Privilege_listContext {
	var p = new(Privilege_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_privilege_list
	return p
}

func InitEmptyPrivilege_listContext(p *Privilege_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_privilege_list
}

func (*Privilege_listContext) IsPrivilege_listContext() {}

func NewPrivilege_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Privilege_listContext {
	var p = new(Privilege_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_privilege_list

	return p
}

func (s *Privilege_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Privilege_listContext) AllPrivilege() []IPrivilegeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivilegeContext); ok {
			len++
		}
	}

	tst := make([]IPrivilegeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivilegeContext); ok {
			tst[i] = t.(IPrivilegeContext)
			i++
		}
	}

	return tst
}

func (s *Privilege_listContext) Privilege(i int) IPrivilegeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeContext)
}

func (s *Privilege_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Privilege_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Privilege_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Privilege_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Privilege_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitPrivilege_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Privilege_list() (localctx IPrivilege_listContext) {
	localctx = NewPrivilege_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, KuneiformParserRULE_privilege_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(534)
		p.Privilege()
	}
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCOMMA {
		{
			p.SetState(535)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(536)
			p.Privilege()
		}

		p.SetState(541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeContext is an interface to support dynamic dispatch.
type IPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	ROLES() antlr.TerminalNode
	CALL() antlr.TerminalNode
	USE() antlr.TerminalNode

	// IsPrivilegeContext differentiates from other interfaces.
	IsPrivilegeContext()
}

type PrivilegeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeContext() *PrivilegeContext {
	var p = new(PrivilegeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_privilege
	return p
}

func InitEmptyPrivilegeContext(p *PrivilegeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_privilege
}

func (*PrivilegeContext) IsPrivilegeContext() {}

func NewPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeContext {
	var p = new(PrivilegeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_privilege

	return p
}

func (s *PrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeContext) SELECT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSELECT, 0)
}

func (s *PrivilegeContext) INSERT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserINSERT, 0)
}

func (s *PrivilegeContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUPDATE, 0)
}

func (s *PrivilegeContext) DELETE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDELETE, 0)
}

func (s *PrivilegeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCREATE, 0)
}

func (s *PrivilegeContext) DROP() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDROP, 0)
}

func (s *PrivilegeContext) ALTER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserALTER, 0)
}

func (s *PrivilegeContext) ROLES() antlr.TerminalNode {
	return s.GetToken(KuneiformParserROLES, 0)
}

func (s *PrivilegeContext) CALL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCALL, 0)
}

func (s *PrivilegeContext) USE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUSE, 0)
}

func (s *PrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitPrivilege(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Privilege() (localctx IPrivilegeContext) {
	localctx = NewPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, KuneiformParserRULE_privilege)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(542)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&864696368315236352) != 0) || ((int64((_la-98)) & ^0x3f) == 0 && ((int64(1)<<(_la-98))&51539607555) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_action_statementContext is an interface to support dynamic dispatch.
type ICreate_action_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	ACTION() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllVARIABLE() []antlr.TerminalNode
	VARIABLE(i int) antlr.TerminalNode
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	Action_return() IAction_returnContext
	AllAction_statement() []IAction_statementContext
	Action_statement(i int) IAction_statementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreate_action_statementContext differentiates from other interfaces.
	IsCreate_action_statementContext()
}

type Create_action_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_action_statementContext() *Create_action_statementContext {
	var p = new(Create_action_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_create_action_statement
	return p
}

func InitEmptyCreate_action_statementContext(p *Create_action_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_create_action_statement
}

func (*Create_action_statementContext) IsCreate_action_statementContext() {}

func NewCreate_action_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_action_statementContext {
	var p = new(Create_action_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_create_action_statement

	return p
}

func (s *Create_action_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_action_statementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCREATE, 0)
}

func (s *Create_action_statementContext) ACTION() antlr.TerminalNode {
	return s.GetToken(KuneiformParserACTION, 0)
}

func (s *Create_action_statementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Create_action_statementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Create_action_statementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Create_action_statementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Create_action_statementContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACE, 0)
}

func (s *Create_action_statementContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACE, 0)
}

func (s *Create_action_statementContext) OR() antlr.TerminalNode {
	return s.GetToken(KuneiformParserOR, 0)
}

func (s *Create_action_statementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserREPLACE, 0)
}

func (s *Create_action_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIF, 0)
}

func (s *Create_action_statementContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Create_action_statementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEXISTS, 0)
}

func (s *Create_action_statementContext) AllVARIABLE() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserVARIABLE)
}

func (s *Create_action_statementContext) VARIABLE(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserVARIABLE, i)
}

func (s *Create_action_statementContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *Create_action_statementContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Create_action_statementContext) Action_return() IAction_returnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_returnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_returnContext)
}

func (s *Create_action_statementContext) AllAction_statement() []IAction_statementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAction_statementContext); ok {
			len++
		}
	}

	tst := make([]IAction_statementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAction_statementContext); ok {
			tst[i] = t.(IAction_statementContext)
			i++
		}
	}

	return tst
}

func (s *Create_action_statementContext) Action_statement(i int) IAction_statementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_statementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_statementContext)
}

func (s *Create_action_statementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Create_action_statementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Create_action_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_action_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_action_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitCreate_action_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Create_action_statement() (localctx ICreate_action_statementContext) {
	localctx = NewCreate_action_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, KuneiformParserRULE_create_action_statement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(544)
		p.Match(KuneiformParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(547)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserOR {
		{
			p.SetState(545)
			p.Match(KuneiformParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(546)
			p.Match(KuneiformParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(549)
		p.Match(KuneiformParserACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(553)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(550)
			p.Match(KuneiformParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(551)
			p.Match(KuneiformParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(552)
			p.Match(KuneiformParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(555)
		p.Identifier()
	}
	{
		p.SetState(556)
		p.Match(KuneiformParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserVARIABLE {
		{
			p.SetState(557)
			p.Match(KuneiformParserVARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(558)
			p.Type_()
		}
		p.SetState(564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KuneiformParserCOMMA {
			{
				p.SetState(559)
				p.Match(KuneiformParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(560)
				p.Match(KuneiformParserVARIABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(561)
				p.Type_()
			}

			p.SetState(566)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(569)
		p.Match(KuneiformParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(573)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(570)
				p.Identifier()
			}

		}
		p.SetState(575)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(577)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserRETURNS {
		{
			p.SetState(576)
			p.Action_return()
		}

	}
	{
		p.SetState(579)
		p.Match(KuneiformParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(583)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3507232162117056376) != 0) || ((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&2022115962081253381) != 0) {
		{
			p.SetState(580)
			p.Action_statement()
		}

		p.SetState(585)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(586)
		p.Match(KuneiformParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_action_statementContext is an interface to support dynamic dispatch.
type IDrop_action_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	ACTION() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDrop_action_statementContext differentiates from other interfaces.
	IsDrop_action_statementContext()
}

type Drop_action_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_action_statementContext() *Drop_action_statementContext {
	var p = new(Drop_action_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_drop_action_statement
	return p
}

func InitEmptyDrop_action_statementContext(p *Drop_action_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_drop_action_statement
}

func (*Drop_action_statementContext) IsDrop_action_statementContext() {}

func NewDrop_action_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_action_statementContext {
	var p = new(Drop_action_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_drop_action_statement

	return p
}

func (s *Drop_action_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_action_statementContext) DROP() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDROP, 0)
}

func (s *Drop_action_statementContext) ACTION() antlr.TerminalNode {
	return s.GetToken(KuneiformParserACTION, 0)
}

func (s *Drop_action_statementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Drop_action_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIF, 0)
}

func (s *Drop_action_statementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEXISTS, 0)
}

func (s *Drop_action_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_action_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_action_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitDrop_action_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Drop_action_statement() (localctx IDrop_action_statementContext) {
	localctx = NewDrop_action_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, KuneiformParserRULE_drop_action_statement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(588)
		p.Match(KuneiformParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(589)
		p.Match(KuneiformParserACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(592)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(590)
			p.Match(KuneiformParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(591)
			p.Match(KuneiformParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(594)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUse_extension_statementContext is an interface to support dynamic dispatch.
type IUse_extension_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetExtension_name returns the extension_name rule contexts.
	GetExtension_name() IIdentifierContext

	// GetAlias returns the alias rule contexts.
	GetAlias() IIdentifierContext

	// SetExtension_name sets the extension_name rule contexts.
	SetExtension_name(IIdentifierContext)

	// SetAlias sets the alias rule contexts.
	SetAlias(IIdentifierContext)

	// Getter signatures
	USE() antlr.TerminalNode
	AS() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllCOL() []antlr.TerminalNode
	COL(i int) antlr.TerminalNode
	AllAction_expr() []IAction_exprContext
	Action_expr(i int) IAction_exprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUse_extension_statementContext differentiates from other interfaces.
	IsUse_extension_statementContext()
}

type Use_extension_statementContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	extension_name IIdentifierContext
	alias          IIdentifierContext
}

func NewEmptyUse_extension_statementContext() *Use_extension_statementContext {
	var p = new(Use_extension_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_use_extension_statement
	return p
}

func InitEmptyUse_extension_statementContext(p *Use_extension_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_use_extension_statement
}

func (*Use_extension_statementContext) IsUse_extension_statementContext() {}

func NewUse_extension_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Use_extension_statementContext {
	var p = new(Use_extension_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_use_extension_statement

	return p
}

func (s *Use_extension_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Use_extension_statementContext) GetExtension_name() IIdentifierContext {
	return s.extension_name
}

func (s *Use_extension_statementContext) GetAlias() IIdentifierContext { return s.alias }

func (s *Use_extension_statementContext) SetExtension_name(v IIdentifierContext) {
	s.extension_name = v
}

func (s *Use_extension_statementContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *Use_extension_statementContext) USE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUSE, 0)
}

func (s *Use_extension_statementContext) AS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAS, 0)
}

func (s *Use_extension_statementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Use_extension_statementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Use_extension_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIF, 0)
}

func (s *Use_extension_statementContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Use_extension_statementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEXISTS, 0)
}

func (s *Use_extension_statementContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACE, 0)
}

func (s *Use_extension_statementContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACE, 0)
}

func (s *Use_extension_statementContext) AllCOL() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOL)
}

func (s *Use_extension_statementContext) COL(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOL, i)
}

func (s *Use_extension_statementContext) AllAction_expr() []IAction_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAction_exprContext); ok {
			len++
		}
	}

	tst := make([]IAction_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAction_exprContext); ok {
			tst[i] = t.(IAction_exprContext)
			i++
		}
	}

	return tst
}

func (s *Use_extension_statementContext) Action_expr(i int) IAction_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_exprContext)
}

func (s *Use_extension_statementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Use_extension_statementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Use_extension_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Use_extension_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Use_extension_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitUse_extension_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Use_extension_statement() (localctx IUse_extension_statementContext) {
	localctx = NewUse_extension_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, KuneiformParserRULE_use_extension_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(596)
		p.Match(KuneiformParserUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(600)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(597)
			p.Match(KuneiformParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(598)
			p.Match(KuneiformParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(599)
			p.Match(KuneiformParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(602)

		var _x = p.Identifier()

		localctx.(*Use_extension_statementContext).extension_name = _x
	}
	p.SetState(620)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserLBRACE {
		{
			p.SetState(603)
			p.Match(KuneiformParserLBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(617)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9127724498152325120) != 0) || ((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&288362046938939393) != 0) {
			{
				p.SetState(604)
				p.Identifier()
			}
			{
				p.SetState(605)
				p.Match(KuneiformParserCOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(606)
				p.action_expr(0)
			}
			p.SetState(614)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KuneiformParserCOMMA {
				{
					p.SetState(607)
					p.Match(KuneiformParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(608)
					p.Identifier()
				}
				{
					p.SetState(609)
					p.Match(KuneiformParserCOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(610)
					p.action_expr(0)
				}

				p.SetState(616)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(619)
			p.Match(KuneiformParserRBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(622)
		p.Match(KuneiformParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(623)

		var _x = p.Identifier()

		localctx.(*Use_extension_statementContext).alias = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnuse_extension_statementContext is an interface to support dynamic dispatch.
type IUnuse_extension_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlias returns the alias rule contexts.
	GetAlias() IIdentifierContext

	// SetAlias sets the alias rule contexts.
	SetAlias(IIdentifierContext)

	// Getter signatures
	UNUSE() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsUnuse_extension_statementContext differentiates from other interfaces.
	IsUnuse_extension_statementContext()
}

type Unuse_extension_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	alias  IIdentifierContext
}

func NewEmptyUnuse_extension_statementContext() *Unuse_extension_statementContext {
	var p = new(Unuse_extension_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_unuse_extension_statement
	return p
}

func InitEmptyUnuse_extension_statementContext(p *Unuse_extension_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_unuse_extension_statement
}

func (*Unuse_extension_statementContext) IsUnuse_extension_statementContext() {}

func NewUnuse_extension_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unuse_extension_statementContext {
	var p = new(Unuse_extension_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_unuse_extension_statement

	return p
}

func (s *Unuse_extension_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Unuse_extension_statementContext) GetAlias() IIdentifierContext { return s.alias }

func (s *Unuse_extension_statementContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *Unuse_extension_statementContext) UNUSE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUNUSE, 0)
}

func (s *Unuse_extension_statementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Unuse_extension_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIF, 0)
}

func (s *Unuse_extension_statementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEXISTS, 0)
}

func (s *Unuse_extension_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unuse_extension_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unuse_extension_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitUnuse_extension_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Unuse_extension_statement() (localctx IUnuse_extension_statementContext) {
	localctx = NewUnuse_extension_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, KuneiformParserRULE_unuse_extension_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(625)
		p.Match(KuneiformParserUNUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(626)

		var _x = p.Identifier()

		localctx.(*Unuse_extension_statementContext).alias = _x
	}
	p.SetState(629)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserIF {
		{
			p.SetState(627)
			p.Match(KuneiformParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(628)
			p.Match(KuneiformParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_namespace_statementContext is an interface to support dynamic dispatch.
type ICreate_namespace_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	NAMESPACE() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsCreate_namespace_statementContext differentiates from other interfaces.
	IsCreate_namespace_statementContext()
}

type Create_namespace_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_namespace_statementContext() *Create_namespace_statementContext {
	var p = new(Create_namespace_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_create_namespace_statement
	return p
}

func InitEmptyCreate_namespace_statementContext(p *Create_namespace_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_create_namespace_statement
}

func (*Create_namespace_statementContext) IsCreate_namespace_statementContext() {}

func NewCreate_namespace_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_namespace_statementContext {
	var p = new(Create_namespace_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_create_namespace_statement

	return p
}

func (s *Create_namespace_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_namespace_statementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCREATE, 0)
}

func (s *Create_namespace_statementContext) NAMESPACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNAMESPACE, 0)
}

func (s *Create_namespace_statementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Create_namespace_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIF, 0)
}

func (s *Create_namespace_statementContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Create_namespace_statementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEXISTS, 0)
}

func (s *Create_namespace_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_namespace_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_namespace_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitCreate_namespace_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Create_namespace_statement() (localctx ICreate_namespace_statementContext) {
	localctx = NewCreate_namespace_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, KuneiformParserRULE_create_namespace_statement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(631)
		p.Match(KuneiformParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(632)
		p.Match(KuneiformParserNAMESPACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(636)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(633)
			p.Match(KuneiformParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(634)
			p.Match(KuneiformParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(635)
			p.Match(KuneiformParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(638)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_namespace_statementContext is an interface to support dynamic dispatch.
type IDrop_namespace_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	NAMESPACE() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDrop_namespace_statementContext differentiates from other interfaces.
	IsDrop_namespace_statementContext()
}

type Drop_namespace_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_namespace_statementContext() *Drop_namespace_statementContext {
	var p = new(Drop_namespace_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_drop_namespace_statement
	return p
}

func InitEmptyDrop_namespace_statementContext(p *Drop_namespace_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_drop_namespace_statement
}

func (*Drop_namespace_statementContext) IsDrop_namespace_statementContext() {}

func NewDrop_namespace_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_namespace_statementContext {
	var p = new(Drop_namespace_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_drop_namespace_statement

	return p
}

func (s *Drop_namespace_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_namespace_statementContext) DROP() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDROP, 0)
}

func (s *Drop_namespace_statementContext) NAMESPACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNAMESPACE, 0)
}

func (s *Drop_namespace_statementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Drop_namespace_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIF, 0)
}

func (s *Drop_namespace_statementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEXISTS, 0)
}

func (s *Drop_namespace_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_namespace_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_namespace_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitDrop_namespace_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Drop_namespace_statement() (localctx IDrop_namespace_statementContext) {
	localctx = NewDrop_namespace_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, KuneiformParserRULE_drop_namespace_statement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(640)
		p.Match(KuneiformParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(641)
		p.Match(KuneiformParserNAMESPACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(644)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(642)
			p.Match(KuneiformParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(643)
			p.Match(KuneiformParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(646)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_statementContext is an interface to support dynamic dispatch.
type ISelect_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit rule contexts.
	GetLimit() ISql_exprContext

	// GetOffset returns the offset rule contexts.
	GetOffset() ISql_exprContext

	// SetLimit sets the limit rule contexts.
	SetLimit(ISql_exprContext)

	// SetOffset sets the offset rule contexts.
	SetOffset(ISql_exprContext)

	// Getter signatures
	AllSelect_core() []ISelect_coreContext
	Select_core(i int) ISelect_coreContext
	AllCompound_operator() []ICompound_operatorContext
	Compound_operator(i int) ICompound_operatorContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllOrdering_term() []IOrdering_termContext
	Ordering_term(i int) IOrdering_termContext
	LIMIT() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	AllSql_expr() []ISql_exprContext
	Sql_expr(i int) ISql_exprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSelect_statementContext differentiates from other interfaces.
	IsSelect_statementContext()
}

type Select_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  ISql_exprContext
	offset ISql_exprContext
}

func NewEmptySelect_statementContext() *Select_statementContext {
	var p = new(Select_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_select_statement
	return p
}

func InitEmptySelect_statementContext(p *Select_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_select_statement
}

func (*Select_statementContext) IsSelect_statementContext() {}

func NewSelect_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_statementContext {
	var p = new(Select_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_select_statement

	return p
}

func (s *Select_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_statementContext) GetLimit() ISql_exprContext { return s.limit }

func (s *Select_statementContext) GetOffset() ISql_exprContext { return s.offset }

func (s *Select_statementContext) SetLimit(v ISql_exprContext) { s.limit = v }

func (s *Select_statementContext) SetOffset(v ISql_exprContext) { s.offset = v }

func (s *Select_statementContext) AllSelect_core() []ISelect_coreContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelect_coreContext); ok {
			len++
		}
	}

	tst := make([]ISelect_coreContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelect_coreContext); ok {
			tst[i] = t.(ISelect_coreContext)
			i++
		}
	}

	return tst
}

func (s *Select_statementContext) Select_core(i int) ISelect_coreContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_coreContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_coreContext)
}

func (s *Select_statementContext) AllCompound_operator() []ICompound_operatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICompound_operatorContext); ok {
			len++
		}
	}

	tst := make([]ICompound_operatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICompound_operatorContext); ok {
			tst[i] = t.(ICompound_operatorContext)
			i++
		}
	}

	return tst
}

func (s *Select_statementContext) Compound_operator(i int) ICompound_operatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompound_operatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompound_operatorContext)
}

func (s *Select_statementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserORDER, 0)
}

func (s *Select_statementContext) BY() antlr.TerminalNode {
	return s.GetToken(KuneiformParserBY, 0)
}

func (s *Select_statementContext) AllOrdering_term() []IOrdering_termContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrdering_termContext); ok {
			len++
		}
	}

	tst := make([]IOrdering_termContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrdering_termContext); ok {
			tst[i] = t.(IOrdering_termContext)
			i++
		}
	}

	return tst
}

func (s *Select_statementContext) Ordering_term(i int) IOrdering_termContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrdering_termContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrdering_termContext)
}

func (s *Select_statementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLIMIT, 0)
}

func (s *Select_statementContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserOFFSET, 0)
}

func (s *Select_statementContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Select_statementContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Select_statementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Select_statementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Select_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitSelect_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Select_statement() (localctx ISelect_statementContext) {
	localctx = NewSelect_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, KuneiformParserRULE_select_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(648)
		p.Select_core()
	}
	p.SetState(654)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-102)) & ^0x3f) == 0 && ((int64(1)<<(_la-102))&7) != 0 {
		{
			p.SetState(649)
			p.Compound_operator()
		}
		{
			p.SetState(650)
			p.Select_core()
		}

		p.SetState(656)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(667)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserORDER {
		{
			p.SetState(657)
			p.Match(KuneiformParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(658)
			p.Match(KuneiformParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(659)
			p.Ordering_term()
		}
		p.SetState(664)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KuneiformParserCOMMA {
			{
				p.SetState(660)
				p.Match(KuneiformParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(661)
				p.Ordering_term()
			}

			p.SetState(666)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(671)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserLIMIT {
		{
			p.SetState(669)
			p.Match(KuneiformParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(670)

			var _x = p.sql_expr(0)

			localctx.(*Select_statementContext).limit = _x
		}

	}
	p.SetState(675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserOFFSET {
		{
			p.SetState(673)
			p.Match(KuneiformParserOFFSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(674)

			var _x = p.sql_expr(0)

			localctx.(*Select_statementContext).offset = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompound_operatorContext is an interface to support dynamic dispatch.
type ICompound_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNION() antlr.TerminalNode
	ALL() antlr.TerminalNode
	INTERSECT() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode

	// IsCompound_operatorContext differentiates from other interfaces.
	IsCompound_operatorContext()
}

type Compound_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompound_operatorContext() *Compound_operatorContext {
	var p = new(Compound_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_compound_operator
	return p
}

func InitEmptyCompound_operatorContext(p *Compound_operatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_compound_operator
}

func (*Compound_operatorContext) IsCompound_operatorContext() {}

func NewCompound_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compound_operatorContext {
	var p = new(Compound_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_compound_operator

	return p
}

func (s *Compound_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Compound_operatorContext) UNION() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUNION, 0)
}

func (s *Compound_operatorContext) ALL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserALL, 0)
}

func (s *Compound_operatorContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserINTERSECT, 0)
}

func (s *Compound_operatorContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEXCEPT, 0)
}

func (s *Compound_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compound_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Compound_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitCompound_operator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Compound_operator() (localctx ICompound_operatorContext) {
	localctx = NewCompound_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, KuneiformParserRULE_compound_operator)
	var _la int

	p.SetState(683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KuneiformParserUNION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(677)
			p.Match(KuneiformParserUNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(679)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserALL {
			{
				p.SetState(678)
				p.Match(KuneiformParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case KuneiformParserINTERSECT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(681)
			p.Match(KuneiformParserINTERSECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KuneiformParserEXCEPT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(682)
			p.Match(KuneiformParserEXCEPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrdering_termContext is an interface to support dynamic dispatch.
type IOrdering_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Sql_expr() ISql_exprContext
	NULLS() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode

	// IsOrdering_termContext differentiates from other interfaces.
	IsOrdering_termContext()
}

type Ordering_termContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrdering_termContext() *Ordering_termContext {
	var p = new(Ordering_termContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_ordering_term
	return p
}

func InitEmptyOrdering_termContext(p *Ordering_termContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_ordering_term
}

func (*Ordering_termContext) IsOrdering_termContext() {}

func NewOrdering_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ordering_termContext {
	var p = new(Ordering_termContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_ordering_term

	return p
}

func (s *Ordering_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Ordering_termContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Ordering_termContext) NULLS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNULLS, 0)
}

func (s *Ordering_termContext) ASC() antlr.TerminalNode {
	return s.GetToken(KuneiformParserASC, 0)
}

func (s *Ordering_termContext) DESC() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDESC, 0)
}

func (s *Ordering_termContext) FIRST() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFIRST, 0)
}

func (s *Ordering_termContext) LAST() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLAST, 0)
}

func (s *Ordering_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ordering_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ordering_termContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitOrdering_term(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Ordering_term() (localctx IOrdering_termContext) {
	localctx = NewOrdering_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, KuneiformParserRULE_ordering_term)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(685)
		p.sql_expr(0)
	}
	p.SetState(687)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserASC || _la == KuneiformParserDESC {
		{
			p.SetState(686)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KuneiformParserASC || _la == KuneiformParserDESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(691)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserNULLS {
		{
			p.SetState(689)
			p.Match(KuneiformParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(690)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KuneiformParserFIRST || _la == KuneiformParserLAST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_coreContext is an interface to support dynamic dispatch.
type ISelect_coreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() ISql_exprContext

	// GetGroup_by returns the group_by rule contexts.
	GetGroup_by() ISql_expr_listContext

	// GetHaving returns the having rule contexts.
	GetHaving() ISql_exprContext

	// SetWhere sets the where rule contexts.
	SetWhere(ISql_exprContext)

	// SetGroup_by sets the group_by rule contexts.
	SetGroup_by(ISql_expr_listContext)

	// SetHaving sets the having rule contexts.
	SetHaving(ISql_exprContext)

	// Getter signatures
	SELECT() antlr.TerminalNode
	AllResult_column() []IResult_columnContext
	Result_column(i int) IResult_columnContext
	DISTINCT() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	FROM() antlr.TerminalNode
	Relation() IRelationContext
	WHERE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	WINDOW() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllAS() []antlr.TerminalNode
	AS(i int) antlr.TerminalNode
	AllWindow() []IWindowContext
	Window(i int) IWindowContext
	AllSql_expr() []ISql_exprContext
	Sql_expr(i int) ISql_exprContext
	Sql_expr_list() ISql_expr_listContext
	AllJoin() []IJoinContext
	Join(i int) IJoinContext
	HAVING() antlr.TerminalNode

	// IsSelect_coreContext differentiates from other interfaces.
	IsSelect_coreContext()
}

type Select_coreContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	where    ISql_exprContext
	group_by ISql_expr_listContext
	having   ISql_exprContext
}

func NewEmptySelect_coreContext() *Select_coreContext {
	var p = new(Select_coreContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_select_core
	return p
}

func InitEmptySelect_coreContext(p *Select_coreContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_select_core
}

func (*Select_coreContext) IsSelect_coreContext() {}

func NewSelect_coreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_coreContext {
	var p = new(Select_coreContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_select_core

	return p
}

func (s *Select_coreContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_coreContext) GetWhere() ISql_exprContext { return s.where }

func (s *Select_coreContext) GetGroup_by() ISql_expr_listContext { return s.group_by }

func (s *Select_coreContext) GetHaving() ISql_exprContext { return s.having }

func (s *Select_coreContext) SetWhere(v ISql_exprContext) { s.where = v }

func (s *Select_coreContext) SetGroup_by(v ISql_expr_listContext) { s.group_by = v }

func (s *Select_coreContext) SetHaving(v ISql_exprContext) { s.having = v }

func (s *Select_coreContext) SELECT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSELECT, 0)
}

func (s *Select_coreContext) AllResult_column() []IResult_columnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResult_columnContext); ok {
			len++
		}
	}

	tst := make([]IResult_columnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResult_columnContext); ok {
			tst[i] = t.(IResult_columnContext)
			i++
		}
	}

	return tst
}

func (s *Select_coreContext) Result_column(i int) IResult_columnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResult_columnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResult_columnContext)
}

func (s *Select_coreContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDISTINCT, 0)
}

func (s *Select_coreContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Select_coreContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Select_coreContext) FROM() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFROM, 0)
}

func (s *Select_coreContext) Relation() IRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *Select_coreContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserWHERE, 0)
}

func (s *Select_coreContext) GROUP() antlr.TerminalNode {
	return s.GetToken(KuneiformParserGROUP, 0)
}

func (s *Select_coreContext) BY() antlr.TerminalNode {
	return s.GetToken(KuneiformParserBY, 0)
}

func (s *Select_coreContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(KuneiformParserWINDOW, 0)
}

func (s *Select_coreContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Select_coreContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Select_coreContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserAS)
}

func (s *Select_coreContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserAS, i)
}

func (s *Select_coreContext) AllWindow() []IWindowContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindowContext); ok {
			len++
		}
	}

	tst := make([]IWindowContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindowContext); ok {
			tst[i] = t.(IWindowContext)
			i++
		}
	}

	return tst
}

func (s *Select_coreContext) Window(i int) IWindowContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowContext)
}

func (s *Select_coreContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Select_coreContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Select_coreContext) Sql_expr_list() ISql_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_expr_listContext)
}

func (s *Select_coreContext) AllJoin() []IJoinContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinContext); ok {
			len++
		}
	}

	tst := make([]IJoinContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinContext); ok {
			tst[i] = t.(IJoinContext)
			i++
		}
	}

	return tst
}

func (s *Select_coreContext) Join(i int) IJoinContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinContext)
}

func (s *Select_coreContext) HAVING() antlr.TerminalNode {
	return s.GetToken(KuneiformParserHAVING, 0)
}

func (s *Select_coreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_coreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_coreContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitSelect_core(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Select_core() (localctx ISelect_coreContext) {
	localctx = NewSelect_coreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, KuneiformParserRULE_select_core)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(693)
		p.Match(KuneiformParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserDISTINCT {
		{
			p.SetState(694)
			p.Match(KuneiformParserDISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(697)
		p.Result_column()
	}
	p.SetState(702)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCOMMA {
		{
			p.SetState(698)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(699)
			p.Result_column()
		}

		p.SetState(704)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(713)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserFROM {
		{
			p.SetState(705)
			p.Match(KuneiformParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(706)
			p.Relation()
		}
		p.SetState(710)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-74)) & ^0x3f) == 0 && ((int64(1)<<(_la-74))&134217743) != 0 {
			{
				p.SetState(707)
				p.Join()
			}

			p.SetState(712)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(717)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserWHERE {
		{
			p.SetState(715)
			p.Match(KuneiformParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(716)

			var _x = p.sql_expr(0)

			localctx.(*Select_coreContext).where = _x
		}

	}
	p.SetState(726)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserGROUP {
		{
			p.SetState(719)
			p.Match(KuneiformParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(720)
			p.Match(KuneiformParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(721)

			var _x = p.Sql_expr_list()

			localctx.(*Select_coreContext).group_by = _x
		}
		p.SetState(724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserHAVING {
			{
				p.SetState(722)
				p.Match(KuneiformParserHAVING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(723)

				var _x = p.sql_expr(0)

				localctx.(*Select_coreContext).having = _x
			}

		}

	}
	p.SetState(742)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserWINDOW {
		{
			p.SetState(728)
			p.Match(KuneiformParserWINDOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(729)
			p.Identifier()
		}
		{
			p.SetState(730)
			p.Match(KuneiformParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(731)
			p.Window()
		}
		p.SetState(739)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KuneiformParserCOMMA {
			{
				p.SetState(732)
				p.Match(KuneiformParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(733)
				p.Identifier()
			}
			{
				p.SetState(734)
				p.Match(KuneiformParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(735)
				p.Window()
			}

			p.SetState(741)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_relation
	return p
}

func InitEmptyRelationContext(p *RelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_relation
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) CopyAll(ctx *RelationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Table_relationContext struct {
	RelationContext
	namespace  IIdentifierContext
	table_name IIdentifierContext
	alias      IIdentifierContext
}

func NewTable_relationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Table_relationContext {
	var p = new(Table_relationContext)

	InitEmptyRelationContext(&p.RelationContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationContext))

	return p
}

func (s *Table_relationContext) GetNamespace() IIdentifierContext { return s.namespace }

func (s *Table_relationContext) GetTable_name() IIdentifierContext { return s.table_name }

func (s *Table_relationContext) GetAlias() IIdentifierContext { return s.alias }

func (s *Table_relationContext) SetNamespace(v IIdentifierContext) { s.namespace = v }

func (s *Table_relationContext) SetTable_name(v IIdentifierContext) { s.table_name = v }

func (s *Table_relationContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *Table_relationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_relationContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Table_relationContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Table_relationContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPERIOD, 0)
}

func (s *Table_relationContext) AS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAS, 0)
}

func (s *Table_relationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitTable_relation(s)

	default:
		return t.VisitChildren(s)
	}
}

type Subquery_relationContext struct {
	RelationContext
	alias IIdentifierContext
}

func NewSubquery_relationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Subquery_relationContext {
	var p = new(Subquery_relationContext)

	InitEmptyRelationContext(&p.RelationContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationContext))

	return p
}

func (s *Subquery_relationContext) GetAlias() IIdentifierContext { return s.alias }

func (s *Subquery_relationContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *Subquery_relationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subquery_relationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Subquery_relationContext) Select_statement() ISelect_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *Subquery_relationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Subquery_relationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Subquery_relationContext) AS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAS, 0)
}

func (s *Subquery_relationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitSubquery_relation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Relation() (localctx IRelationContext) {
	localctx = NewRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, KuneiformParserRULE_relation)
	var _la int

	p.SetState(765)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KuneiformParserDOUBLE_QUOTE, KuneiformParserUSE, KuneiformParserUNUSE, KuneiformParserACTION, KuneiformParserCREATE, KuneiformParserALTER, KuneiformParserADD, KuneiformParserDROP, KuneiformParserRENAME, KuneiformParserCHECK, KuneiformParserFOREIGN, KuneiformParserPRIMARY, KuneiformParserKEY, KuneiformParserUNIQUE, KuneiformParserRESTRICT, KuneiformParserDEFAULT, KuneiformParserINDEX, KuneiformParserRETURNS, KuneiformParserCONFLICT, KuneiformParserFOR, KuneiformParserIF, KuneiformParserELSEIF, KuneiformParserELSE, KuneiformParserBREAK, KuneiformParserCONTINUE, KuneiformParserRETURN, KuneiformParserGRANT, KuneiformParserGRANTED, KuneiformParserREVOKE, KuneiformParserROLE, KuneiformParserREPLACE, KuneiformParserNAMESPACE, KuneiformParserROLES, KuneiformParserCALL, KuneiformParserIDENTIFIER:
		localctx = NewTable_relationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(747)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(744)

				var _x = p.Identifier()

				localctx.(*Table_relationContext).namespace = _x
			}
			{
				p.SetState(745)
				p.Match(KuneiformParserPERIOD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(749)

			var _x = p.Identifier()

			localctx.(*Table_relationContext).table_name = _x
		}
		p.SetState(754)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-33)) & ^0x3f) == 0 && ((int64(1)<<(_la-33))&18049583966447479) != 0) || ((int64((_la-110)) & ^0x3f) == 0 && ((int64(1)<<(_la-110))&34375434749) != 0) {
			p.SetState(751)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == KuneiformParserAS {
				{
					p.SetState(750)
					p.Match(KuneiformParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(753)

				var _x = p.Identifier()

				localctx.(*Table_relationContext).alias = _x
			}

		}

	case KuneiformParserLPAREN:
		localctx = NewSubquery_relationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(756)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(757)
			p.Select_statement()
		}
		{
			p.SetState(758)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(763)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-33)) & ^0x3f) == 0 && ((int64(1)<<(_la-33))&18049583966447479) != 0) || ((int64((_la-110)) & ^0x3f) == 0 && ((int64(1)<<(_la-110))&34375434749) != 0) {
			p.SetState(760)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == KuneiformParserAS {
				{
					p.SetState(759)
					p.Match(KuneiformParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(762)

				var _x = p.Identifier()

				localctx.(*Subquery_relationContext).alias = _x
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinContext is an interface to support dynamic dispatch.
type IJoinContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JOIN() antlr.TerminalNode
	Relation() IRelationContext
	ON() antlr.TerminalNode
	Sql_expr() ISql_exprContext
	INNER() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	FULL() antlr.TerminalNode

	// IsJoinContext differentiates from other interfaces.
	IsJoinContext()
}

type JoinContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinContext() *JoinContext {
	var p = new(JoinContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_join
	return p
}

func InitEmptyJoinContext(p *JoinContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_join
}

func (*JoinContext) IsJoinContext() {}

func NewJoinContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinContext {
	var p = new(JoinContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_join

	return p
}

func (s *JoinContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinContext) JOIN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserJOIN, 0)
}

func (s *JoinContext) Relation() IRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *JoinContext) ON() antlr.TerminalNode {
	return s.GetToken(KuneiformParserON, 0)
}

func (s *JoinContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *JoinContext) INNER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserINNER, 0)
}

func (s *JoinContext) LEFT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLEFT, 0)
}

func (s *JoinContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRIGHT, 0)
}

func (s *JoinContext) FULL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFULL, 0)
}

func (s *JoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitJoin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Join() (localctx IJoinContext) {
	localctx = NewJoinContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, KuneiformParserRULE_join)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(768)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-75)) & ^0x3f) == 0 && ((int64(1)<<(_la-75))&67108871) != 0 {
		{
			p.SetState(767)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-75)) & ^0x3f) == 0 && ((int64(1)<<(_la-75))&67108871) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(770)
		p.Match(KuneiformParserJOIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(771)
		p.Relation()
	}
	{
		p.SetState(772)
		p.Match(KuneiformParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(773)
		p.sql_expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResult_columnContext is an interface to support dynamic dispatch.
type IResult_columnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsResult_columnContext differentiates from other interfaces.
	IsResult_columnContext()
}

type Result_columnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResult_columnContext() *Result_columnContext {
	var p = new(Result_columnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_result_column
	return p
}

func InitEmptyResult_columnContext(p *Result_columnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_result_column
}

func (*Result_columnContext) IsResult_columnContext() {}

func NewResult_columnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Result_columnContext {
	var p = new(Result_columnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_result_column

	return p
}

func (s *Result_columnContext) GetParser() antlr.Parser { return s.parser }

func (s *Result_columnContext) CopyAll(ctx *Result_columnContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *Result_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Result_columnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Expression_result_columnContext struct {
	Result_columnContext
}

func NewExpression_result_columnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Expression_result_columnContext {
	var p = new(Expression_result_columnContext)

	InitEmptyResult_columnContext(&p.Result_columnContext)
	p.parser = parser
	p.CopyAll(ctx.(*Result_columnContext))

	return p
}

func (s *Expression_result_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_result_columnContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Expression_result_columnContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Expression_result_columnContext) AS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAS, 0)
}

func (s *Expression_result_columnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitExpression_result_column(s)

	default:
		return t.VisitChildren(s)
	}
}

type Wildcard_result_columnContext struct {
	Result_columnContext
	table_name IIdentifierContext
}

func NewWildcard_result_columnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Wildcard_result_columnContext {
	var p = new(Wildcard_result_columnContext)

	InitEmptyResult_columnContext(&p.Result_columnContext)
	p.parser = parser
	p.CopyAll(ctx.(*Result_columnContext))

	return p
}

func (s *Wildcard_result_columnContext) GetTable_name() IIdentifierContext { return s.table_name }

func (s *Wildcard_result_columnContext) SetTable_name(v IIdentifierContext) { s.table_name = v }

func (s *Wildcard_result_columnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Wildcard_result_columnContext) STAR() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSTAR, 0)
}

func (s *Wildcard_result_columnContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPERIOD, 0)
}

func (s *Wildcard_result_columnContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Wildcard_result_columnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitWildcard_result_column(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Result_column() (localctx IResult_columnContext) {
	localctx = NewResult_columnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, KuneiformParserRULE_result_column)
	var _la int

	p.SetState(788)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		localctx = NewExpression_result_columnContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(775)
			p.sql_expr(0)
		}
		p.SetState(780)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-33)) & ^0x3f) == 0 && ((int64(1)<<(_la-33))&18049583966447479) != 0) || ((int64((_la-110)) & ^0x3f) == 0 && ((int64(1)<<(_la-110))&34375434749) != 0) {
			p.SetState(777)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == KuneiformParserAS {
				{
					p.SetState(776)
					p.Match(KuneiformParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(779)
				p.Identifier()
			}

		}

	case 2:
		localctx = NewWildcard_result_columnContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(785)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9127724498152325120) != 0) || ((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&288362046938939393) != 0) {
			{
				p.SetState(782)

				var _x = p.Identifier()

				localctx.(*Wildcard_result_columnContext).table_name = _x
			}
			{
				p.SetState(783)
				p.Match(KuneiformParserPERIOD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(787)
			p.Match(KuneiformParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdate_statementContext is an interface to support dynamic dispatch.
type IUpdate_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable_name returns the table_name rule contexts.
	GetTable_name() IIdentifierContext

	// GetAlias returns the alias rule contexts.
	GetAlias() IIdentifierContext

	// GetWhere returns the where rule contexts.
	GetWhere() ISql_exprContext

	// SetTable_name sets the table_name rule contexts.
	SetTable_name(IIdentifierContext)

	// SetAlias sets the alias rule contexts.
	SetAlias(IIdentifierContext)

	// SetWhere sets the where rule contexts.
	SetWhere(ISql_exprContext)

	// Getter signatures
	UPDATE() antlr.TerminalNode
	SET() antlr.TerminalNode
	AllUpdate_set_clause() []IUpdate_set_clauseContext
	Update_set_clause(i int) IUpdate_set_clauseContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	FROM() antlr.TerminalNode
	Relation() IRelationContext
	WHERE() antlr.TerminalNode
	Sql_expr() ISql_exprContext
	AS() antlr.TerminalNode
	AllJoin() []IJoinContext
	Join(i int) IJoinContext

	// IsUpdate_statementContext differentiates from other interfaces.
	IsUpdate_statementContext()
}

type Update_statementContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	table_name IIdentifierContext
	alias      IIdentifierContext
	where      ISql_exprContext
}

func NewEmptyUpdate_statementContext() *Update_statementContext {
	var p = new(Update_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_update_statement
	return p
}

func InitEmptyUpdate_statementContext(p *Update_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_update_statement
}

func (*Update_statementContext) IsUpdate_statementContext() {}

func NewUpdate_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_statementContext {
	var p = new(Update_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_update_statement

	return p
}

func (s *Update_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_statementContext) GetTable_name() IIdentifierContext { return s.table_name }

func (s *Update_statementContext) GetAlias() IIdentifierContext { return s.alias }

func (s *Update_statementContext) GetWhere() ISql_exprContext { return s.where }

func (s *Update_statementContext) SetTable_name(v IIdentifierContext) { s.table_name = v }

func (s *Update_statementContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *Update_statementContext) SetWhere(v ISql_exprContext) { s.where = v }

func (s *Update_statementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUPDATE, 0)
}

func (s *Update_statementContext) SET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSET, 0)
}

func (s *Update_statementContext) AllUpdate_set_clause() []IUpdate_set_clauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdate_set_clauseContext); ok {
			len++
		}
	}

	tst := make([]IUpdate_set_clauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdate_set_clauseContext); ok {
			tst[i] = t.(IUpdate_set_clauseContext)
			i++
		}
	}

	return tst
}

func (s *Update_statementContext) Update_set_clause(i int) IUpdate_set_clauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_set_clauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_set_clauseContext)
}

func (s *Update_statementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Update_statementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Update_statementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Update_statementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Update_statementContext) FROM() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFROM, 0)
}

func (s *Update_statementContext) Relation() IRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *Update_statementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserWHERE, 0)
}

func (s *Update_statementContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Update_statementContext) AS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAS, 0)
}

func (s *Update_statementContext) AllJoin() []IJoinContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinContext); ok {
			len++
		}
	}

	tst := make([]IJoinContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinContext); ok {
			tst[i] = t.(IJoinContext)
			i++
		}
	}

	return tst
}

func (s *Update_statementContext) Join(i int) IJoinContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinContext)
}

func (s *Update_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitUpdate_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Update_statement() (localctx IUpdate_statementContext) {
	localctx = NewUpdate_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, KuneiformParserRULE_update_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(790)
		p.Match(KuneiformParserUPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(791)

		var _x = p.Identifier()

		localctx.(*Update_statementContext).table_name = _x
	}
	p.SetState(796)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-33)) & ^0x3f) == 0 && ((int64(1)<<(_la-33))&18049583966447479) != 0) || ((int64((_la-110)) & ^0x3f) == 0 && ((int64(1)<<(_la-110))&34375434749) != 0) {
		p.SetState(793)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserAS {
			{
				p.SetState(792)
				p.Match(KuneiformParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(795)

			var _x = p.Identifier()

			localctx.(*Update_statementContext).alias = _x
		}

	}
	{
		p.SetState(798)
		p.Match(KuneiformParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(799)
		p.Update_set_clause()
	}
	p.SetState(804)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCOMMA {
		{
			p.SetState(800)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(801)
			p.Update_set_clause()
		}

		p.SetState(806)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(815)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserFROM {
		{
			p.SetState(807)
			p.Match(KuneiformParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(808)
			p.Relation()
		}
		p.SetState(812)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-74)) & ^0x3f) == 0 && ((int64(1)<<(_la-74))&134217743) != 0 {
			{
				p.SetState(809)
				p.Join()
			}

			p.SetState(814)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(819)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserWHERE {
		{
			p.SetState(817)
			p.Match(KuneiformParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(818)

			var _x = p.sql_expr(0)

			localctx.(*Update_statementContext).where = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdate_set_clauseContext is an interface to support dynamic dispatch.
type IUpdate_set_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetColumn returns the column rule contexts.
	GetColumn() IIdentifierContext

	// SetColumn sets the column rule contexts.
	SetColumn(IIdentifierContext)

	// Getter signatures
	EQUALS() antlr.TerminalNode
	Sql_expr() ISql_exprContext
	Identifier() IIdentifierContext

	// IsUpdate_set_clauseContext differentiates from other interfaces.
	IsUpdate_set_clauseContext()
}

type Update_set_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	column IIdentifierContext
}

func NewEmptyUpdate_set_clauseContext() *Update_set_clauseContext {
	var p = new(Update_set_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_update_set_clause
	return p
}

func InitEmptyUpdate_set_clauseContext(p *Update_set_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_update_set_clause
}

func (*Update_set_clauseContext) IsUpdate_set_clauseContext() {}

func NewUpdate_set_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_set_clauseContext {
	var p = new(Update_set_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_update_set_clause

	return p
}

func (s *Update_set_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_set_clauseContext) GetColumn() IIdentifierContext { return s.column }

func (s *Update_set_clauseContext) SetColumn(v IIdentifierContext) { s.column = v }

func (s *Update_set_clauseContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEQUALS, 0)
}

func (s *Update_set_clauseContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Update_set_clauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Update_set_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_set_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_set_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitUpdate_set_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Update_set_clause() (localctx IUpdate_set_clauseContext) {
	localctx = NewUpdate_set_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, KuneiformParserRULE_update_set_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(821)

		var _x = p.Identifier()

		localctx.(*Update_set_clauseContext).column = _x
	}
	{
		p.SetState(822)
		p.Match(KuneiformParserEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(823)
		p.sql_expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsert_statementContext is an interface to support dynamic dispatch.
type IInsert_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable_name returns the table_name rule contexts.
	GetTable_name() IIdentifierContext

	// GetAlias returns the alias rule contexts.
	GetAlias() IIdentifierContext

	// GetTarget_columns returns the target_columns rule contexts.
	GetTarget_columns() IIdentifier_listContext

	// SetTable_name sets the table_name rule contexts.
	SetTable_name(IIdentifierContext)

	// SetAlias sets the alias rule contexts.
	SetAlias(IIdentifierContext)

	// SetTarget_columns sets the target_columns rule contexts.
	SetTarget_columns(IIdentifier_listContext)

	// Getter signatures
	INSERT() antlr.TerminalNode
	INTO() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	Upsert_clause() IUpsert_clauseContext
	Identifier_list() IIdentifier_listContext
	VALUES() antlr.TerminalNode
	AllSql_expr_list() []ISql_expr_listContext
	Sql_expr_list(i int) ISql_expr_listContext
	Select_statement() ISelect_statementContext
	AS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsInsert_statementContext differentiates from other interfaces.
	IsInsert_statementContext()
}

type Insert_statementContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	table_name     IIdentifierContext
	alias          IIdentifierContext
	target_columns IIdentifier_listContext
}

func NewEmptyInsert_statementContext() *Insert_statementContext {
	var p = new(Insert_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_insert_statement
	return p
}

func InitEmptyInsert_statementContext(p *Insert_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_insert_statement
}

func (*Insert_statementContext) IsInsert_statementContext() {}

func NewInsert_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_statementContext {
	var p = new(Insert_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_insert_statement

	return p
}

func (s *Insert_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_statementContext) GetTable_name() IIdentifierContext { return s.table_name }

func (s *Insert_statementContext) GetAlias() IIdentifierContext { return s.alias }

func (s *Insert_statementContext) GetTarget_columns() IIdentifier_listContext {
	return s.target_columns
}

func (s *Insert_statementContext) SetTable_name(v IIdentifierContext) { s.table_name = v }

func (s *Insert_statementContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *Insert_statementContext) SetTarget_columns(v IIdentifier_listContext) { s.target_columns = v }

func (s *Insert_statementContext) INSERT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserINSERT, 0)
}

func (s *Insert_statementContext) INTO() antlr.TerminalNode {
	return s.GetToken(KuneiformParserINTO, 0)
}

func (s *Insert_statementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Insert_statementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Insert_statementContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserLPAREN)
}

func (s *Insert_statementContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, i)
}

func (s *Insert_statementContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserRPAREN)
}

func (s *Insert_statementContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, i)
}

func (s *Insert_statementContext) Upsert_clause() IUpsert_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpsert_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpsert_clauseContext)
}

func (s *Insert_statementContext) Identifier_list() IIdentifier_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifier_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Insert_statementContext) VALUES() antlr.TerminalNode {
	return s.GetToken(KuneiformParserVALUES, 0)
}

func (s *Insert_statementContext) AllSql_expr_list() []ISql_expr_listContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_expr_listContext); ok {
			len++
		}
	}

	tst := make([]ISql_expr_listContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_expr_listContext); ok {
			tst[i] = t.(ISql_expr_listContext)
			i++
		}
	}

	return tst
}

func (s *Insert_statementContext) Sql_expr_list(i int) ISql_expr_listContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_expr_listContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_expr_listContext)
}

func (s *Insert_statementContext) Select_statement() ISelect_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *Insert_statementContext) AS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAS, 0)
}

func (s *Insert_statementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Insert_statementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Insert_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Insert_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitInsert_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Insert_statement() (localctx IInsert_statementContext) {
	localctx = NewInsert_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, KuneiformParserRULE_insert_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(825)
		p.Match(KuneiformParserINSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(826)
		p.Match(KuneiformParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(827)

		var _x = p.Identifier()

		localctx.(*Insert_statementContext).table_name = _x
	}
	p.SetState(832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-33)) & ^0x3f) == 0 && ((int64(1)<<(_la-33))&18049583966447479) != 0) || ((int64((_la-110)) & ^0x3f) == 0 && ((int64(1)<<(_la-110))&34375434749) != 0) {
		p.SetState(829)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserAS {
			{
				p.SetState(828)
				p.Match(KuneiformParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(831)

			var _x = p.Identifier()

			localctx.(*Insert_statementContext).alias = _x
		}

	}
	p.SetState(838)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserLPAREN {
		{
			p.SetState(834)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(835)

			var _x = p.Identifier_list()

			localctx.(*Insert_statementContext).target_columns = _x
		}
		{
			p.SetState(836)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(855)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KuneiformParserVALUES:
		{
			p.SetState(840)
			p.Match(KuneiformParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(841)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(842)
			p.Sql_expr_list()
		}
		{
			p.SetState(843)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(851)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KuneiformParserCOMMA {
			{
				p.SetState(844)
				p.Match(KuneiformParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(845)
				p.Match(KuneiformParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(846)
				p.Sql_expr_list()
			}
			{
				p.SetState(847)
				p.Match(KuneiformParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(853)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case KuneiformParserSELECT:
		{
			p.SetState(854)
			p.Select_statement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(858)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserON {
		{
			p.SetState(857)
			p.Upsert_clause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpsert_clauseContext is an interface to support dynamic dispatch.
type IUpsert_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConflict_columns returns the conflict_columns rule contexts.
	GetConflict_columns() IIdentifier_listContext

	// GetConflict_where returns the conflict_where rule contexts.
	GetConflict_where() ISql_exprContext

	// GetUpdate_where returns the update_where rule contexts.
	GetUpdate_where() ISql_exprContext

	// SetConflict_columns sets the conflict_columns rule contexts.
	SetConflict_columns(IIdentifier_listContext)

	// SetConflict_where sets the conflict_where rule contexts.
	SetConflict_where(ISql_exprContext)

	// SetUpdate_where sets the update_where rule contexts.
	SetUpdate_where(ISql_exprContext)

	// Getter signatures
	ON() antlr.TerminalNode
	CONFLICT() antlr.TerminalNode
	DO() antlr.TerminalNode
	NOTHING() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	SET() antlr.TerminalNode
	AllUpdate_set_clause() []IUpdate_set_clauseContext
	Update_set_clause(i int) IUpdate_set_clauseContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Identifier_list() IIdentifier_listContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllWHERE() []antlr.TerminalNode
	WHERE(i int) antlr.TerminalNode
	AllSql_expr() []ISql_exprContext
	Sql_expr(i int) ISql_exprContext

	// IsUpsert_clauseContext differentiates from other interfaces.
	IsUpsert_clauseContext()
}

type Upsert_clauseContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	conflict_columns IIdentifier_listContext
	conflict_where   ISql_exprContext
	update_where     ISql_exprContext
}

func NewEmptyUpsert_clauseContext() *Upsert_clauseContext {
	var p = new(Upsert_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_upsert_clause
	return p
}

func InitEmptyUpsert_clauseContext(p *Upsert_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_upsert_clause
}

func (*Upsert_clauseContext) IsUpsert_clauseContext() {}

func NewUpsert_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Upsert_clauseContext {
	var p = new(Upsert_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_upsert_clause

	return p
}

func (s *Upsert_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Upsert_clauseContext) GetConflict_columns() IIdentifier_listContext {
	return s.conflict_columns
}

func (s *Upsert_clauseContext) GetConflict_where() ISql_exprContext { return s.conflict_where }

func (s *Upsert_clauseContext) GetUpdate_where() ISql_exprContext { return s.update_where }

func (s *Upsert_clauseContext) SetConflict_columns(v IIdentifier_listContext) { s.conflict_columns = v }

func (s *Upsert_clauseContext) SetConflict_where(v ISql_exprContext) { s.conflict_where = v }

func (s *Upsert_clauseContext) SetUpdate_where(v ISql_exprContext) { s.update_where = v }

func (s *Upsert_clauseContext) ON() antlr.TerminalNode {
	return s.GetToken(KuneiformParserON, 0)
}

func (s *Upsert_clauseContext) CONFLICT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCONFLICT, 0)
}

func (s *Upsert_clauseContext) DO() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDO, 0)
}

func (s *Upsert_clauseContext) NOTHING() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOTHING, 0)
}

func (s *Upsert_clauseContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUPDATE, 0)
}

func (s *Upsert_clauseContext) SET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSET, 0)
}

func (s *Upsert_clauseContext) AllUpdate_set_clause() []IUpdate_set_clauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdate_set_clauseContext); ok {
			len++
		}
	}

	tst := make([]IUpdate_set_clauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdate_set_clauseContext); ok {
			tst[i] = t.(IUpdate_set_clauseContext)
			i++
		}
	}

	return tst
}

func (s *Upsert_clauseContext) Update_set_clause(i int) IUpdate_set_clauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_set_clauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_set_clauseContext)
}

func (s *Upsert_clauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Upsert_clauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Upsert_clauseContext) Identifier_list() IIdentifier_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifier_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Upsert_clauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Upsert_clauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Upsert_clauseContext) AllWHERE() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserWHERE)
}

func (s *Upsert_clauseContext) WHERE(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserWHERE, i)
}

func (s *Upsert_clauseContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Upsert_clauseContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Upsert_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Upsert_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Upsert_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitUpsert_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Upsert_clause() (localctx IUpsert_clauseContext) {
	localctx = NewUpsert_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, KuneiformParserRULE_upsert_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(860)
		p.Match(KuneiformParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(861)
		p.Match(KuneiformParserCONFLICT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(869)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserLPAREN {
		{
			p.SetState(862)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(863)

			var _x = p.Identifier_list()

			localctx.(*Upsert_clauseContext).conflict_columns = _x
		}
		{
			p.SetState(864)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(867)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserWHERE {
			{
				p.SetState(865)
				p.Match(KuneiformParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(866)

				var _x = p.sql_expr(0)

				localctx.(*Upsert_clauseContext).conflict_where = _x
			}

		}

	}
	{
		p.SetState(871)
		p.Match(KuneiformParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(887)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KuneiformParserNOTHING:
		{
			p.SetState(872)
			p.Match(KuneiformParserNOTHING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KuneiformParserUPDATE:
		{
			p.SetState(873)
			p.Match(KuneiformParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(874)
			p.Match(KuneiformParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(875)
			p.Update_set_clause()
		}
		p.SetState(880)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KuneiformParserCOMMA {
			{
				p.SetState(876)
				p.Match(KuneiformParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(877)
				p.Update_set_clause()
			}

			p.SetState(882)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(885)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserWHERE {
			{
				p.SetState(883)
				p.Match(KuneiformParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(884)

				var _x = p.sql_expr(0)

				localctx.(*Upsert_clauseContext).update_where = _x
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelete_statementContext is an interface to support dynamic dispatch.
type IDelete_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable_name returns the table_name rule contexts.
	GetTable_name() IIdentifierContext

	// GetAlias returns the alias rule contexts.
	GetAlias() IIdentifierContext

	// GetWhere returns the where rule contexts.
	GetWhere() ISql_exprContext

	// SetTable_name sets the table_name rule contexts.
	SetTable_name(IIdentifierContext)

	// SetAlias sets the alias rule contexts.
	SetAlias(IIdentifierContext)

	// SetWhere sets the where rule contexts.
	SetWhere(ISql_exprContext)

	// Getter signatures
	DELETE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	WHERE() antlr.TerminalNode
	Sql_expr() ISql_exprContext
	AS() antlr.TerminalNode

	// IsDelete_statementContext differentiates from other interfaces.
	IsDelete_statementContext()
}

type Delete_statementContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	table_name IIdentifierContext
	alias      IIdentifierContext
	where      ISql_exprContext
}

func NewEmptyDelete_statementContext() *Delete_statementContext {
	var p = new(Delete_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_delete_statement
	return p
}

func InitEmptyDelete_statementContext(p *Delete_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_delete_statement
}

func (*Delete_statementContext) IsDelete_statementContext() {}

func NewDelete_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delete_statementContext {
	var p = new(Delete_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_delete_statement

	return p
}

func (s *Delete_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Delete_statementContext) GetTable_name() IIdentifierContext { return s.table_name }

func (s *Delete_statementContext) GetAlias() IIdentifierContext { return s.alias }

func (s *Delete_statementContext) GetWhere() ISql_exprContext { return s.where }

func (s *Delete_statementContext) SetTable_name(v IIdentifierContext) { s.table_name = v }

func (s *Delete_statementContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *Delete_statementContext) SetWhere(v ISql_exprContext) { s.where = v }

func (s *Delete_statementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDELETE, 0)
}

func (s *Delete_statementContext) FROM() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFROM, 0)
}

func (s *Delete_statementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Delete_statementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Delete_statementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserWHERE, 0)
}

func (s *Delete_statementContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Delete_statementContext) AS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAS, 0)
}

func (s *Delete_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delete_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitDelete_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Delete_statement() (localctx IDelete_statementContext) {
	localctx = NewDelete_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, KuneiformParserRULE_delete_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(889)
		p.Match(KuneiformParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(890)
		p.Match(KuneiformParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(891)

		var _x = p.Identifier()

		localctx.(*Delete_statementContext).table_name = _x
	}
	p.SetState(896)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-33)) & ^0x3f) == 0 && ((int64(1)<<(_la-33))&18049583966447479) != 0) || ((int64((_la-110)) & ^0x3f) == 0 && ((int64(1)<<(_la-110))&34375434749) != 0) {
		p.SetState(893)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserAS {
			{
				p.SetState(892)
				p.Match(KuneiformParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(895)

			var _x = p.Identifier()

			localctx.(*Delete_statementContext).alias = _x
		}

	}
	p.SetState(900)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserWHERE {
		{
			p.SetState(898)
			p.Match(KuneiformParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(899)

			var _x = p.sql_expr(0)

			localctx.(*Delete_statementContext).where = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISql_exprContext is an interface to support dynamic dispatch.
type ISql_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSql_exprContext differentiates from other interfaces.
	IsSql_exprContext()
}

type Sql_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_exprContext() *Sql_exprContext {
	var p = new(Sql_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_sql_expr
	return p
}

func InitEmptySql_exprContext(p *Sql_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_sql_expr
}

func (*Sql_exprContext) IsSql_exprContext() {}

func NewSql_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_exprContext {
	var p = new(Sql_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_sql_expr

	return p
}

func (s *Sql_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_exprContext) CopyAll(ctx *Sql_exprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *Sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Column_sql_exprContext struct {
	Sql_exprContext
	table  IIdentifierContext
	column IIdentifierContext
}

func NewColumn_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Column_sql_exprContext {
	var p = new(Column_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Column_sql_exprContext) GetTable() IIdentifierContext { return s.table }

func (s *Column_sql_exprContext) GetColumn() IIdentifierContext { return s.column }

func (s *Column_sql_exprContext) SetTable(v IIdentifierContext) { s.table = v }

func (s *Column_sql_exprContext) SetColumn(v IIdentifierContext) { s.column = v }

func (s *Column_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_sql_exprContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Column_sql_exprContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Column_sql_exprContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPERIOD, 0)
}

func (s *Column_sql_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Column_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitColumn_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Logical_sql_exprContext struct {
	Sql_exprContext
	left  ISql_exprContext
	right ISql_exprContext
}

func NewLogical_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Logical_sql_exprContext {
	var p = new(Logical_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Logical_sql_exprContext) GetLeft() ISql_exprContext { return s.left }

func (s *Logical_sql_exprContext) GetRight() ISql_exprContext { return s.right }

func (s *Logical_sql_exprContext) SetLeft(v ISql_exprContext) { s.left = v }

func (s *Logical_sql_exprContext) SetRight(v ISql_exprContext) { s.right = v }

func (s *Logical_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_sql_exprContext) AND() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAND, 0)
}

func (s *Logical_sql_exprContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Logical_sql_exprContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Logical_sql_exprContext) OR() antlr.TerminalNode {
	return s.GetToken(KuneiformParserOR, 0)
}

func (s *Logical_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitLogical_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Field_access_sql_exprContext struct {
	Sql_exprContext
}

func NewField_access_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Field_access_sql_exprContext {
	var p = new(Field_access_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Field_access_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_access_sql_exprContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Field_access_sql_exprContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPERIOD, 0)
}

func (s *Field_access_sql_exprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Field_access_sql_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Field_access_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitField_access_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Array_access_sql_exprContext struct {
	Sql_exprContext
	array_element ISql_exprContext
	single        ISql_exprContext
	left          ISql_exprContext
	right         ISql_exprContext
}

func NewArray_access_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Array_access_sql_exprContext {
	var p = new(Array_access_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Array_access_sql_exprContext) GetArray_element() ISql_exprContext { return s.array_element }

func (s *Array_access_sql_exprContext) GetSingle() ISql_exprContext { return s.single }

func (s *Array_access_sql_exprContext) GetLeft() ISql_exprContext { return s.left }

func (s *Array_access_sql_exprContext) GetRight() ISql_exprContext { return s.right }

func (s *Array_access_sql_exprContext) SetArray_element(v ISql_exprContext) { s.array_element = v }

func (s *Array_access_sql_exprContext) SetSingle(v ISql_exprContext) { s.single = v }

func (s *Array_access_sql_exprContext) SetLeft(v ISql_exprContext) { s.left = v }

func (s *Array_access_sql_exprContext) SetRight(v ISql_exprContext) { s.right = v }

func (s *Array_access_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_access_sql_exprContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACKET, 0)
}

func (s *Array_access_sql_exprContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACKET, 0)
}

func (s *Array_access_sql_exprContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Array_access_sql_exprContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Array_access_sql_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Array_access_sql_exprContext) COL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOL, 0)
}

func (s *Array_access_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitArray_access_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Comparison_sql_exprContext struct {
	Sql_exprContext
	left  ISql_exprContext
	right ISql_exprContext
}

func NewComparison_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Comparison_sql_exprContext {
	var p = new(Comparison_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Comparison_sql_exprContext) GetLeft() ISql_exprContext { return s.left }

func (s *Comparison_sql_exprContext) GetRight() ISql_exprContext { return s.right }

func (s *Comparison_sql_exprContext) SetLeft(v ISql_exprContext) { s.left = v }

func (s *Comparison_sql_exprContext) SetRight(v ISql_exprContext) { s.right = v }

func (s *Comparison_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comparison_sql_exprContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Comparison_sql_exprContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Comparison_sql_exprContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEQUALS, 0)
}

func (s *Comparison_sql_exprContext) EQUATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEQUATE, 0)
}

func (s *Comparison_sql_exprContext) NEQ() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNEQ, 0)
}

func (s *Comparison_sql_exprContext) LT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLT, 0)
}

func (s *Comparison_sql_exprContext) LTE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLTE, 0)
}

func (s *Comparison_sql_exprContext) GT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserGT, 0)
}

func (s *Comparison_sql_exprContext) GTE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserGTE, 0)
}

func (s *Comparison_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitComparison_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Literal_sql_exprContext struct {
	Sql_exprContext
}

func NewLiteral_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Literal_sql_exprContext {
	var p = new(Literal_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Literal_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Literal_sql_exprContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *Literal_sql_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Literal_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitLiteral_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Between_sql_exprContext struct {
	Sql_exprContext
	element ISql_exprContext
	lower   ISql_exprContext
	upper   ISql_exprContext
}

func NewBetween_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Between_sql_exprContext {
	var p = new(Between_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Between_sql_exprContext) GetElement() ISql_exprContext { return s.element }

func (s *Between_sql_exprContext) GetLower() ISql_exprContext { return s.lower }

func (s *Between_sql_exprContext) GetUpper() ISql_exprContext { return s.upper }

func (s *Between_sql_exprContext) SetElement(v ISql_exprContext) { s.element = v }

func (s *Between_sql_exprContext) SetLower(v ISql_exprContext) { s.lower = v }

func (s *Between_sql_exprContext) SetUpper(v ISql_exprContext) { s.upper = v }

func (s *Between_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Between_sql_exprContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserBETWEEN, 0)
}

func (s *Between_sql_exprContext) AND() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAND, 0)
}

func (s *Between_sql_exprContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Between_sql_exprContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Between_sql_exprContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Between_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitBetween_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Function_call_sql_exprContext struct {
	Sql_exprContext
}

func NewFunction_call_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Function_call_sql_exprContext {
	var p = new(Function_call_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Function_call_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_call_sql_exprContext) Sql_function_call() ISql_function_callContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_function_callContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_function_callContext)
}

func (s *Function_call_sql_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Function_call_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitFunction_call_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Paren_sql_exprContext struct {
	Sql_exprContext
}

func NewParen_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Paren_sql_exprContext {
	var p = new(Paren_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Paren_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Paren_sql_exprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Paren_sql_exprContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Paren_sql_exprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Paren_sql_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Paren_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitParen_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Collate_sql_exprContext struct {
	Sql_exprContext
}

func NewCollate_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Collate_sql_exprContext {
	var p = new(Collate_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Collate_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collate_sql_exprContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Collate_sql_exprContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOLLATE, 0)
}

func (s *Collate_sql_exprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Collate_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitCollate_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Make_array_sql_exprContext struct {
	Sql_exprContext
}

func NewMake_array_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Make_array_sql_exprContext {
	var p = new(Make_array_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Make_array_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Make_array_sql_exprContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(KuneiformParserARRAY, 0)
}

func (s *Make_array_sql_exprContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACKET, 0)
}

func (s *Make_array_sql_exprContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACKET, 0)
}

func (s *Make_array_sql_exprContext) Sql_expr_list() ISql_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_expr_listContext)
}

func (s *Make_array_sql_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Make_array_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitMake_array_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Variable_sql_exprContext struct {
	Sql_exprContext
}

func NewVariable_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Variable_sql_exprContext {
	var p = new(Variable_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Variable_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_sql_exprContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Variable_sql_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Variable_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitVariable_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Window_function_call_sql_exprContext struct {
	Sql_exprContext
}

func NewWindow_function_call_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Window_function_call_sql_exprContext {
	var p = new(Window_function_call_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Window_function_call_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_function_call_sql_exprContext) Sql_function_call() ISql_function_callContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_function_callContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_function_callContext)
}

func (s *Window_function_call_sql_exprContext) OVER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserOVER, 0)
}

func (s *Window_function_call_sql_exprContext) Window() IWindowContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowContext)
}

func (s *Window_function_call_sql_exprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Window_function_call_sql_exprContext) FILTER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFILTER, 0)
}

func (s *Window_function_call_sql_exprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Window_function_call_sql_exprContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserWHERE, 0)
}

func (s *Window_function_call_sql_exprContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Window_function_call_sql_exprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Window_function_call_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitWindow_function_call_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Is_sql_exprContext struct {
	Sql_exprContext
	left  ISql_exprContext
	right ISql_exprContext
}

func NewIs_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Is_sql_exprContext {
	var p = new(Is_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Is_sql_exprContext) GetLeft() ISql_exprContext { return s.left }

func (s *Is_sql_exprContext) GetRight() ISql_exprContext { return s.right }

func (s *Is_sql_exprContext) SetLeft(v ISql_exprContext) { s.left = v }

func (s *Is_sql_exprContext) SetRight(v ISql_exprContext) { s.right = v }

func (s *Is_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Is_sql_exprContext) IS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIS, 0)
}

func (s *Is_sql_exprContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Is_sql_exprContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Is_sql_exprContext) NULL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNULL, 0)
}

func (s *Is_sql_exprContext) TRUE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserTRUE, 0)
}

func (s *Is_sql_exprContext) FALSE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFALSE, 0)
}

func (s *Is_sql_exprContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Is_sql_exprContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDISTINCT, 0)
}

func (s *Is_sql_exprContext) FROM() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFROM, 0)
}

func (s *Is_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitIs_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Arithmetic_sql_exprContext struct {
	Sql_exprContext
	left  ISql_exprContext
	right ISql_exprContext
}

func NewArithmetic_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Arithmetic_sql_exprContext {
	var p = new(Arithmetic_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Arithmetic_sql_exprContext) GetLeft() ISql_exprContext { return s.left }

func (s *Arithmetic_sql_exprContext) GetRight() ISql_exprContext { return s.right }

func (s *Arithmetic_sql_exprContext) SetLeft(v ISql_exprContext) { s.left = v }

func (s *Arithmetic_sql_exprContext) SetRight(v ISql_exprContext) { s.right = v }

func (s *Arithmetic_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arithmetic_sql_exprContext) EXP() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEXP, 0)
}

func (s *Arithmetic_sql_exprContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Arithmetic_sql_exprContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Arithmetic_sql_exprContext) STAR() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSTAR, 0)
}

func (s *Arithmetic_sql_exprContext) DIV() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDIV, 0)
}

func (s *Arithmetic_sql_exprContext) MOD() antlr.TerminalNode {
	return s.GetToken(KuneiformParserMOD, 0)
}

func (s *Arithmetic_sql_exprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPLUS, 0)
}

func (s *Arithmetic_sql_exprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserMINUS, 0)
}

func (s *Arithmetic_sql_exprContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCONCAT, 0)
}

func (s *Arithmetic_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitArithmetic_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Like_sql_exprContext struct {
	Sql_exprContext
	left  ISql_exprContext
	right ISql_exprContext
}

func NewLike_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Like_sql_exprContext {
	var p = new(Like_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Like_sql_exprContext) GetLeft() ISql_exprContext { return s.left }

func (s *Like_sql_exprContext) GetRight() ISql_exprContext { return s.right }

func (s *Like_sql_exprContext) SetLeft(v ISql_exprContext) { s.left = v }

func (s *Like_sql_exprContext) SetRight(v ISql_exprContext) { s.right = v }

func (s *Like_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Like_sql_exprContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Like_sql_exprContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Like_sql_exprContext) LIKE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLIKE, 0)
}

func (s *Like_sql_exprContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserILIKE, 0)
}

func (s *Like_sql_exprContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Like_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitLike_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Subquery_sql_exprContext struct {
	Sql_exprContext
}

func NewSubquery_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Subquery_sql_exprContext {
	var p = new(Subquery_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Subquery_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subquery_sql_exprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Subquery_sql_exprContext) Select_statement() ISelect_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *Subquery_sql_exprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Subquery_sql_exprContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEXISTS, 0)
}

func (s *Subquery_sql_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Subquery_sql_exprContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Subquery_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitSubquery_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Unary_sql_exprContext struct {
	Sql_exprContext
}

func NewUnary_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Unary_sql_exprContext {
	var p = new(Unary_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Unary_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_sql_exprContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Unary_sql_exprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPLUS, 0)
}

func (s *Unary_sql_exprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserMINUS, 0)
}

func (s *Unary_sql_exprContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Unary_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitUnary_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Case_exprContext struct {
	Sql_exprContext
	case_clause ISql_exprContext
	else_clause ISql_exprContext
}

func NewCase_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Case_exprContext {
	var p = new(Case_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *Case_exprContext) GetCase_clause() ISql_exprContext { return s.case_clause }

func (s *Case_exprContext) GetElse_clause() ISql_exprContext { return s.else_clause }

func (s *Case_exprContext) SetCase_clause(v ISql_exprContext) { s.case_clause = v }

func (s *Case_exprContext) SetElse_clause(v ISql_exprContext) { s.else_clause = v }

func (s *Case_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_exprContext) CASE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCASE, 0)
}

func (s *Case_exprContext) END() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEND, 0)
}

func (s *Case_exprContext) AllWhen_then_clause() []IWhen_then_clauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhen_then_clauseContext); ok {
			len++
		}
	}

	tst := make([]IWhen_then_clauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhen_then_clauseContext); ok {
			tst[i] = t.(IWhen_then_clauseContext)
			i++
		}
	}

	return tst
}

func (s *Case_exprContext) When_then_clause(i int) IWhen_then_clauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhen_then_clauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhen_then_clauseContext)
}

func (s *Case_exprContext) ELSE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserELSE, 0)
}

func (s *Case_exprContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Case_exprContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Case_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitCase_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type In_sql_exprContext struct {
	Sql_exprContext
}

func NewIn_sql_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *In_sql_exprContext {
	var p = new(In_sql_exprContext)

	InitEmptySql_exprContext(&p.Sql_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_exprContext))

	return p
}

func (s *In_sql_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *In_sql_exprContext) Sql_expr() ISql_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *In_sql_exprContext) IN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIN, 0)
}

func (s *In_sql_exprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *In_sql_exprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *In_sql_exprContext) Sql_expr_list() ISql_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_expr_listContext)
}

func (s *In_sql_exprContext) Select_statement() ISelect_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *In_sql_exprContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *In_sql_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitIn_sql_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Sql_expr() (localctx ISql_exprContext) {
	return p.sql_expr(0)
}

func (p *KuneiformParser) sql_expr(_p int) (localctx ISql_exprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewSql_exprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISql_exprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 100
	p.EnterRecursionRule(localctx, 100, KuneiformParserRULE_sql_expr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(984)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) {
	case 1:
		localctx = NewParen_sql_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(903)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(904)
			p.sql_expr(0)
		}
		{
			p.SetState(905)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(907)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(906)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewUnary_sql_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(909)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KuneiformParserPLUS || _la == KuneiformParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(910)
			p.sql_expr(22)
		}

	case 3:
		localctx = NewLiteral_sql_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(911)
			p.Literal()
		}
		p.SetState(913)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(912)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewWindow_function_call_sql_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(915)
			p.Sql_function_call()
		}
		p.SetState(922)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserFILTER {
			{
				p.SetState(916)
				p.Match(KuneiformParserFILTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(917)
				p.Match(KuneiformParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(918)
				p.Match(KuneiformParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(919)
				p.sql_expr(0)
			}
			{
				p.SetState(920)
				p.Match(KuneiformParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(924)
			p.Match(KuneiformParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(927)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case KuneiformParserLPAREN:
			{
				p.SetState(925)
				p.Window()
			}

		case KuneiformParserDOUBLE_QUOTE, KuneiformParserUSE, KuneiformParserUNUSE, KuneiformParserACTION, KuneiformParserCREATE, KuneiformParserALTER, KuneiformParserADD, KuneiformParserDROP, KuneiformParserRENAME, KuneiformParserCHECK, KuneiformParserFOREIGN, KuneiformParserPRIMARY, KuneiformParserKEY, KuneiformParserUNIQUE, KuneiformParserRESTRICT, KuneiformParserDEFAULT, KuneiformParserINDEX, KuneiformParserRETURNS, KuneiformParserCONFLICT, KuneiformParserFOR, KuneiformParserIF, KuneiformParserELSEIF, KuneiformParserELSE, KuneiformParserBREAK, KuneiformParserCONTINUE, KuneiformParserRETURN, KuneiformParserGRANT, KuneiformParserGRANTED, KuneiformParserREVOKE, KuneiformParserROLE, KuneiformParserREPLACE, KuneiformParserNAMESPACE, KuneiformParserROLES, KuneiformParserCALL, KuneiformParserIDENTIFIER:
			{
				p.SetState(926)
				p.Identifier()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 5:
		localctx = NewFunction_call_sql_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(929)
			p.Sql_function_call()
		}
		p.SetState(931)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(930)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		localctx = NewVariable_sql_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(933)
			p.Variable()
		}
		p.SetState(935)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(934)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		localctx = NewMake_array_sql_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(937)
			p.Match(KuneiformParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(938)
			p.Match(KuneiformParserLBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(940)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4371923291645935488) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&-17734572799623167) != 0) || ((int64((_la-135)) & ^0x3f) == 0 && ((int64(1)<<(_la-135))&7183) != 0) {
			{
				p.SetState(939)
				p.Sql_expr_list()
			}

		}
		{
			p.SetState(942)
			p.Match(KuneiformParserRBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(944)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(943)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 8:
		localctx = NewColumn_sql_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(949)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(946)

				var _x = p.Identifier()

				localctx.(*Column_sql_exprContext).table = _x
			}
			{
				p.SetState(947)
				p.Match(KuneiformParserPERIOD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(951)

			var _x = p.Identifier()

			localctx.(*Column_sql_exprContext).column = _x
		}
		p.SetState(953)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 128, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(952)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 9:
		localctx = NewCase_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(955)
			p.Match(KuneiformParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(957)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4371923291645935488) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&-17734572799623167) != 0) || ((int64((_la-135)) & ^0x3f) == 0 && ((int64(1)<<(_la-135))&7183) != 0) {
			{
				p.SetState(956)

				var _x = p.sql_expr(0)

				localctx.(*Case_exprContext).case_clause = _x
			}

		}
		p.SetState(960)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == KuneiformParserWHEN {
			{
				p.SetState(959)
				p.When_then_clause()
			}

			p.SetState(962)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(966)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserELSE {
			{
				p.SetState(964)
				p.Match(KuneiformParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(965)

				var _x = p.sql_expr(0)

				localctx.(*Case_exprContext).else_clause = _x
			}

		}
		{
			p.SetState(968)
			p.Match(KuneiformParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewSubquery_sql_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(974)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserNOT || _la == KuneiformParserEXISTS {
			p.SetState(971)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == KuneiformParserNOT {
				{
					p.SetState(970)
					p.Match(KuneiformParserNOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(973)
				p.Match(KuneiformParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(976)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(977)
			p.Select_statement()
		}
		{
			p.SetState(978)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(980)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 134, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(979)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 11:
		localctx = NewUnary_sql_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(982)
			p.Match(KuneiformParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(983)
			p.sql_expr(3)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1074)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1072)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmetic_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				localctx.(*Arithmetic_sql_exprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(986)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
					goto errorExit
				}
				{
					p.SetState(987)
					p.Match(KuneiformParserEXP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(988)

					var _x = p.sql_expr(21)

					localctx.(*Arithmetic_sql_exprContext).right = _x
				}

			case 2:
				localctx = NewArithmetic_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				localctx.(*Arithmetic_sql_exprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(989)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
					goto errorExit
				}
				{
					p.SetState(990)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4734976) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(991)

					var _x = p.sql_expr(20)

					localctx.(*Arithmetic_sql_exprContext).right = _x
				}

			case 3:
				localctx = NewArithmetic_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				localctx.(*Arithmetic_sql_exprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(992)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
					goto errorExit
				}
				{
					p.SetState(993)
					_la = p.GetTokenStream().LA(1)

					if !(_la == KuneiformParserPLUS || _la == KuneiformParserMINUS) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(994)

					var _x = p.sql_expr(19)

					localctx.(*Arithmetic_sql_exprContext).right = _x
				}

			case 4:
				localctx = NewArithmetic_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				localctx.(*Arithmetic_sql_exprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(995)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				{
					p.SetState(996)
					p.Match(KuneiformParserCONCAT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(997)

					var _x = p.sql_expr(10)

					localctx.(*Arithmetic_sql_exprContext).right = _x
				}

			case 5:
				localctx = NewLike_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				localctx.(*Like_sql_exprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(998)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				p.SetState(1000)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == KuneiformParserNOT {
					{
						p.SetState(999)
						p.Match(KuneiformParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(1002)
					_la = p.GetTokenStream().LA(1)

					if !(_la == KuneiformParserLIKE || _la == KuneiformParserILIKE) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1003)

					var _x = p.sql_expr(8)

					localctx.(*Like_sql_exprContext).right = _x
				}

			case 6:
				localctx = NewBetween_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				localctx.(*Between_sql_exprContext).element = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(1004)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				p.SetState(1006)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == KuneiformParserNOT {
					{
						p.SetState(1005)
						p.Match(KuneiformParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(1008)
					p.Match(KuneiformParserBETWEEN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1009)

					var _x = p.sql_expr(0)

					localctx.(*Between_sql_exprContext).lower = _x
				}
				{
					p.SetState(1010)
					p.Match(KuneiformParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1011)

					var _x = p.sql_expr(7)

					localctx.(*Between_sql_exprContext).upper = _x
				}

			case 7:
				localctx = NewComparison_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				localctx.(*Comparison_sql_exprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(1013)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(1014)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&520192000) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1015)

					var _x = p.sql_expr(6)

					localctx.(*Comparison_sql_exprContext).right = _x
				}

			case 8:
				localctx = NewLogical_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				localctx.(*Logical_sql_exprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(1016)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(1017)
					p.Match(KuneiformParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1018)

					var _x = p.sql_expr(3)

					localctx.(*Logical_sql_exprContext).right = _x
				}

			case 9:
				localctx = NewLogical_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				localctx.(*Logical_sql_exprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(1019)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(1020)
					p.Match(KuneiformParserOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1021)

					var _x = p.sql_expr(2)

					localctx.(*Logical_sql_exprContext).right = _x
				}

			case 10:
				localctx = NewField_access_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(1022)

				if !(p.Precpred(p.GetParserRuleContext(), 24)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 24)", ""))
					goto errorExit
				}
				{
					p.SetState(1023)
					p.Match(KuneiformParserPERIOD)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1024)
					p.Identifier()
				}
				p.SetState(1026)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 138, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(1025)
						p.Type_cast()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case 11:
				localctx = NewArray_access_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				localctx.(*Array_access_sql_exprContext).array_element = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(1028)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
					goto errorExit
				}
				{
					p.SetState(1029)
					p.Match(KuneiformParserLBRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1038)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(1030)

						var _x = p.sql_expr(0)

						localctx.(*Array_access_sql_exprContext).single = _x
					}

				case 2:
					p.SetState(1032)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4371923291645935488) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&-17734572799623167) != 0) || ((int64((_la-135)) & ^0x3f) == 0 && ((int64(1)<<(_la-135))&7183) != 0) {
						{
							p.SetState(1031)

							var _x = p.sql_expr(0)

							localctx.(*Array_access_sql_exprContext).left = _x
						}

					}
					{
						p.SetState(1034)
						p.Match(KuneiformParserCOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					p.SetState(1036)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4371923291645935488) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&-17734572799623167) != 0) || ((int64((_la-135)) & ^0x3f) == 0 && ((int64(1)<<(_la-135))&7183) != 0) {
						{
							p.SetState(1035)

							var _x = p.sql_expr(0)

							localctx.(*Array_access_sql_exprContext).right = _x
						}

					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}
				{
					p.SetState(1040)
					p.Match(KuneiformParserRBRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1042)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(1041)
						p.Type_cast()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case 12:
				localctx = NewCollate_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(1044)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
					goto errorExit
				}
				{
					p.SetState(1045)
					p.Match(KuneiformParserCOLLATE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1046)
					p.Identifier()
				}

			case 13:
				localctx = NewIn_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(1047)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				p.SetState(1049)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == KuneiformParserNOT {
					{
						p.SetState(1048)
						p.Match(KuneiformParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(1051)
					p.Match(KuneiformParserIN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1052)
					p.Match(KuneiformParserLPAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1055)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case KuneiformParserLPAREN, KuneiformParserPLUS, KuneiformParserMINUS, KuneiformParserDOUBLE_QUOTE, KuneiformParserUSE, KuneiformParserUNUSE, KuneiformParserACTION, KuneiformParserCREATE, KuneiformParserALTER, KuneiformParserADD, KuneiformParserDROP, KuneiformParserRENAME, KuneiformParserCHECK, KuneiformParserFOREIGN, KuneiformParserPRIMARY, KuneiformParserKEY, KuneiformParserUNIQUE, KuneiformParserRESTRICT, KuneiformParserDEFAULT, KuneiformParserNULL, KuneiformParserNOT, KuneiformParserINDEX, KuneiformParserEXISTS, KuneiformParserRETURNS, KuneiformParserCASE, KuneiformParserCONFLICT, KuneiformParserFOR, KuneiformParserIF, KuneiformParserELSEIF, KuneiformParserELSE, KuneiformParserBREAK, KuneiformParserCONTINUE, KuneiformParserRETURN, KuneiformParserGRANT, KuneiformParserGRANTED, KuneiformParserREVOKE, KuneiformParserROLE, KuneiformParserREPLACE, KuneiformParserARRAY, KuneiformParserNAMESPACE, KuneiformParserROLES, KuneiformParserCALL, KuneiformParserSTRING_, KuneiformParserTRUE, KuneiformParserFALSE, KuneiformParserDIGITS_, KuneiformParserBINARY_, KuneiformParserIDENTIFIER, KuneiformParserVARIABLE, KuneiformParserCONTEXTUAL_VARIABLE:
					{
						p.SetState(1053)
						p.Sql_expr_list()
					}

				case KuneiformParserSELECT:
					{
						p.SetState(1054)
						p.Select_statement()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}
				{
					p.SetState(1057)
					p.Match(KuneiformParserRPAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 14:
				localctx = NewIs_sql_exprContext(p, NewSql_exprContext(p, _parentctx, _parentState))
				localctx.(*Is_sql_exprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_sql_expr)
				p.SetState(1059)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(1060)
					p.Match(KuneiformParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1062)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == KuneiformParserNOT {
					{
						p.SetState(1061)
						p.Match(KuneiformParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(1070)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case KuneiformParserDISTINCT:
					{
						p.SetState(1064)
						p.Match(KuneiformParserDISTINCT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1065)
						p.Match(KuneiformParserFROM)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1066)

						var _x = p.sql_expr(0)

						localctx.(*Is_sql_exprContext).right = _x
					}

				case KuneiformParserNULL:
					{
						p.SetState(1067)
						p.Match(KuneiformParserNULL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case KuneiformParserTRUE:
					{
						p.SetState(1068)
						p.Match(KuneiformParserTRUE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case KuneiformParserFALSE:
					{
						p.SetState(1069)
						p.Match(KuneiformParserFALSE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1076)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowContext is an interface to support dynamic dispatch.
type IWindowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartition returns the partition rule contexts.
	GetPartition() ISql_expr_listContext

	// SetPartition sets the partition rule contexts.
	SetPartition(ISql_expr_listContext)

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	ORDER() antlr.TerminalNode
	AllOrdering_term() []IOrdering_termContext
	Ordering_term(i int) IOrdering_termContext
	Sql_expr_list() ISql_expr_listContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWindowContext differentiates from other interfaces.
	IsWindowContext()
}

type WindowContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	partition ISql_expr_listContext
}

func NewEmptyWindowContext() *WindowContext {
	var p = new(WindowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_window
	return p
}

func InitEmptyWindowContext(p *WindowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_window
}

func (*WindowContext) IsWindowContext() {}

func NewWindowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowContext {
	var p = new(WindowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_window

	return p
}

func (s *WindowContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowContext) GetPartition() ISql_expr_listContext { return s.partition }

func (s *WindowContext) SetPartition(v ISql_expr_listContext) { s.partition = v }

func (s *WindowContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *WindowContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *WindowContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPARTITION, 0)
}

func (s *WindowContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserBY)
}

func (s *WindowContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserBY, i)
}

func (s *WindowContext) ORDER() antlr.TerminalNode {
	return s.GetToken(KuneiformParserORDER, 0)
}

func (s *WindowContext) AllOrdering_term() []IOrdering_termContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrdering_termContext); ok {
			len++
		}
	}

	tst := make([]IOrdering_termContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrdering_termContext); ok {
			tst[i] = t.(IOrdering_termContext)
			i++
		}
	}

	return tst
}

func (s *WindowContext) Ordering_term(i int) IOrdering_termContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrdering_termContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrdering_termContext)
}

func (s *WindowContext) Sql_expr_list() ISql_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_expr_listContext)
}

func (s *WindowContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *WindowContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *WindowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitWindow(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Window() (localctx IWindowContext) {
	localctx = NewWindowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, KuneiformParserRULE_window)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1077)
		p.Match(KuneiformParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1081)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserPARTITION {
		{
			p.SetState(1078)
			p.Match(KuneiformParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1079)
			p.Match(KuneiformParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1080)

			var _x = p.Sql_expr_list()

			localctx.(*WindowContext).partition = _x
		}

	}
	p.SetState(1093)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KuneiformParserORDER {
		{
			p.SetState(1083)
			p.Match(KuneiformParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1084)
			p.Match(KuneiformParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1085)
			p.Ordering_term()
		}
		p.SetState(1090)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KuneiformParserCOMMA {
			{
				p.SetState(1086)
				p.Match(KuneiformParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1087)
				p.Ordering_term()
			}

			p.SetState(1092)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1095)
		p.Match(KuneiformParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhen_then_clauseContext is an interface to support dynamic dispatch.
type IWhen_then_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhen_condition returns the when_condition rule contexts.
	GetWhen_condition() ISql_exprContext

	// GetThen returns the then rule contexts.
	GetThen() ISql_exprContext

	// SetWhen_condition sets the when_condition rule contexts.
	SetWhen_condition(ISql_exprContext)

	// SetThen sets the then rule contexts.
	SetThen(ISql_exprContext)

	// Getter signatures
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	AllSql_expr() []ISql_exprContext
	Sql_expr(i int) ISql_exprContext

	// IsWhen_then_clauseContext differentiates from other interfaces.
	IsWhen_then_clauseContext()
}

type When_then_clauseContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	when_condition ISql_exprContext
	then           ISql_exprContext
}

func NewEmptyWhen_then_clauseContext() *When_then_clauseContext {
	var p = new(When_then_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_when_then_clause
	return p
}

func InitEmptyWhen_then_clauseContext(p *When_then_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_when_then_clause
}

func (*When_then_clauseContext) IsWhen_then_clauseContext() {}

func NewWhen_then_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *When_then_clauseContext {
	var p = new(When_then_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_when_then_clause

	return p
}

func (s *When_then_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *When_then_clauseContext) GetWhen_condition() ISql_exprContext { return s.when_condition }

func (s *When_then_clauseContext) GetThen() ISql_exprContext { return s.then }

func (s *When_then_clauseContext) SetWhen_condition(v ISql_exprContext) { s.when_condition = v }

func (s *When_then_clauseContext) SetThen(v ISql_exprContext) { s.then = v }

func (s *When_then_clauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserWHEN, 0)
}

func (s *When_then_clauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserTHEN, 0)
}

func (s *When_then_clauseContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *When_then_clauseContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *When_then_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *When_then_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *When_then_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitWhen_then_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) When_then_clause() (localctx IWhen_then_clauseContext) {
	localctx = NewWhen_then_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, KuneiformParserRULE_when_then_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1097)
		p.Match(KuneiformParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1098)

		var _x = p.sql_expr(0)

		localctx.(*When_then_clauseContext).when_condition = _x
	}
	{
		p.SetState(1099)
		p.Match(KuneiformParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1100)

		var _x = p.sql_expr(0)

		localctx.(*When_then_clauseContext).then = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISql_expr_listContext is an interface to support dynamic dispatch.
type ISql_expr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSql_expr() []ISql_exprContext
	Sql_expr(i int) ISql_exprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSql_expr_listContext differentiates from other interfaces.
	IsSql_expr_listContext()
}

type Sql_expr_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_expr_listContext() *Sql_expr_listContext {
	var p = new(Sql_expr_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_sql_expr_list
	return p
}

func InitEmptySql_expr_listContext(p *Sql_expr_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_sql_expr_list
}

func (*Sql_expr_listContext) IsSql_expr_listContext() {}

func NewSql_expr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_expr_listContext {
	var p = new(Sql_expr_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_sql_expr_list

	return p
}

func (s *Sql_expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_expr_listContext) AllSql_expr() []ISql_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISql_exprContext); ok {
			len++
		}
	}

	tst := make([]ISql_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISql_exprContext); ok {
			tst[i] = t.(ISql_exprContext)
			i++
		}
	}

	return tst
}

func (s *Sql_expr_listContext) Sql_expr(i int) ISql_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_exprContext)
}

func (s *Sql_expr_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Sql_expr_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Sql_expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sql_expr_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitSql_expr_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Sql_expr_list() (localctx ISql_expr_listContext) {
	localctx = NewSql_expr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, KuneiformParserRULE_sql_expr_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1102)
		p.sql_expr(0)
	}
	p.SetState(1107)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCOMMA {
		{
			p.SetState(1103)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1104)
			p.sql_expr(0)
		}

		p.SetState(1109)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISql_function_callContext is an interface to support dynamic dispatch.
type ISql_function_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSql_function_callContext differentiates from other interfaces.
	IsSql_function_callContext()
}

type Sql_function_callContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_function_callContext() *Sql_function_callContext {
	var p = new(Sql_function_callContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_sql_function_call
	return p
}

func InitEmptySql_function_callContext(p *Sql_function_callContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_sql_function_call
}

func (*Sql_function_callContext) IsSql_function_callContext() {}

func NewSql_function_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_function_callContext {
	var p = new(Sql_function_callContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_sql_function_call

	return p
}

func (s *Sql_function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_function_callContext) CopyAll(ctx *Sql_function_callContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *Sql_function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Normal_call_sqlContext struct {
	Sql_function_callContext
}

func NewNormal_call_sqlContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Normal_call_sqlContext {
	var p = new(Normal_call_sqlContext)

	InitEmptySql_function_callContext(&p.Sql_function_callContext)
	p.parser = parser
	p.CopyAll(ctx.(*Sql_function_callContext))

	return p
}

func (s *Normal_call_sqlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Normal_call_sqlContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Normal_call_sqlContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Normal_call_sqlContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Normal_call_sqlContext) Sql_expr_list() ISql_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_expr_listContext)
}

func (s *Normal_call_sqlContext) STAR() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSTAR, 0)
}

func (s *Normal_call_sqlContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDISTINCT, 0)
}

func (s *Normal_call_sqlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitNormal_call_sql(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Sql_function_call() (localctx ISql_function_callContext) {
	localctx = NewSql_function_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, KuneiformParserRULE_sql_function_call)
	var _la int

	localctx = NewNormal_call_sqlContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1110)
		p.Identifier()
	}
	{
		p.SetState(1111)
		p.Match(KuneiformParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1117)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case KuneiformParserLPAREN, KuneiformParserPLUS, KuneiformParserMINUS, KuneiformParserDOUBLE_QUOTE, KuneiformParserUSE, KuneiformParserUNUSE, KuneiformParserACTION, KuneiformParserCREATE, KuneiformParserALTER, KuneiformParserADD, KuneiformParserDROP, KuneiformParserRENAME, KuneiformParserCHECK, KuneiformParserFOREIGN, KuneiformParserPRIMARY, KuneiformParserKEY, KuneiformParserUNIQUE, KuneiformParserRESTRICT, KuneiformParserDEFAULT, KuneiformParserNULL, KuneiformParserNOT, KuneiformParserINDEX, KuneiformParserEXISTS, KuneiformParserRETURNS, KuneiformParserCASE, KuneiformParserDISTINCT, KuneiformParserCONFLICT, KuneiformParserFOR, KuneiformParserIF, KuneiformParserELSEIF, KuneiformParserELSE, KuneiformParserBREAK, KuneiformParserCONTINUE, KuneiformParserRETURN, KuneiformParserGRANT, KuneiformParserGRANTED, KuneiformParserREVOKE, KuneiformParserROLE, KuneiformParserREPLACE, KuneiformParserARRAY, KuneiformParserNAMESPACE, KuneiformParserROLES, KuneiformParserCALL, KuneiformParserSTRING_, KuneiformParserTRUE, KuneiformParserFALSE, KuneiformParserDIGITS_, KuneiformParserBINARY_, KuneiformParserIDENTIFIER, KuneiformParserVARIABLE, KuneiformParserCONTEXTUAL_VARIABLE:
		p.SetState(1113)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserDISTINCT {
			{
				p.SetState(1112)
				p.Match(KuneiformParserDISTINCT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1115)
			p.Sql_expr_list()
		}

	case KuneiformParserSTAR:
		{
			p.SetState(1116)
			p.Match(KuneiformParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KuneiformParserRPAREN:

	default:
	}
	{
		p.SetState(1119)
		p.Match(KuneiformParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAction_exprContext is an interface to support dynamic dispatch.
type IAction_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAction_exprContext differentiates from other interfaces.
	IsAction_exprContext()
}

type Action_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAction_exprContext() *Action_exprContext {
	var p = new(Action_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_action_expr
	return p
}

func InitEmptyAction_exprContext(p *Action_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_action_expr
}

func (*Action_exprContext) IsAction_exprContext() {}

func NewAction_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Action_exprContext {
	var p = new(Action_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_action_expr

	return p
}

func (s *Action_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Action_exprContext) CopyAll(ctx *Action_exprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *Action_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Action_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Function_call_action_exprContext struct {
	Action_exprContext
}

func NewFunction_call_action_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Function_call_action_exprContext {
	var p = new(Function_call_action_exprContext)

	InitEmptyAction_exprContext(&p.Action_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_exprContext))

	return p
}

func (s *Function_call_action_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_call_action_exprContext) Action_function_call() IAction_function_callContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_function_callContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_function_callContext)
}

func (s *Function_call_action_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Function_call_action_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitFunction_call_action_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Literal_action_exprContext struct {
	Action_exprContext
}

func NewLiteral_action_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Literal_action_exprContext {
	var p = new(Literal_action_exprContext)

	InitEmptyAction_exprContext(&p.Action_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_exprContext))

	return p
}

func (s *Literal_action_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Literal_action_exprContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *Literal_action_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Literal_action_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitLiteral_action_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Field_access_action_exprContext struct {
	Action_exprContext
}

func NewField_access_action_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Field_access_action_exprContext {
	var p = new(Field_access_action_exprContext)

	InitEmptyAction_exprContext(&p.Action_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_exprContext))

	return p
}

func (s *Field_access_action_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_access_action_exprContext) Action_expr() IAction_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_exprContext)
}

func (s *Field_access_action_exprContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPERIOD, 0)
}

func (s *Field_access_action_exprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Field_access_action_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Field_access_action_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitField_access_action_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Is_action_exprContext struct {
	Action_exprContext
	left  IAction_exprContext
	right IAction_exprContext
}

func NewIs_action_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Is_action_exprContext {
	var p = new(Is_action_exprContext)

	InitEmptyAction_exprContext(&p.Action_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_exprContext))

	return p
}

func (s *Is_action_exprContext) GetLeft() IAction_exprContext { return s.left }

func (s *Is_action_exprContext) GetRight() IAction_exprContext { return s.right }

func (s *Is_action_exprContext) SetLeft(v IAction_exprContext) { s.left = v }

func (s *Is_action_exprContext) SetRight(v IAction_exprContext) { s.right = v }

func (s *Is_action_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Is_action_exprContext) IS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIS, 0)
}

func (s *Is_action_exprContext) AllAction_expr() []IAction_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAction_exprContext); ok {
			len++
		}
	}

	tst := make([]IAction_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAction_exprContext); ok {
			tst[i] = t.(IAction_exprContext)
			i++
		}
	}

	return tst
}

func (s *Is_action_exprContext) Action_expr(i int) IAction_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_exprContext)
}

func (s *Is_action_exprContext) NULL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNULL, 0)
}

func (s *Is_action_exprContext) TRUE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserTRUE, 0)
}

func (s *Is_action_exprContext) FALSE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFALSE, 0)
}

func (s *Is_action_exprContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Is_action_exprContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDISTINCT, 0)
}

func (s *Is_action_exprContext) FROM() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFROM, 0)
}

func (s *Is_action_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitIs_action_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Variable_action_exprContext struct {
	Action_exprContext
}

func NewVariable_action_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Variable_action_exprContext {
	var p = new(Variable_action_exprContext)

	InitEmptyAction_exprContext(&p.Action_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_exprContext))

	return p
}

func (s *Variable_action_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_action_exprContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Variable_action_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Variable_action_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitVariable_action_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Make_array_action_exprContext struct {
	Action_exprContext
}

func NewMake_array_action_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Make_array_action_exprContext {
	var p = new(Make_array_action_exprContext)

	InitEmptyAction_exprContext(&p.Action_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_exprContext))

	return p
}

func (s *Make_array_action_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Make_array_action_exprContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACKET, 0)
}

func (s *Make_array_action_exprContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACKET, 0)
}

func (s *Make_array_action_exprContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(KuneiformParserARRAY, 0)
}

func (s *Make_array_action_exprContext) Action_expr_list() IAction_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_expr_listContext)
}

func (s *Make_array_action_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Make_array_action_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitMake_array_action_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Comparison_action_exprContext struct {
	Action_exprContext
}

func NewComparison_action_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Comparison_action_exprContext {
	var p = new(Comparison_action_exprContext)

	InitEmptyAction_exprContext(&p.Action_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_exprContext))

	return p
}

func (s *Comparison_action_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comparison_action_exprContext) AllAction_expr() []IAction_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAction_exprContext); ok {
			len++
		}
	}

	tst := make([]IAction_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAction_exprContext); ok {
			tst[i] = t.(IAction_exprContext)
			i++
		}
	}

	return tst
}

func (s *Comparison_action_exprContext) Action_expr(i int) IAction_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_exprContext)
}

func (s *Comparison_action_exprContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEQUALS, 0)
}

func (s *Comparison_action_exprContext) EQUATE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEQUATE, 0)
}

func (s *Comparison_action_exprContext) NEQ() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNEQ, 0)
}

func (s *Comparison_action_exprContext) LT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLT, 0)
}

func (s *Comparison_action_exprContext) LTE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLTE, 0)
}

func (s *Comparison_action_exprContext) GT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserGT, 0)
}

func (s *Comparison_action_exprContext) GTE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserGTE, 0)
}

func (s *Comparison_action_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitComparison_action_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Action_expr_arithmeticContext struct {
	Action_exprContext
}

func NewAction_expr_arithmeticContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Action_expr_arithmeticContext {
	var p = new(Action_expr_arithmeticContext)

	InitEmptyAction_exprContext(&p.Action_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_exprContext))

	return p
}

func (s *Action_expr_arithmeticContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Action_expr_arithmeticContext) AllAction_expr() []IAction_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAction_exprContext); ok {
			len++
		}
	}

	tst := make([]IAction_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAction_exprContext); ok {
			tst[i] = t.(IAction_exprContext)
			i++
		}
	}

	return tst
}

func (s *Action_expr_arithmeticContext) Action_expr(i int) IAction_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_exprContext)
}

func (s *Action_expr_arithmeticContext) EXP() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEXP, 0)
}

func (s *Action_expr_arithmeticContext) STAR() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSTAR, 0)
}

func (s *Action_expr_arithmeticContext) DIV() antlr.TerminalNode {
	return s.GetToken(KuneiformParserDIV, 0)
}

func (s *Action_expr_arithmeticContext) MOD() antlr.TerminalNode {
	return s.GetToken(KuneiformParserMOD, 0)
}

func (s *Action_expr_arithmeticContext) PLUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPLUS, 0)
}

func (s *Action_expr_arithmeticContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserMINUS, 0)
}

func (s *Action_expr_arithmeticContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCONCAT, 0)
}

func (s *Action_expr_arithmeticContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitAction_expr_arithmetic(s)

	default:
		return t.VisitChildren(s)
	}
}

type Array_access_action_exprContext struct {
	Action_exprContext
	array_element IAction_exprContext
	single        IAction_exprContext
	left          IAction_exprContext
	right         IAction_exprContext
}

func NewArray_access_action_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Array_access_action_exprContext {
	var p = new(Array_access_action_exprContext)

	InitEmptyAction_exprContext(&p.Action_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_exprContext))

	return p
}

func (s *Array_access_action_exprContext) GetArray_element() IAction_exprContext {
	return s.array_element
}

func (s *Array_access_action_exprContext) GetSingle() IAction_exprContext { return s.single }

func (s *Array_access_action_exprContext) GetLeft() IAction_exprContext { return s.left }

func (s *Array_access_action_exprContext) GetRight() IAction_exprContext { return s.right }

func (s *Array_access_action_exprContext) SetArray_element(v IAction_exprContext) {
	s.array_element = v
}

func (s *Array_access_action_exprContext) SetSingle(v IAction_exprContext) { s.single = v }

func (s *Array_access_action_exprContext) SetLeft(v IAction_exprContext) { s.left = v }

func (s *Array_access_action_exprContext) SetRight(v IAction_exprContext) { s.right = v }

func (s *Array_access_action_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_access_action_exprContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACKET, 0)
}

func (s *Array_access_action_exprContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACKET, 0)
}

func (s *Array_access_action_exprContext) AllAction_expr() []IAction_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAction_exprContext); ok {
			len++
		}
	}

	tst := make([]IAction_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAction_exprContext); ok {
			tst[i] = t.(IAction_exprContext)
			i++
		}
	}

	return tst
}

func (s *Array_access_action_exprContext) Action_expr(i int) IAction_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_exprContext)
}

func (s *Array_access_action_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Array_access_action_exprContext) COL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOL, 0)
}

func (s *Array_access_action_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitArray_access_action_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Logical_action_exprContext struct {
	Action_exprContext
}

func NewLogical_action_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Logical_action_exprContext {
	var p = new(Logical_action_exprContext)

	InitEmptyAction_exprContext(&p.Action_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_exprContext))

	return p
}

func (s *Logical_action_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_action_exprContext) AllAction_expr() []IAction_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAction_exprContext); ok {
			len++
		}
	}

	tst := make([]IAction_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAction_exprContext); ok {
			tst[i] = t.(IAction_exprContext)
			i++
		}
	}

	return tst
}

func (s *Logical_action_exprContext) Action_expr(i int) IAction_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_exprContext)
}

func (s *Logical_action_exprContext) AND() antlr.TerminalNode {
	return s.GetToken(KuneiformParserAND, 0)
}

func (s *Logical_action_exprContext) OR() antlr.TerminalNode {
	return s.GetToken(KuneiformParserOR, 0)
}

func (s *Logical_action_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitLogical_action_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Paren_action_exprContext struct {
	Action_exprContext
}

func NewParen_action_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Paren_action_exprContext {
	var p = new(Paren_action_exprContext)

	InitEmptyAction_exprContext(&p.Action_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_exprContext))

	return p
}

func (s *Paren_action_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Paren_action_exprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Paren_action_exprContext) Action_expr() IAction_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_exprContext)
}

func (s *Paren_action_exprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Paren_action_exprContext) Type_cast() IType_castContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_castContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_castContext)
}

func (s *Paren_action_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitParen_action_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

type Unary_action_exprContext struct {
	Action_exprContext
}

func NewUnary_action_exprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Unary_action_exprContext {
	var p = new(Unary_action_exprContext)

	InitEmptyAction_exprContext(&p.Action_exprContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_exprContext))

	return p
}

func (s *Unary_action_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_action_exprContext) Action_expr() IAction_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_exprContext)
}

func (s *Unary_action_exprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPLUS, 0)
}

func (s *Unary_action_exprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserMINUS, 0)
}

func (s *Unary_action_exprContext) EXCL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEXCL, 0)
}

func (s *Unary_action_exprContext) NOT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNOT, 0)
}

func (s *Unary_action_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitUnary_action_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Action_expr() (localctx IAction_exprContext) {
	return p.action_expr(0)
}

func (p *KuneiformParser) action_expr(_p int) (localctx IAction_exprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewAction_exprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAction_exprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 110
	p.EnterRecursionRule(localctx, 110, KuneiformParserRULE_action_expr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1155)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext()) {
	case 1:
		localctx = NewParen_action_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1122)
			p.Match(KuneiformParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1123)
			p.action_expr(0)
		}
		{
			p.SetState(1124)
			p.Match(KuneiformParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1126)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 155, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1125)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewUnary_action_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1128)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3147776) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1129)
			p.action_expr(14)
		}

	case 3:
		localctx = NewLiteral_action_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1130)
			p.Literal()
		}
		p.SetState(1132)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 156, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1131)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewFunction_call_action_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1134)
			p.Action_function_call()
		}
		p.SetState(1136)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 157, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1135)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		localctx = NewVariable_action_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1138)
			p.Variable()
		}
		p.SetState(1140)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1139)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		localctx = NewMake_array_action_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(1143)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserARRAY {
			{
				p.SetState(1142)
				p.Match(KuneiformParserARRAY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1145)
			p.Match(KuneiformParserLBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1147)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4371923291645933432) != 0) || ((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&2022115962081247233) != 0) {
			{
				p.SetState(1146)
				p.Action_expr_list()
			}

		}
		{
			p.SetState(1149)
			p.Match(KuneiformParserRBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1151)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1150)
				p.Type_cast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		localctx = NewUnary_action_exprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1153)
			p.Match(KuneiformParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(1154)
			p.action_expr(3)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1215)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1213)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext()) {
			case 1:
				localctx = NewAction_expr_arithmeticContext(p, NewAction_exprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_action_expr)
				p.SetState(1157)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				{
					p.SetState(1158)
					p.Match(KuneiformParserEXP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1159)
					p.action_expr(14)
				}

			case 2:
				localctx = NewAction_expr_arithmeticContext(p, NewAction_exprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_action_expr)
				p.SetState(1160)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				{
					p.SetState(1161)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4734976) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1162)
					p.action_expr(13)
				}

			case 3:
				localctx = NewAction_expr_arithmeticContext(p, NewAction_exprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_action_expr)
				p.SetState(1163)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				{
					p.SetState(1164)
					_la = p.GetTokenStream().LA(1)

					if !(_la == KuneiformParserPLUS || _la == KuneiformParserMINUS) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1165)
					p.action_expr(12)
				}

			case 4:
				localctx = NewAction_expr_arithmeticContext(p, NewAction_exprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_action_expr)
				p.SetState(1166)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(1167)
					p.Match(KuneiformParserCONCAT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1168)
					p.action_expr(7)
				}

			case 5:
				localctx = NewComparison_action_exprContext(p, NewAction_exprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_action_expr)
				p.SetState(1169)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(1170)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&520192000) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1171)
					p.action_expr(6)
				}

			case 6:
				localctx = NewLogical_action_exprContext(p, NewAction_exprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_action_expr)
				p.SetState(1172)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(1173)
					p.Match(KuneiformParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1174)
					p.action_expr(3)
				}

			case 7:
				localctx = NewLogical_action_exprContext(p, NewAction_exprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_action_expr)
				p.SetState(1175)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(1176)
					p.Match(KuneiformParserOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1177)
					p.action_expr(2)
				}

			case 8:
				localctx = NewField_access_action_exprContext(p, NewAction_exprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_action_expr)
				p.SetState(1178)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
					goto errorExit
				}
				{
					p.SetState(1179)
					p.Match(KuneiformParserPERIOD)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1180)
					p.Identifier()
				}
				p.SetState(1182)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 163, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(1181)
						p.Type_cast()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case 9:
				localctx = NewArray_access_action_exprContext(p, NewAction_exprContext(p, _parentctx, _parentState))
				localctx.(*Array_access_action_exprContext).array_element = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_action_expr)
				p.SetState(1184)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
					goto errorExit
				}
				{
					p.SetState(1185)
					p.Match(KuneiformParserLBRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1194)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 166, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(1186)

						var _x = p.action_expr(0)

						localctx.(*Array_access_action_exprContext).single = _x
					}

				case 2:
					p.SetState(1188)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4371923291645933432) != 0) || ((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&2022115962081247233) != 0) {
						{
							p.SetState(1187)

							var _x = p.action_expr(0)

							localctx.(*Array_access_action_exprContext).left = _x
						}

					}
					{
						p.SetState(1190)
						p.Match(KuneiformParserCOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					p.SetState(1192)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4371923291645933432) != 0) || ((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&2022115962081247233) != 0) {
						{
							p.SetState(1191)

							var _x = p.action_expr(0)

							localctx.(*Array_access_action_exprContext).right = _x
						}

					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}
				{
					p.SetState(1196)
					p.Match(KuneiformParserRBRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1198)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 167, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(1197)
						p.Type_cast()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case 10:
				localctx = NewIs_action_exprContext(p, NewAction_exprContext(p, _parentctx, _parentState))
				localctx.(*Is_action_exprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KuneiformParserRULE_action_expr)
				p.SetState(1200)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(1201)
					p.Match(KuneiformParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1203)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == KuneiformParserNOT {
					{
						p.SetState(1202)
						p.Match(KuneiformParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(1211)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case KuneiformParserDISTINCT:
					{
						p.SetState(1205)
						p.Match(KuneiformParserDISTINCT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1206)
						p.Match(KuneiformParserFROM)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1207)

						var _x = p.action_expr(0)

						localctx.(*Is_action_exprContext).right = _x
					}

				case KuneiformParserNULL:
					{
						p.SetState(1208)
						p.Match(KuneiformParserNULL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case KuneiformParserTRUE:
					{
						p.SetState(1209)
						p.Match(KuneiformParserTRUE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case KuneiformParserFALSE:
					{
						p.SetState(1210)
						p.Match(KuneiformParserFALSE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1217)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAction_expr_listContext is an interface to support dynamic dispatch.
type IAction_expr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAction_expr() []IAction_exprContext
	Action_expr(i int) IAction_exprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAction_expr_listContext differentiates from other interfaces.
	IsAction_expr_listContext()
}

type Action_expr_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAction_expr_listContext() *Action_expr_listContext {
	var p = new(Action_expr_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_action_expr_list
	return p
}

func InitEmptyAction_expr_listContext(p *Action_expr_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_action_expr_list
}

func (*Action_expr_listContext) IsAction_expr_listContext() {}

func NewAction_expr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Action_expr_listContext {
	var p = new(Action_expr_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_action_expr_list

	return p
}

func (s *Action_expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Action_expr_listContext) AllAction_expr() []IAction_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAction_exprContext); ok {
			len++
		}
	}

	tst := make([]IAction_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAction_exprContext); ok {
			tst[i] = t.(IAction_exprContext)
			i++
		}
	}

	return tst
}

func (s *Action_expr_listContext) Action_expr(i int) IAction_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_exprContext)
}

func (s *Action_expr_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Action_expr_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Action_expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Action_expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Action_expr_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitAction_expr_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Action_expr_list() (localctx IAction_expr_listContext) {
	localctx = NewAction_expr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, KuneiformParserRULE_action_expr_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1218)
		p.action_expr(0)
	}
	p.SetState(1223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KuneiformParserCOMMA {
		{
			p.SetState(1219)
			p.Match(KuneiformParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1220)
			p.action_expr(0)
		}

		p.SetState(1225)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAction_statementContext is an interface to support dynamic dispatch.
type IAction_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAction_statementContext differentiates from other interfaces.
	IsAction_statementContext()
}

type Action_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAction_statementContext() *Action_statementContext {
	var p = new(Action_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_action_statement
	return p
}

func InitEmptyAction_statementContext(p *Action_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_action_statement
}

func (*Action_statementContext) IsAction_statementContext() {}

func NewAction_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Action_statementContext {
	var p = new(Action_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_action_statement

	return p
}

func (s *Action_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Action_statementContext) CopyAll(ctx *Action_statementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *Action_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Action_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Stmt_ifContext struct {
	Action_statementContext
}

func NewStmt_ifContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Stmt_ifContext {
	var p = new(Stmt_ifContext)

	InitEmptyAction_statementContext(&p.Action_statementContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_statementContext))

	return p
}

func (s *Stmt_ifContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_ifContext) AllIF() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserIF)
}

func (s *Stmt_ifContext) IF(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserIF, i)
}

func (s *Stmt_ifContext) AllIf_then_block() []IIf_then_blockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIf_then_blockContext); ok {
			len++
		}
	}

	tst := make([]IIf_then_blockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIf_then_blockContext); ok {
			tst[i] = t.(IIf_then_blockContext)
			i++
		}
	}

	return tst
}

func (s *Stmt_ifContext) If_then_block(i int) IIf_then_blockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_then_blockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_then_blockContext)
}

func (s *Stmt_ifContext) AllELSE() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserELSE)
}

func (s *Stmt_ifContext) ELSE(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserELSE, i)
}

func (s *Stmt_ifContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACE, 0)
}

func (s *Stmt_ifContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACE, 0)
}

func (s *Stmt_ifContext) SCOL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, 0)
}

func (s *Stmt_ifContext) AllELSEIF() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserELSEIF)
}

func (s *Stmt_ifContext) ELSEIF(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserELSEIF, i)
}

func (s *Stmt_ifContext) AllAction_statement() []IAction_statementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAction_statementContext); ok {
			len++
		}
	}

	tst := make([]IAction_statementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAction_statementContext); ok {
			tst[i] = t.(IAction_statementContext)
			i++
		}
	}

	return tst
}

func (s *Stmt_ifContext) Action_statement(i int) IAction_statementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_statementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_statementContext)
}

func (s *Stmt_ifContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitStmt_if(s)

	default:
		return t.VisitChildren(s)
	}
}

type Stmt_loop_controlContext struct {
	Action_statementContext
}

func NewStmt_loop_controlContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Stmt_loop_controlContext {
	var p = new(Stmt_loop_controlContext)

	InitEmptyAction_statementContext(&p.Action_statementContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_statementContext))

	return p
}

func (s *Stmt_loop_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_loop_controlContext) SCOL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, 0)
}

func (s *Stmt_loop_controlContext) BREAK() antlr.TerminalNode {
	return s.GetToken(KuneiformParserBREAK, 0)
}

func (s *Stmt_loop_controlContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserCONTINUE, 0)
}

func (s *Stmt_loop_controlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitStmt_loop_control(s)

	default:
		return t.VisitChildren(s)
	}
}

type Stmt_variable_declarationContext struct {
	Action_statementContext
}

func NewStmt_variable_declarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Stmt_variable_declarationContext {
	var p = new(Stmt_variable_declarationContext)

	InitEmptyAction_statementContext(&p.Action_statementContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_statementContext))

	return p
}

func (s *Stmt_variable_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_variable_declarationContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserVARIABLE, 0)
}

func (s *Stmt_variable_declarationContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Stmt_variable_declarationContext) SCOL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, 0)
}

func (s *Stmt_variable_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitStmt_variable_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

type Stmt_return_nextContext struct {
	Action_statementContext
}

func NewStmt_return_nextContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Stmt_return_nextContext {
	var p = new(Stmt_return_nextContext)

	InitEmptyAction_statementContext(&p.Action_statementContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_statementContext))

	return p
}

func (s *Stmt_return_nextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_return_nextContext) RETURN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRETURN, 0)
}

func (s *Stmt_return_nextContext) NEXT() antlr.TerminalNode {
	return s.GetToken(KuneiformParserNEXT, 0)
}

func (s *Stmt_return_nextContext) Action_expr_list() IAction_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_expr_listContext)
}

func (s *Stmt_return_nextContext) SCOL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, 0)
}

func (s *Stmt_return_nextContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitStmt_return_next(s)

	default:
		return t.VisitChildren(s)
	}
}

type Stmt_for_loopContext struct {
	Action_statementContext
	receiver antlr.Token
}

func NewStmt_for_loopContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Stmt_for_loopContext {
	var p = new(Stmt_for_loopContext)

	InitEmptyAction_statementContext(&p.Action_statementContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_statementContext))

	return p
}

func (s *Stmt_for_loopContext) GetReceiver() antlr.Token { return s.receiver }

func (s *Stmt_for_loopContext) SetReceiver(v antlr.Token) { s.receiver = v }

func (s *Stmt_for_loopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_for_loopContext) FOR() antlr.TerminalNode {
	return s.GetToken(KuneiformParserFOR, 0)
}

func (s *Stmt_for_loopContext) IN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserIN, 0)
}

func (s *Stmt_for_loopContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACE, 0)
}

func (s *Stmt_for_loopContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACE, 0)
}

func (s *Stmt_for_loopContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserVARIABLE, 0)
}

func (s *Stmt_for_loopContext) Range_() IRangeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeContext)
}

func (s *Stmt_for_loopContext) Sql_statement() ISql_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_statementContext)
}

func (s *Stmt_for_loopContext) Action_expr() IAction_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_exprContext)
}

func (s *Stmt_for_loopContext) AllAction_statement() []IAction_statementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAction_statementContext); ok {
			len++
		}
	}

	tst := make([]IAction_statementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAction_statementContext); ok {
			tst[i] = t.(IAction_statementContext)
			i++
		}
	}

	return tst
}

func (s *Stmt_for_loopContext) Action_statement(i int) IAction_statementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_statementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_statementContext)
}

func (s *Stmt_for_loopContext) SCOL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, 0)
}

func (s *Stmt_for_loopContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(KuneiformParserARRAY, 0)
}

func (s *Stmt_for_loopContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitStmt_for_loop(s)

	default:
		return t.VisitChildren(s)
	}
}

type Stmt_returnContext struct {
	Action_statementContext
}

func NewStmt_returnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Stmt_returnContext {
	var p = new(Stmt_returnContext)

	InitEmptyAction_statementContext(&p.Action_statementContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_statementContext))

	return p
}

func (s *Stmt_returnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_returnContext) RETURN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRETURN, 0)
}

func (s *Stmt_returnContext) SCOL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, 0)
}

func (s *Stmt_returnContext) Action_expr_list() IAction_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_expr_listContext)
}

func (s *Stmt_returnContext) Sql_statement() ISql_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_statementContext)
}

func (s *Stmt_returnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitStmt_return(s)

	default:
		return t.VisitChildren(s)
	}
}

type Stmt_action_callContext struct {
	Action_statementContext
}

func NewStmt_action_callContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Stmt_action_callContext {
	var p = new(Stmt_action_callContext)

	InitEmptyAction_statementContext(&p.Action_statementContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_statementContext))

	return p
}

func (s *Stmt_action_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_action_callContext) Action_function_call() IAction_function_callContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_function_callContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_function_callContext)
}

func (s *Stmt_action_callContext) SCOL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, 0)
}

func (s *Stmt_action_callContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserASSIGN, 0)
}

func (s *Stmt_action_callContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEQUALS, 0)
}

func (s *Stmt_action_callContext) AllVariable_or_underscore() []IVariable_or_underscoreContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariable_or_underscoreContext); ok {
			len++
		}
	}

	tst := make([]IVariable_or_underscoreContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariable_or_underscoreContext); ok {
			tst[i] = t.(IVariable_or_underscoreContext)
			i++
		}
	}

	return tst
}

func (s *Stmt_action_callContext) Variable_or_underscore(i int) IVariable_or_underscoreContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariable_or_underscoreContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariable_or_underscoreContext)
}

func (s *Stmt_action_callContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KuneiformParserCOMMA)
}

func (s *Stmt_action_callContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KuneiformParserCOMMA, i)
}

func (s *Stmt_action_callContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitStmt_action_call(s)

	default:
		return t.VisitChildren(s)
	}
}

type Stmt_variable_assignmentContext struct {
	Action_statementContext
}

func NewStmt_variable_assignmentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Stmt_variable_assignmentContext {
	var p = new(Stmt_variable_assignmentContext)

	InitEmptyAction_statementContext(&p.Action_statementContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_statementContext))

	return p
}

func (s *Stmt_variable_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_variable_assignmentContext) AllAction_expr() []IAction_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAction_exprContext); ok {
			len++
		}
	}

	tst := make([]IAction_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAction_exprContext); ok {
			tst[i] = t.(IAction_exprContext)
			i++
		}
	}

	return tst
}

func (s *Stmt_variable_assignmentContext) Action_expr(i int) IAction_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_exprContext)
}

func (s *Stmt_variable_assignmentContext) SCOL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, 0)
}

func (s *Stmt_variable_assignmentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserASSIGN, 0)
}

func (s *Stmt_variable_assignmentContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(KuneiformParserEQUALS, 0)
}

func (s *Stmt_variable_assignmentContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Stmt_variable_assignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitStmt_variable_assignment(s)

	default:
		return t.VisitChildren(s)
	}
}

type Stmt_sqlContext struct {
	Action_statementContext
}

func NewStmt_sqlContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Stmt_sqlContext {
	var p = new(Stmt_sqlContext)

	InitEmptyAction_statementContext(&p.Action_statementContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_statementContext))

	return p
}

func (s *Stmt_sqlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_sqlContext) Sql_statement() ISql_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_statementContext)
}

func (s *Stmt_sqlContext) SCOL() antlr.TerminalNode {
	return s.GetToken(KuneiformParserSCOL, 0)
}

func (s *Stmt_sqlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitStmt_sql(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Action_statement() (localctx IAction_statementContext) {
	localctx = NewAction_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, KuneiformParserRULE_action_statement)
	var _la int

	var _alt int

	p.SetState(1318)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStmt_variable_declarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1226)
			p.Match(KuneiformParserVARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1227)
			p.Type_()
		}
		{
			p.SetState(1228)
			p.Match(KuneiformParserSCOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewStmt_action_callContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1240)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserUNDERSCORE || _la == KuneiformParserVARIABLE {
			{
				p.SetState(1230)
				p.Variable_or_underscore()
			}

			p.SetState(1235)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KuneiformParserCOMMA {
				{
					p.SetState(1231)
					p.Match(KuneiformParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				{
					p.SetState(1232)
					p.Variable_or_underscore()
				}

				p.SetState(1237)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1238)
				_la = p.GetTokenStream().LA(1)

				if !(_la == KuneiformParserEQUALS || _la == KuneiformParserASSIGN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1242)
			p.Action_function_call()
		}
		{
			p.SetState(1243)
			p.Match(KuneiformParserSCOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewStmt_variable_assignmentContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1245)
			p.action_expr(0)
		}
		p.SetState(1247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9127724498152325120) != 0) || ((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&288362046938939393) != 0) {
			{
				p.SetState(1246)
				p.Type_()
			}

		}
		{
			p.SetState(1249)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KuneiformParserEQUALS || _la == KuneiformParserASSIGN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1250)
			p.action_expr(0)
		}
		{
			p.SetState(1251)
			p.Match(KuneiformParserSCOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewStmt_for_loopContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1253)
			p.Match(KuneiformParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1254)

			var _m = p.Match(KuneiformParserVARIABLE)

			localctx.(*Stmt_for_loopContext).receiver = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1255)
			p.Match(KuneiformParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1262)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 177, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1256)
				p.Range_()
			}

		case 2:
			{
				p.SetState(1257)
				p.Sql_statement()
			}

		case 3:
			p.SetState(1259)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1258)
					p.Match(KuneiformParserARRAY)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(1261)
				p.action_expr(0)
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(1264)
			p.Match(KuneiformParserLBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1268)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3507232162117056376) != 0) || ((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&2022115962081253381) != 0) {
			{
				p.SetState(1265)
				p.Action_statement()
			}

			p.SetState(1270)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1271)
			p.Match(KuneiformParserRBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1273)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserSCOL {
			{
				p.SetState(1272)
				p.Match(KuneiformParserSCOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		localctx = NewStmt_ifContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1275)
			p.Match(KuneiformParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1276)
			p.If_then_block()
		}
		p.SetState(1285)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(1280)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case KuneiformParserELSEIF:
					{
						p.SetState(1277)
						p.Match(KuneiformParserELSEIF)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case KuneiformParserELSE:
					{
						p.SetState(1278)
						p.Match(KuneiformParserELSE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1279)
						p.Match(KuneiformParserIF)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}
				{
					p.SetState(1282)
					p.If_then_block()
				}

			}
			p.SetState(1287)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1297)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 183, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1288)
				p.Match(KuneiformParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1289)
				p.Match(KuneiformParserLBRACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1293)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3507232162117056376) != 0) || ((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&2022115962081253381) != 0) {
				{
					p.SetState(1290)
					p.Action_statement()
				}

				p.SetState(1295)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1296)
				p.Match(KuneiformParserRBRACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1300)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KuneiformParserSCOL {
			{
				p.SetState(1299)
				p.Match(KuneiformParserSCOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		localctx = NewStmt_sqlContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1302)
			p.Sql_statement()
		}
		{
			p.SetState(1303)
			p.Match(KuneiformParserSCOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewStmt_loop_controlContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1305)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KuneiformParserBREAK || _la == KuneiformParserCONTINUE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1306)
			p.Match(KuneiformParserSCOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewStmt_returnContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1307)
			p.Match(KuneiformParserRETURN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1310)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case KuneiformParserLBRACKET, KuneiformParserLPAREN, KuneiformParserEXCL, KuneiformParserPLUS, KuneiformParserMINUS, KuneiformParserDOUBLE_QUOTE, KuneiformParserUSE, KuneiformParserUNUSE, KuneiformParserACTION, KuneiformParserCREATE, KuneiformParserALTER, KuneiformParserADD, KuneiformParserDROP, KuneiformParserRENAME, KuneiformParserCHECK, KuneiformParserFOREIGN, KuneiformParserPRIMARY, KuneiformParserKEY, KuneiformParserUNIQUE, KuneiformParserRESTRICT, KuneiformParserDEFAULT, KuneiformParserNULL, KuneiformParserNOT, KuneiformParserINDEX, KuneiformParserRETURNS, KuneiformParserCONFLICT, KuneiformParserFOR, KuneiformParserIF, KuneiformParserELSEIF, KuneiformParserELSE, KuneiformParserBREAK, KuneiformParserCONTINUE, KuneiformParserRETURN, KuneiformParserGRANT, KuneiformParserGRANTED, KuneiformParserREVOKE, KuneiformParserROLE, KuneiformParserREPLACE, KuneiformParserARRAY, KuneiformParserNAMESPACE, KuneiformParserROLES, KuneiformParserCALL, KuneiformParserSTRING_, KuneiformParserTRUE, KuneiformParserFALSE, KuneiformParserDIGITS_, KuneiformParserBINARY_, KuneiformParserIDENTIFIER, KuneiformParserVARIABLE, KuneiformParserCONTEXTUAL_VARIABLE:
			{
				p.SetState(1308)
				p.Action_expr_list()
			}

		case KuneiformParserDELETE, KuneiformParserUPDATE, KuneiformParserWITH, KuneiformParserSELECT, KuneiformParserINSERT:
			{
				p.SetState(1309)
				p.Sql_statement()
			}

		case KuneiformParserSCOL:

		default:
		}
		{
			p.SetState(1312)
			p.Match(KuneiformParserSCOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewStmt_return_nextContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1313)
			p.Match(KuneiformParserRETURN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1314)
			p.Match(KuneiformParserNEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1315)
			p.Action_expr_list()
		}
		{
			p.SetState(1316)
			p.Match(KuneiformParserSCOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariable_or_underscoreContext is an interface to support dynamic dispatch.
type IVariable_or_underscoreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VARIABLE() antlr.TerminalNode
	UNDERSCORE() antlr.TerminalNode

	// IsVariable_or_underscoreContext differentiates from other interfaces.
	IsVariable_or_underscoreContext()
}

type Variable_or_underscoreContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_or_underscoreContext() *Variable_or_underscoreContext {
	var p = new(Variable_or_underscoreContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_variable_or_underscore
	return p
}

func InitEmptyVariable_or_underscoreContext(p *Variable_or_underscoreContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_variable_or_underscore
}

func (*Variable_or_underscoreContext) IsVariable_or_underscoreContext() {}

func NewVariable_or_underscoreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_or_underscoreContext {
	var p = new(Variable_or_underscoreContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_variable_or_underscore

	return p
}

func (s *Variable_or_underscoreContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_or_underscoreContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserVARIABLE, 0)
}

func (s *Variable_or_underscoreContext) UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserUNDERSCORE, 0)
}

func (s *Variable_or_underscoreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_or_underscoreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_or_underscoreContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitVariable_or_underscore(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Variable_or_underscore() (localctx IVariable_or_underscoreContext) {
	localctx = NewVariable_or_underscoreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, KuneiformParserRULE_variable_or_underscore)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1320)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KuneiformParserUNDERSCORE || _la == KuneiformParserVARIABLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAction_function_callContext is an interface to support dynamic dispatch.
type IAction_function_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAction_function_callContext differentiates from other interfaces.
	IsAction_function_callContext()
}

type Action_function_callContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAction_function_callContext() *Action_function_callContext {
	var p = new(Action_function_callContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_action_function_call
	return p
}

func InitEmptyAction_function_callContext(p *Action_function_callContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_action_function_call
}

func (*Action_function_callContext) IsAction_function_callContext() {}

func NewAction_function_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Action_function_callContext {
	var p = new(Action_function_callContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_action_function_call

	return p
}

func (s *Action_function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Action_function_callContext) CopyAll(ctx *Action_function_callContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *Action_function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Action_function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Normal_call_actionContext struct {
	Action_function_callContext
	namespace IIdentifierContext
	function  IIdentifierContext
}

func NewNormal_call_actionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Normal_call_actionContext {
	var p = new(Normal_call_actionContext)

	InitEmptyAction_function_callContext(&p.Action_function_callContext)
	p.parser = parser
	p.CopyAll(ctx.(*Action_function_callContext))

	return p
}

func (s *Normal_call_actionContext) GetNamespace() IIdentifierContext { return s.namespace }

func (s *Normal_call_actionContext) GetFunction() IIdentifierContext { return s.function }

func (s *Normal_call_actionContext) SetNamespace(v IIdentifierContext) { s.namespace = v }

func (s *Normal_call_actionContext) SetFunction(v IIdentifierContext) { s.function = v }

func (s *Normal_call_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Normal_call_actionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLPAREN, 0)
}

func (s *Normal_call_actionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRPAREN, 0)
}

func (s *Normal_call_actionContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Normal_call_actionContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Normal_call_actionContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(KuneiformParserPERIOD, 0)
}

func (s *Normal_call_actionContext) Action_expr_list() IAction_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_expr_listContext)
}

func (s *Normal_call_actionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitNormal_call_action(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Action_function_call() (localctx IAction_function_callContext) {
	localctx = NewAction_function_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, KuneiformParserRULE_action_function_call)
	var _la int

	localctx = NewNormal_call_actionContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1325)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 187, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1322)

			var _x = p.Identifier()

			localctx.(*Normal_call_actionContext).namespace = _x
		}
		{
			p.SetState(1323)
			p.Match(KuneiformParserPERIOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1327)

		var _x = p.Identifier()

		localctx.(*Normal_call_actionContext).function = _x
	}
	{
		p.SetState(1328)
		p.Match(KuneiformParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1330)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4371923291645933432) != 0) || ((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&2022115962081247233) != 0) {
		{
			p.SetState(1329)
			p.Action_expr_list()
		}

	}
	{
		p.SetState(1332)
		p.Match(KuneiformParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIf_then_blockContext is an interface to support dynamic dispatch.
type IIf_then_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Action_expr() IAction_exprContext
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllAction_statement() []IAction_statementContext
	Action_statement(i int) IAction_statementContext

	// IsIf_then_blockContext differentiates from other interfaces.
	IsIf_then_blockContext()
}

type If_then_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_then_blockContext() *If_then_blockContext {
	var p = new(If_then_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_if_then_block
	return p
}

func InitEmptyIf_then_blockContext(p *If_then_blockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_if_then_block
}

func (*If_then_blockContext) IsIf_then_blockContext() {}

func NewIf_then_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_then_blockContext {
	var p = new(If_then_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_if_then_block

	return p
}

func (s *If_then_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *If_then_blockContext) Action_expr() IAction_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_exprContext)
}

func (s *If_then_blockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserLBRACE, 0)
}

func (s *If_then_blockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRBRACE, 0)
}

func (s *If_then_blockContext) AllAction_statement() []IAction_statementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAction_statementContext); ok {
			len++
		}
	}

	tst := make([]IAction_statementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAction_statementContext); ok {
			tst[i] = t.(IAction_statementContext)
			i++
		}
	}

	return tst
}

func (s *If_then_blockContext) Action_statement(i int) IAction_statementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_statementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_statementContext)
}

func (s *If_then_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_then_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_then_blockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitIf_then_block(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) If_then_block() (localctx IIf_then_blockContext) {
	localctx = NewIf_then_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, KuneiformParserRULE_if_then_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1334)
		p.action_expr(0)
	}
	{
		p.SetState(1335)
		p.Match(KuneiformParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1339)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3507232162117056376) != 0) || ((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&2022115962081253381) != 0) {
		{
			p.SetState(1336)
			p.Action_statement()
		}

		p.SetState(1341)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1342)
		p.Match(KuneiformParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeContext is an interface to support dynamic dispatch.
type IRangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAction_expr() []IAction_exprContext
	Action_expr(i int) IAction_exprContext
	RANGE() antlr.TerminalNode

	// IsRangeContext differentiates from other interfaces.
	IsRangeContext()
}

type RangeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeContext() *RangeContext {
	var p = new(RangeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_range
	return p
}

func InitEmptyRangeContext(p *RangeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KuneiformParserRULE_range
}

func (*RangeContext) IsRangeContext() {}

func NewRangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeContext {
	var p = new(RangeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KuneiformParserRULE_range

	return p
}

func (s *RangeContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeContext) AllAction_expr() []IAction_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAction_exprContext); ok {
			len++
		}
	}

	tst := make([]IAction_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAction_exprContext); ok {
			tst[i] = t.(IAction_exprContext)
			i++
		}
	}

	return tst
}

func (s *RangeContext) Action_expr(i int) IAction_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAction_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAction_exprContext)
}

func (s *RangeContext) RANGE() antlr.TerminalNode {
	return s.GetToken(KuneiformParserRANGE, 0)
}

func (s *RangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KuneiformParserVisitor:
		return t.VisitRange(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KuneiformParser) Range_() (localctx IRangeContext) {
	localctx = NewRangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, KuneiformParserRULE_range)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1344)
		p.action_expr(0)
	}
	{
		p.SetState(1345)
		p.Match(KuneiformParserRANGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1346)
		p.action_expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *KuneiformParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 50:
		var t *Sql_exprContext = nil
		if localctx != nil {
			t = localctx.(*Sql_exprContext)
		}
		return p.Sql_expr_Sempred(t, predIndex)

	case 55:
		var t *Action_exprContext = nil
		if localctx != nil {
			t = localctx.(*Action_exprContext)
		}
		return p.Action_expr_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *KuneiformParser) Sql_expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 24)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 21)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *KuneiformParser) Action_expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 14:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 22:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 23:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
