package types

import (
	"encoding/binary"
	"fmt"
	"io"
	"slices"
	"time"

	"github.com/kwilteam/kwil-db/core/crypto"
)

const (
	BlockVersion = 0
)

type BlockHeader struct {
	Version     uint16
	Height      int64
	NumTxns     uint32
	PrevHash    Hash // previous block's hash
	PrevAppHash Hash // app hash after last block
	Timestamp   time.Time
	MerkleRoot  Hash // Merkle tree reference to hash of all transactions for the block

	// Proposer []byte should be leader, so probably pointless here
	ValidatorSetHash Hash // Hash of the validator set for the block

	// ConsensusUpdates []ConsensusUpdate

	// ChainStateHash Hash // if we want to keep the "application" hash separate from state of consensus engine
	// PrevExecResultHash Hash
}

type Block struct {
	Header    *BlockHeader
	Txns      [][]byte
	Signature []byte // Signature is the block producer's signature (leader in our model)
}

func (b *Block) Hash() Hash {
	return b.Header.Hash()
}

func (b *Block) MerkleRoot() Hash {
	txHashes := make([]Hash, len(b.Txns))
	for i := range b.Txns {
		txHashes[i] = HashBytes(b.Txns[i])
	}
	return CalcMerkleRoot(txHashes)
}

func (b *Block) Sign(signer crypto.PrivateKey) error {
	hash := b.Hash()
	sig, err := signer.Sign(hash[:])
	if err != nil {
		return fmt.Errorf("failed to sign block: %w", err)
	}
	b.Signature = sig
	return nil
}

func (b *Block) VerifySignature(pubKey crypto.PublicKey) (bool, error) {
	hash := b.Hash()
	return pubKey.Verify(hash[:], b.Signature)
}

func (bh *BlockHeader) Hash() Hash {
	hasher := NewHasher()
	bh.WriteBlockHeader(hasher)
	return hasher.Sum(nil)
}

func (bh *BlockHeader) String() string {
	return fmt.Sprintf("BlockHeader{Version: %d, Height: %d, NumTxns: %d, PrevHash: %s, AppHash: %s, Timestamp: %s, MerkelRoot: %s}",
		bh.Version,
		bh.Height,
		bh.NumTxns,
		bh.PrevHash,
		bh.PrevAppHash,
		bh.Timestamp.Format(time.RFC3339),
		bh.MerkleRoot)
}

func (bh *BlockHeader) WriteBlockHeader(w io.Writer) error {
	if err := binary.Write(w, binary.LittleEndian, bh.Version); err != nil {
		return fmt.Errorf("failed to write version: %w", err)
	}

	if err := binary.Write(w, binary.LittleEndian, bh.Height); err != nil {
		return fmt.Errorf("failed to write height: %w", err)
	}

	if err := binary.Write(w, binary.LittleEndian, bh.NumTxns); err != nil {
		return fmt.Errorf("failed to write number of transactions: %w", err)
	}

	if _, err := w.Write(bh.PrevHash[:]); err != nil {
		return fmt.Errorf("failed to write previous block hash: %w", err)
	}

	if _, err := w.Write(bh.PrevAppHash[:]); err != nil {
		return fmt.Errorf("failed to write app hash: %w", err)
	}

	if _, err := w.Write(bh.ValidatorSetHash[:]); err != nil {
		return fmt.Errorf("failed to write validator hash: %w", err)
	}

	if err := binary.Write(w, binary.LittleEndian, uint64(bh.Timestamp.UnixMilli())); err != nil {
		return fmt.Errorf("failed to write timestamp: %w", err)
	}

	if _, err := w.Write(bh.MerkleRoot[:]); err != nil {
		return fmt.Errorf("failed to write merkel root: %w", err)
	}

	// for _, v := range bh.ValidatorUpdates {
	// 	if err := binary.Write(w, binary.LittleEndian, v.PubKey); err != nil {
	// 		return fmt.Errorf("failed to write validator pubkey: %w", err)
	// 	}

	// 	if err := binary.Write(w, binary.LittleEndian, v.Power); err != nil {
	// 		return fmt.Errorf("failed to write validator power: %w", err)
	// 	}
	// }

	return nil
}

// CalcMerkleRoot computes the merkel root for a slice of hashes. This is based
// on the "inline" implementation from btcd / dcrd.
func CalcMerkleRoot(leaves []Hash) Hash {
	if len(leaves) == 0 {
		// All zero.
		return Hash{}
	}

	// Do not modify the leaves slice from the caller.
	leaves = slices.Clone(leaves)

	// Create a buffer to reuse for hashing the branches and some long lived
	// slices into it to avoid reslicing.
	var buf [2 * HashLen]byte
	var left = buf[:HashLen]
	var right = buf[HashLen:]
	var both = buf[:]

	// The following algorithm works by replacing the leftmost entries in the
	// slice with the concatenations of each subsequent set of 2 hashes and
	// shrinking the slice by half to account for the fact that each level of
	// the tree is half the size of the previous one.  In the case a level is
	// unbalanced (there is no final right child), the final node is duplicated
	// so it ultimately is concatenated with itself.
	//
	// For example, the following illustrates calculating a tree with 5 leaves:
	//
	// [0 1 2 3 4]                              (5 entries)
	// 1st iteration: [h(0||1) h(2||3) h(4||4)] (3 entries)
	// 2nd iteration: [h(h01||h23) h(h44||h44)] (2 entries)
	// 3rd iteration: [h(h0123||h4444)]         (1 entry)
	for len(leaves) > 1 {
		// When there is no right child, the parent is generated by hashing the
		// concatenation of the left child with itself.
		if len(leaves)&1 != 0 {
			leaves = append(leaves, leaves[len(leaves)-1])
		}

		// Set the parent node to the hash of the concatenation of the left and
		// right children.
		for i := range len(leaves) / 2 {
			copy(left, leaves[i*2][:])
			copy(right, leaves[i*2+1][:])
			leaves[i] = HashBytes(both)
		}
		leaves = leaves[:len(leaves)/2]
	}
	return leaves[0]
}
