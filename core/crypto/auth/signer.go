package auth

import (
	"bytes"
	"crypto/sha256"
	"encoding/binary"
	"errors"
	"fmt"
	"io"

	"golang.org/x/crypto/sha3"

	"github.com/kwilteam/kwil-db/core/crypto"
	"github.com/kwilteam/kwil-db/core/utils"
)

// Signature is a signature with a designated AuthType, which should
// be used to determine how to verify the signature.
type Signature struct {
	// Data is the raw signature bytes
	Data []byte `json:"sig"`
	// Type is the signature type, which must have a registered Authenticator of
	// the same name for the Verify method to be usable.
	Type string `json:"type"`
}

var _ io.WriterTo = Signature{}

func (s Signature) WriteTo(w io.Writer) (int64, error) {
	cw := utils.NewCountingWriter(w)
	if err := binary.Write(cw, binary.LittleEndian, uint32(len(s.Data))); err != nil {
		return cw.Written(), fmt.Errorf("failed to write signature length: %w", err)
	}
	if err := binary.Write(cw, binary.LittleEndian, s.Data); err != nil {
		return cw.Written(), fmt.Errorf("failed to write signature data: %w", err)
	}

	if err := binary.Write(cw, binary.LittleEndian, uint32(len(s.Type))); err != nil {
		return cw.Written(), fmt.Errorf("failed to write signature type length: %w", err)
	}
	if err := binary.Write(cw, binary.LittleEndian, []byte(s.Type)); err != nil {
		return cw.Written(), fmt.Errorf("failed to write signature type: %w", err)
	}

	return cw.Written(), nil
}

func (s Signature) MarshalBinary() ([]byte, error) {
	buf := new(bytes.Buffer)
	s.WriteTo(buf) // does not error with a bytes.Buffer as the Writer
	return buf.Bytes(), nil
}

func (s Signature) Bytes() []byte {
	b, _ := s.MarshalBinary() // does not error
	return b
}

func (s *Signature) UnmarshalBinary(data []byte) error {
	r := bytes.NewReader(data)
	n, err := s.ReadFrom(r)
	if err != nil {
		return err
	}
	if len(data) != int(n) {
		return errors.New("extra signature data")
	}
	if r.Len() != 0 {
		return errors.New("extra signature data (reader)")
	}
	return nil
}

func (s *Signature) ReadFrom(r io.Reader) (int64, error) {
	rl, _ := r.(interface{ Len() int })
	var n int64
	var sigLen uint32
	if err := binary.Read(r, binary.LittleEndian, &sigLen); err != nil {
		return 0, fmt.Errorf("failed to read signature length: %w", err)
	}
	n += 4

	if sigLen > 0 {
		if rl != nil {
			if int(sigLen) > rl.Len() {
				return 0, fmt.Errorf("impossibly long signature length: %d", sigLen)
			}
			s.Data = make([]byte, sigLen)
			if _, err := io.ReadFull(r, s.Data); err != nil {
				return 0, fmt.Errorf("failed to read signature data: %w", err)
			}
		} else {
			sigBuf := &bytes.Buffer{}
			_, err := io.CopyN(sigBuf, r, int64(sigLen))
			if err != nil {
				return 0, fmt.Errorf("failed to read signature data: %w", err)
			}
			s.Data = sigBuf.Bytes()
		}

	}
	n += int64(sigLen)

	var typeLen uint32
	if err := binary.Read(r, binary.LittleEndian, &typeLen); err != nil {
		return 0, fmt.Errorf("failed to read signature type length: %w", err)
	}
	n += 4

	if typeLen > 0 {
		if rl != nil && int(typeLen) > rl.Len() {
			return 0, fmt.Errorf("impossibly long sig type length: %d", typeLen)
		}
		typeBytes := make([]byte, typeLen)
		if _, err := io.ReadFull(r, typeBytes); err != nil {
			return 0, fmt.Errorf("failed to read signature type: %w", err)
		}
		s.Type = string(typeBytes)
	}
	n += int64(typeLen)

	return n, nil
}

// Signer is an interface for something that can sign messages.
// It returns signatures with a designated AuthType, which should
// be used to determine how to verify the signature.
type Signer interface {
	// Sign signs a message and returns the signature
	Sign(msg []byte) (*Signature, error)

	// CompactID returns the signer's compact identifier, which is typically and
	// address or a public key. This value is recognized by the Verify method of
	// the corresponding Authenticator for the types of signatures generated by
	// this Signer. This is used to set the Sender field of a Transaction.
	// If you need the public key, use the PubKey method.
	CompactID() []byte

	// PubKey returns the public key associated with this signer. This may or
	// may not correspond directly to the Identity, which may be an address. The
	// purpose of Identity is to be used with the Verify method of the
	// Authenticator for the AuthType of this Signer, which may not take the
	// bytes of this pubkey.
	PubKey() crypto.PublicKey

	// AuthType is the type of Authenticator that should be used to verify the
	// signature created by this Signer; also to get the string identifier from
	// the Identity. This is used to set the AuthType field of a Transaction.
	AuthType() string
}

func GetNodeSigner(key crypto.PrivateKey) Signer {
	switch key := key.(type) {
	case *crypto.Secp256k1PrivateKey:
		return &Secp256k1Signer{Secp256k1PrivateKey: *key} // id is pubkey / sign/verify with just sha256, no text hash
	case *crypto.Ed25519PrivateKey:
		return &Ed25519Signer{Ed25519PrivateKey: *key}
	default:
		return nil
	}
}

func GetUserSigner(key crypto.PrivateKey) Signer {
	switch key := key.(type) {
	case *crypto.Secp256k1PrivateKey:
		return &EthPersonalSigner{Key: *key}
	case *crypto.Ed25519PrivateKey:
		return &Ed25519Signer{Ed25519PrivateKey: *key}
	default:
		return nil
	}
}

func GetUserIdentifier(pub crypto.PublicKey) (string, error) {
	switch pub := pub.(type) {
	case *crypto.Secp256k1PublicKey:
		compactID := ethSecp256k1CompactID(pub)
		return EthSecp256k1Authenticator{}.Identifier(compactID)
	case *crypto.Ed25519PublicKey:
		compactID := ed25519CompactID(pub)
		return Ed25519Authenticator{}.Identifier(compactID)
	default:
		return "", errors.New("unsupported public key type")
	}
}

func GetNodeIdentifier(pub crypto.PublicKey) (string, error) {
	switch pub := pub.(type) {
	case *crypto.Secp256k1PublicKey:
		compactID := secp256k1CompactID(pub) // NOT EthSecp256k1CompactID!
		return EthSecp256k1Authenticator{}.Identifier(compactID)
	case *crypto.Ed25519PublicKey:
		compactID := ed25519CompactID(pub)
		return Ed25519Authenticator{}.Identifier(compactID)
	default:
		return "", errors.New("unsupported public key type")
	}
}

type Secp256k1Signer struct {
	crypto.Secp256k1PrivateKey
}

var _ Signer = (*Secp256k1Signer)(nil)

func (s *Secp256k1Signer) Sign(msg []byte) (*Signature, error) {
	hash := sha256.Sum256(msg)
	signatureBts, err := s.Secp256k1PrivateKey.SignRaw(hash[:])
	if err != nil {
		return nil, err
	}

	return &Signature{
		Data: signatureBts,
		Type: Secp256k1Auth,
	}, nil
}

func (s *Secp256k1Signer) PubKey() crypto.PublicKey {
	return s.Secp256k1PrivateKey.Public()
}

func ethSecp256k1CompactID(pub *crypto.Secp256k1PublicKey) []byte {
	return crypto.EthereumAddressFromPubKey(pub)
}

func secp256k1CompactID(pub *crypto.Secp256k1PublicKey) []byte {
	return pub.Bytes()
}

// CompactID returns the identity of the signer (public key for this signer).
// This is used with the Verify method of the authenticator. To get a text
// identifier, use the Authenticator's Identifier method.
func (s *Secp256k1Signer) CompactID() []byte {
	return s.Secp256k1PrivateKey.Public().Bytes()
}

func (*Secp256k1Signer) AuthType() string {
	return Secp256k1Auth
}

// EthPersonalSecp256k1Signer is a signer that signs messages using the
// secp256k1 curve, using ethereum's personal_sign signature scheme.
type EthPersonalSigner struct {
	Key crypto.Secp256k1PrivateKey
}

var _ Signer = (*EthPersonalSigner)(nil)

func textHash(data []byte) []byte {
	msg := fmt.Sprintf("\x19Ethereum Signed Message:\n%d%s", len(data), data)
	hasher := sha3.NewLegacyKeccak256()
	hasher.Write([]byte(msg))
	return hasher.Sum(nil)
}

// Sign sign given message according to EIP-191 personal_sign.
// EIP-191 personal_sign prefix the message with "\x19Ethereum Signed Message:\n"
// and the message length, then hash the message with 'legacy' keccak256.
// The signature is in [R || S || V] format, 65 bytes.
// This method is used to sign an arbitrary message in the same manner in which
// a wallet like MetaMask would sign a text message. The message is defined by
// the object that is being serialized e.g. a Kwil Transaction.
func (e *EthPersonalSigner) Sign(msg []byte) (*Signature, error) {
	hash := textHash(msg)
	sigBts, err := e.Key.SignRaw(hash)
	if err != nil {
		return nil, err
	}

	return &Signature{
		Data: sigBts,
		Type: EthPersonalSignAuth,
	}, nil
}

// PubKey returns the public key of the signer.
func (e *EthPersonalSigner) PubKey() crypto.PublicKey {
	return e.Key.Public()
}

// CompactID returns the identity of the signer (ETH address for this signer).
func (e *EthPersonalSigner) CompactID() []byte {
	pubKey := e.Key.Public().(*crypto.Secp256k1PublicKey)
	return crypto.EthereumAddressFromPubKey(pubKey)
}

func (e *EthPersonalSigner) AuthType() string {
	return EthPersonalSignAuth
}

// Ed25519Signer is a signer that signs messages using the
// ed25519 curve, using the standard signature scheme.
type Ed25519Signer struct {
	crypto.Ed25519PrivateKey
}

var _ Signer = (*Ed25519Signer)(nil)

// Sign signs the given message(not hashed) according to standard signature scheme.
// It does not apply any special digests to the message.
func (e *Ed25519Signer) Sign(msg []byte) (*Signature, error) {
	signatureBts, err := e.Ed25519PrivateKey.Sign(msg)
	if err != nil {
		return nil, err
	}

	return &Signature{
		Data: signatureBts,
		Type: Ed25519Auth,
	}, nil
}

// PubKey returns the public key of the signer.
func (e *Ed25519Signer) PubKey() crypto.PublicKey {
	return e.Ed25519PrivateKey.Public()
}

func ed25519CompactID(pub *crypto.Ed25519PublicKey) []byte {
	return pub.Bytes()
}

// CompactID returns the identity of the signer (public key for this signer).
func (e *Ed25519Signer) CompactID() []byte {
	return ed25519CompactID(e.Ed25519PrivateKey.Public().(*crypto.Ed25519PublicKey))
}

func (e *Ed25519Signer) AuthType() string {
	return Ed25519Auth
}
